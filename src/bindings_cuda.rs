/* automatically generated by rust-bindgen 0.71.1 */
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(dead_code)]
pub const CUDART_VERSION: u32 = 11080;
pub const __CUDART_API_VERSION: u32 = 11080;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const cudaHostAllocDefault: u32 = 0;
pub const cudaHostAllocPortable: u32 = 1;
pub const cudaHostAllocMapped: u32 = 2;
pub const cudaHostAllocWriteCombined: u32 = 4;
pub const cudaHostRegisterDefault: u32 = 0;
pub const cudaHostRegisterPortable: u32 = 1;
pub const cudaHostRegisterMapped: u32 = 2;
pub const cudaHostRegisterIoMemory: u32 = 4;
pub const cudaHostRegisterReadOnly: u32 = 8;
pub const cudaPeerAccessDefault: u32 = 0;
pub const cudaStreamDefault: u32 = 0;
pub const cudaStreamNonBlocking: u32 = 1;
pub const cudaEventDefault: u32 = 0;
pub const cudaEventBlockingSync: u32 = 1;
pub const cudaEventDisableTiming: u32 = 2;
pub const cudaEventInterprocess: u32 = 4;
pub const cudaEventRecordDefault: u32 = 0;
pub const cudaEventRecordExternal: u32 = 1;
pub const cudaEventWaitDefault: u32 = 0;
pub const cudaEventWaitExternal: u32 = 1;
pub const cudaDeviceScheduleAuto: u32 = 0;
pub const cudaDeviceScheduleSpin: u32 = 1;
pub const cudaDeviceScheduleYield: u32 = 2;
pub const cudaDeviceScheduleBlockingSync: u32 = 4;
pub const cudaDeviceBlockingSync: u32 = 4;
pub const cudaDeviceScheduleMask: u32 = 7;
pub const cudaDeviceMapHost: u32 = 8;
pub const cudaDeviceLmemResizeToMax: u32 = 16;
pub const cudaDeviceMask: u32 = 31;
pub const cudaArrayDefault: u32 = 0;
pub const cudaArrayLayered: u32 = 1;
pub const cudaArraySurfaceLoadStore: u32 = 2;
pub const cudaArrayCubemap: u32 = 4;
pub const cudaArrayTextureGather: u32 = 8;
pub const cudaArrayColorAttachment: u32 = 32;
pub const cudaArraySparse: u32 = 64;
pub const cudaArrayDeferredMapping: u32 = 128;
pub const cudaIpcMemLazyEnablePeerAccess: u32 = 1;
pub const cudaMemAttachGlobal: u32 = 1;
pub const cudaMemAttachHost: u32 = 2;
pub const cudaMemAttachSingle: u32 = 4;
pub const cudaOccupancyDefault: u32 = 0;
pub const cudaOccupancyDisableCachingOverride: u32 = 1;
pub const cudaCooperativeLaunchMultiDeviceNoPreSync: u32 = 1;
pub const cudaCooperativeLaunchMultiDeviceNoPostSync: u32 = 2;
pub const cudaArraySparsePropertiesSingleMipTail: u32 = 1;
pub const CUDA_IPC_HANDLE_SIZE: u32 = 64;
pub const cudaExternalMemoryDedicated: u32 = 1;
pub const cudaExternalSemaphoreSignalSkipNvSciBufMemSync: u32 = 1;
pub const cudaExternalSemaphoreWaitSkipNvSciBufMemSync: u32 = 2;
pub const cudaNvSciSyncAttrSignal: u32 = 1;
pub const cudaNvSciSyncAttrWait: u32 = 2;
pub const cudaSurfaceType1D: u32 = 1;
pub const cudaSurfaceType2D: u32 = 2;
pub const cudaSurfaceType3D: u32 = 3;
pub const cudaSurfaceTypeCubemap: u32 = 12;
pub const cudaSurfaceType1DLayered: u32 = 241;
pub const cudaSurfaceType2DLayered: u32 = 242;
pub const cudaSurfaceTypeCubemapLayered: u32 = 252;
pub const cudaTextureType1D: u32 = 1;
pub const cudaTextureType2D: u32 = 2;
pub const cudaTextureType3D: u32 = 3;
pub const cudaTextureTypeCubemap: u32 = 12;
pub const cudaTextureType1DLayered: u32 = 241;
pub const cudaTextureType2DLayered: u32 = 242;
pub const cudaTextureTypeCubemapLayered: u32 = 252;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const _DOMAIN: u32 = 1;
pub const _SING: u32 = 2;
pub const _OVERFLOW: u32 = 3;
pub const _UNDERFLOW: u32 = 4;
pub const _TLOSS: u32 = 5;
pub const _PLOSS: u32 = 6;
pub const _HUGE_ENUF: f64 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0;
pub const _DENORM: i32 = -2;
pub const _FINITE: i32 = -1;
pub const _INFCODE: u32 = 1;
pub const _NANCODE: u32 = 2;
pub const FP_INFINITE: u32 = 1;
pub const FP_NAN: u32 = 2;
pub const FP_NORMAL: i32 = -1;
pub const FP_SUBNORMAL: i32 = -2;
pub const FP_ZERO: u32 = 0;
pub const _C2: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const _FE_DIVBYZERO: u32 = 4;
pub const _FE_INEXACT: u32 = 32;
pub const _FE_INVALID: u32 = 1;
pub const _FE_OVERFLOW: u32 = 8;
pub const _FE_UNDERFLOW: u32 = 16;
pub const _D0_C: u32 = 3;
pub const _D1_C: u32 = 2;
pub const _D2_C: u32 = 1;
pub const _D3_C: u32 = 0;
pub const _DBIAS: u32 = 1022;
pub const _DOFF: u32 = 4;
pub const _F0_C: u32 = 1;
pub const _F1_C: u32 = 0;
pub const _FBIAS: u32 = 126;
pub const _FOFF: u32 = 7;
pub const _FRND: u32 = 1;
pub const _L0_C: u32 = 3;
pub const _L1_C: u32 = 2;
pub const _L2_C: u32 = 1;
pub const _L3_C: u32 = 0;
pub const _LBIAS: u32 = 1022;
pub const _LOFF: u32 = 4;
pub const _FP_LT: u32 = 1;
pub const _FP_EQ: u32 = 2;
pub const _FP_GT: u32 = 4;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const CUBLAS_VER_MAJOR: u32 = 11;
pub const CUBLAS_VER_MINOR: u32 = 11;
pub const CUBLAS_VER_PATCH: u32 = 3;
pub const CUBLAS_VER_BUILD: u32 = 6;
pub const CUBLAS_VERSION: u32 = 111103;
pub const CUSOLVER_VER_MAJOR: u32 = 11;
pub const CUSOLVER_VER_MINOR: u32 = 4;
pub const CUSOLVER_VER_PATCH: u32 = 1;
pub const CUSOLVER_VER_BUILD: u32 = 48;
pub const CUSOLVER_VERSION: u32 = 11401;
pub const CUFFT_VER_MAJOR: u32 = 10;
pub const CUFFT_VER_MINOR: u32 = 9;
pub const CUFFT_VER_PATCH: u32 = 0;
pub const CUFFT_VER_BUILD: u32 = 58;
pub const CUFFT_VERSION: u32 = 10900;
pub const MAX_CUFFT_ERROR: u32 = 17;
pub const CUFFT_FORWARD: i32 = -1;
pub const CUFFT_INVERSE: u32 = 1;
pub const MAX_SHIM_RANK: u32 = 3;
pub const cudaRoundMode_cudaRoundNearest: cudaRoundMode = 0;
pub const cudaRoundMode_cudaRoundZero: cudaRoundMode = 1;
pub const cudaRoundMode_cudaRoundPosInf: cudaRoundMode = 2;
pub const cudaRoundMode_cudaRoundMinInf: cudaRoundMode = 3;
#[doc = "                                                                              *\n                                                                              *\n                                                                              *"]
pub type cudaRoundMode = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char1 {
    pub x: ::std::os::raw::c_schar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of char1"][::std::mem::size_of::<char1>() - 1usize];
    ["Alignment of char1"][::std::mem::align_of::<char1>() - 1usize];
    ["Offset of field: char1::x"][::std::mem::offset_of!(char1, x) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar1 {
    pub x: ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uchar1"][::std::mem::size_of::<uchar1>() - 1usize];
    ["Alignment of uchar1"][::std::mem::align_of::<uchar1>() - 1usize];
    ["Offset of field: uchar1::x"][::std::mem::offset_of!(uchar1, x) - 0usize];
};
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct char2 {
    pub x: ::std::os::raw::c_schar,
    pub y: ::std::os::raw::c_schar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of char2"][::std::mem::size_of::<char2>() - 2usize];
    ["Alignment of char2"][::std::mem::align_of::<char2>() - 2usize];
    ["Offset of field: char2::x"][::std::mem::offset_of!(char2, x) - 0usize];
    ["Offset of field: char2::y"][::std::mem::offset_of!(char2, y) - 1usize];
};
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct uchar2 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uchar2"][::std::mem::size_of::<uchar2>() - 2usize];
    ["Alignment of uchar2"][::std::mem::align_of::<uchar2>() - 2usize];
    ["Offset of field: uchar2::x"][::std::mem::offset_of!(uchar2, x) - 0usize];
    ["Offset of field: uchar2::y"][::std::mem::offset_of!(uchar2, y) - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char3 {
    pub x: ::std::os::raw::c_schar,
    pub y: ::std::os::raw::c_schar,
    pub z: ::std::os::raw::c_schar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of char3"][::std::mem::size_of::<char3>() - 3usize];
    ["Alignment of char3"][::std::mem::align_of::<char3>() - 1usize];
    ["Offset of field: char3::x"][::std::mem::offset_of!(char3, x) - 0usize];
    ["Offset of field: char3::y"][::std::mem::offset_of!(char3, y) - 1usize];
    ["Offset of field: char3::z"][::std::mem::offset_of!(char3, z) - 2usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar3 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
    pub z: ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uchar3"][::std::mem::size_of::<uchar3>() - 3usize];
    ["Alignment of uchar3"][::std::mem::align_of::<uchar3>() - 1usize];
    ["Offset of field: uchar3::x"][::std::mem::offset_of!(uchar3, x) - 0usize];
    ["Offset of field: uchar3::y"][::std::mem::offset_of!(uchar3, y) - 1usize];
    ["Offset of field: uchar3::z"][::std::mem::offset_of!(uchar3, z) - 2usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct char4 {
    pub x: ::std::os::raw::c_schar,
    pub y: ::std::os::raw::c_schar,
    pub z: ::std::os::raw::c_schar,
    pub w: ::std::os::raw::c_schar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of char4"][::std::mem::size_of::<char4>() - 4usize];
    ["Alignment of char4"][::std::mem::align_of::<char4>() - 4usize];
    ["Offset of field: char4::x"][::std::mem::offset_of!(char4, x) - 0usize];
    ["Offset of field: char4::y"][::std::mem::offset_of!(char4, y) - 1usize];
    ["Offset of field: char4::z"][::std::mem::offset_of!(char4, z) - 2usize];
    ["Offset of field: char4::w"][::std::mem::offset_of!(char4, w) - 3usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uchar4 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
    pub z: ::std::os::raw::c_uchar,
    pub w: ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uchar4"][::std::mem::size_of::<uchar4>() - 4usize];
    ["Alignment of uchar4"][::std::mem::align_of::<uchar4>() - 4usize];
    ["Offset of field: uchar4::x"][::std::mem::offset_of!(uchar4, x) - 0usize];
    ["Offset of field: uchar4::y"][::std::mem::offset_of!(uchar4, y) - 1usize];
    ["Offset of field: uchar4::z"][::std::mem::offset_of!(uchar4, z) - 2usize];
    ["Offset of field: uchar4::w"][::std::mem::offset_of!(uchar4, w) - 3usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short1 {
    pub x: ::std::os::raw::c_short,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of short1"][::std::mem::size_of::<short1>() - 2usize];
    ["Alignment of short1"][::std::mem::align_of::<short1>() - 2usize];
    ["Offset of field: short1::x"][::std::mem::offset_of!(short1, x) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort1 {
    pub x: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ushort1"][::std::mem::size_of::<ushort1>() - 2usize];
    ["Alignment of ushort1"][::std::mem::align_of::<ushort1>() - 2usize];
    ["Offset of field: ushort1::x"][::std::mem::offset_of!(ushort1, x) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct short2 {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of short2"][::std::mem::size_of::<short2>() - 4usize];
    ["Alignment of short2"][::std::mem::align_of::<short2>() - 4usize];
    ["Offset of field: short2::x"][::std::mem::offset_of!(short2, x) - 0usize];
    ["Offset of field: short2::y"][::std::mem::offset_of!(short2, y) - 2usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ushort2 {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ushort2"][::std::mem::size_of::<ushort2>() - 4usize];
    ["Alignment of ushort2"][::std::mem::align_of::<ushort2>() - 4usize];
    ["Offset of field: ushort2::x"][::std::mem::offset_of!(ushort2, x) - 0usize];
    ["Offset of field: ushort2::y"][::std::mem::offset_of!(ushort2, y) - 2usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short3 {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub z: ::std::os::raw::c_short,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of short3"][::std::mem::size_of::<short3>() - 6usize];
    ["Alignment of short3"][::std::mem::align_of::<short3>() - 2usize];
    ["Offset of field: short3::x"][::std::mem::offset_of!(short3, x) - 0usize];
    ["Offset of field: short3::y"][::std::mem::offset_of!(short3, y) - 2usize];
    ["Offset of field: short3::z"][::std::mem::offset_of!(short3, z) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort3 {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
    pub z: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ushort3"][::std::mem::size_of::<ushort3>() - 6usize];
    ["Alignment of ushort3"][::std::mem::align_of::<ushort3>() - 2usize];
    ["Offset of field: ushort3::x"][::std::mem::offset_of!(ushort3, x) - 0usize];
    ["Offset of field: ushort3::y"][::std::mem::offset_of!(ushort3, y) - 2usize];
    ["Offset of field: ushort3::z"][::std::mem::offset_of!(ushort3, z) - 4usize];
};
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct short4 {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub z: ::std::os::raw::c_short,
    pub w: ::std::os::raw::c_short,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of short4"][::std::mem::size_of::<short4>() - 8usize];
    ["Alignment of short4"][::std::mem::align_of::<short4>() - 8usize];
    ["Offset of field: short4::x"][::std::mem::offset_of!(short4, x) - 0usize];
    ["Offset of field: short4::y"][::std::mem::offset_of!(short4, y) - 2usize];
    ["Offset of field: short4::z"][::std::mem::offset_of!(short4, z) - 4usize];
    ["Offset of field: short4::w"][::std::mem::offset_of!(short4, w) - 6usize];
};
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ushort4 {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
    pub z: ::std::os::raw::c_ushort,
    pub w: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ushort4"][::std::mem::size_of::<ushort4>() - 8usize];
    ["Alignment of ushort4"][::std::mem::align_of::<ushort4>() - 8usize];
    ["Offset of field: ushort4::x"][::std::mem::offset_of!(ushort4, x) - 0usize];
    ["Offset of field: ushort4::y"][::std::mem::offset_of!(ushort4, y) - 2usize];
    ["Offset of field: ushort4::z"][::std::mem::offset_of!(ushort4, z) - 4usize];
    ["Offset of field: ushort4::w"][::std::mem::offset_of!(ushort4, w) - 6usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int1 {
    pub x: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of int1"][::std::mem::size_of::<int1>() - 4usize];
    ["Alignment of int1"][::std::mem::align_of::<int1>() - 4usize];
    ["Offset of field: int1::x"][::std::mem::offset_of!(int1, x) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint1 {
    pub x: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uint1"][::std::mem::size_of::<uint1>() - 4usize];
    ["Alignment of uint1"][::std::mem::align_of::<uint1>() - 4usize];
    ["Offset of field: uint1::x"][::std::mem::offset_of!(uint1, x) - 0usize];
};
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct int2 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of int2"][::std::mem::size_of::<int2>() - 8usize];
    ["Alignment of int2"][::std::mem::align_of::<int2>() - 8usize];
    ["Offset of field: int2::x"][::std::mem::offset_of!(int2, x) - 0usize];
    ["Offset of field: int2::y"][::std::mem::offset_of!(int2, y) - 4usize];
};
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct uint2 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uint2"][::std::mem::size_of::<uint2>() - 8usize];
    ["Alignment of uint2"][::std::mem::align_of::<uint2>() - 8usize];
    ["Offset of field: uint2::x"][::std::mem::offset_of!(uint2, x) - 0usize];
    ["Offset of field: uint2::y"][::std::mem::offset_of!(uint2, y) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int3 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of int3"][::std::mem::size_of::<int3>() - 12usize];
    ["Alignment of int3"][::std::mem::align_of::<int3>() - 4usize];
    ["Offset of field: int3::x"][::std::mem::offset_of!(int3, x) - 0usize];
    ["Offset of field: int3::y"][::std::mem::offset_of!(int3, y) - 4usize];
    ["Offset of field: int3::z"][::std::mem::offset_of!(int3, z) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint3 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uint3"][::std::mem::size_of::<uint3>() - 12usize];
    ["Alignment of uint3"][::std::mem::align_of::<uint3>() - 4usize];
    ["Offset of field: uint3::x"][::std::mem::offset_of!(uint3, x) - 0usize];
    ["Offset of field: uint3::y"][::std::mem::offset_of!(uint3, y) - 4usize];
    ["Offset of field: uint3::z"][::std::mem::offset_of!(uint3, z) - 8usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct int4 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of int4"][::std::mem::size_of::<int4>() - 16usize];
    ["Alignment of int4"][::std::mem::align_of::<int4>() - 16usize];
    ["Offset of field: int4::x"][::std::mem::offset_of!(int4, x) - 0usize];
    ["Offset of field: int4::y"][::std::mem::offset_of!(int4, y) - 4usize];
    ["Offset of field: int4::z"][::std::mem::offset_of!(int4, z) - 8usize];
    ["Offset of field: int4::w"][::std::mem::offset_of!(int4, w) - 12usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct uint4 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
    pub w: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uint4"][::std::mem::size_of::<uint4>() - 16usize];
    ["Alignment of uint4"][::std::mem::align_of::<uint4>() - 16usize];
    ["Offset of field: uint4::x"][::std::mem::offset_of!(uint4, x) - 0usize];
    ["Offset of field: uint4::y"][::std::mem::offset_of!(uint4, y) - 4usize];
    ["Offset of field: uint4::z"][::std::mem::offset_of!(uint4, z) - 8usize];
    ["Offset of field: uint4::w"][::std::mem::offset_of!(uint4, w) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long1 {
    pub x: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of long1"][::std::mem::size_of::<long1>() - 4usize];
    ["Alignment of long1"][::std::mem::align_of::<long1>() - 4usize];
    ["Offset of field: long1::x"][::std::mem::offset_of!(long1, x) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong1 {
    pub x: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ulong1"][::std::mem::size_of::<ulong1>() - 4usize];
    ["Alignment of ulong1"][::std::mem::align_of::<ulong1>() - 4usize];
    ["Offset of field: ulong1::x"][::std::mem::offset_of!(ulong1, x) - 0usize];
};
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct long2 {
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of long2"][::std::mem::size_of::<long2>() - 8usize];
    ["Alignment of long2"][::std::mem::align_of::<long2>() - 8usize];
    ["Offset of field: long2::x"][::std::mem::offset_of!(long2, x) - 0usize];
    ["Offset of field: long2::y"][::std::mem::offset_of!(long2, y) - 4usize];
};
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ulong2 {
    pub x: ::std::os::raw::c_ulong,
    pub y: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ulong2"][::std::mem::size_of::<ulong2>() - 8usize];
    ["Alignment of ulong2"][::std::mem::align_of::<ulong2>() - 8usize];
    ["Offset of field: ulong2::x"][::std::mem::offset_of!(ulong2, x) - 0usize];
    ["Offset of field: ulong2::y"][::std::mem::offset_of!(ulong2, y) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long3 {
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
    pub z: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of long3"][::std::mem::size_of::<long3>() - 12usize];
    ["Alignment of long3"][::std::mem::align_of::<long3>() - 4usize];
    ["Offset of field: long3::x"][::std::mem::offset_of!(long3, x) - 0usize];
    ["Offset of field: long3::y"][::std::mem::offset_of!(long3, y) - 4usize];
    ["Offset of field: long3::z"][::std::mem::offset_of!(long3, z) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong3 {
    pub x: ::std::os::raw::c_ulong,
    pub y: ::std::os::raw::c_ulong,
    pub z: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ulong3"][::std::mem::size_of::<ulong3>() - 12usize];
    ["Alignment of ulong3"][::std::mem::align_of::<ulong3>() - 4usize];
    ["Offset of field: ulong3::x"][::std::mem::offset_of!(ulong3, x) - 0usize];
    ["Offset of field: ulong3::y"][::std::mem::offset_of!(ulong3, y) - 4usize];
    ["Offset of field: ulong3::z"][::std::mem::offset_of!(ulong3, z) - 8usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct long4 {
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
    pub z: ::std::os::raw::c_long,
    pub w: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of long4"][::std::mem::size_of::<long4>() - 16usize];
    ["Alignment of long4"][::std::mem::align_of::<long4>() - 16usize];
    ["Offset of field: long4::x"][::std::mem::offset_of!(long4, x) - 0usize];
    ["Offset of field: long4::y"][::std::mem::offset_of!(long4, y) - 4usize];
    ["Offset of field: long4::z"][::std::mem::offset_of!(long4, z) - 8usize];
    ["Offset of field: long4::w"][::std::mem::offset_of!(long4, w) - 12usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ulong4 {
    pub x: ::std::os::raw::c_ulong,
    pub y: ::std::os::raw::c_ulong,
    pub z: ::std::os::raw::c_ulong,
    pub w: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ulong4"][::std::mem::size_of::<ulong4>() - 16usize];
    ["Alignment of ulong4"][::std::mem::align_of::<ulong4>() - 16usize];
    ["Offset of field: ulong4::x"][::std::mem::offset_of!(ulong4, x) - 0usize];
    ["Offset of field: ulong4::y"][::std::mem::offset_of!(ulong4, y) - 4usize];
    ["Offset of field: ulong4::z"][::std::mem::offset_of!(ulong4, z) - 8usize];
    ["Offset of field: ulong4::w"][::std::mem::offset_of!(ulong4, w) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float1 {
    pub x: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of float1"][::std::mem::size_of::<float1>() - 4usize];
    ["Alignment of float1"][::std::mem::align_of::<float1>() - 4usize];
    ["Offset of field: float1::x"][::std::mem::offset_of!(float1, x) - 0usize];
};
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct float2 {
    pub x: f32,
    pub y: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of float2"][::std::mem::size_of::<float2>() - 8usize];
    ["Alignment of float2"][::std::mem::align_of::<float2>() - 8usize];
    ["Offset of field: float2::x"][::std::mem::offset_of!(float2, x) - 0usize];
    ["Offset of field: float2::y"][::std::mem::offset_of!(float2, y) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of float3"][::std::mem::size_of::<float3>() - 12usize];
    ["Alignment of float3"][::std::mem::align_of::<float3>() - 4usize];
    ["Offset of field: float3::x"][::std::mem::offset_of!(float3, x) - 0usize];
    ["Offset of field: float3::y"][::std::mem::offset_of!(float3, y) - 4usize];
    ["Offset of field: float3::z"][::std::mem::offset_of!(float3, z) - 8usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct float4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of float4"][::std::mem::size_of::<float4>() - 16usize];
    ["Alignment of float4"][::std::mem::align_of::<float4>() - 16usize];
    ["Offset of field: float4::x"][::std::mem::offset_of!(float4, x) - 0usize];
    ["Offset of field: float4::y"][::std::mem::offset_of!(float4, y) - 4usize];
    ["Offset of field: float4::z"][::std::mem::offset_of!(float4, z) - 8usize];
    ["Offset of field: float4::w"][::std::mem::offset_of!(float4, w) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong1 {
    pub x: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of longlong1"][::std::mem::size_of::<longlong1>() - 8usize];
    ["Alignment of longlong1"][::std::mem::align_of::<longlong1>() - 8usize];
    ["Offset of field: longlong1::x"][::std::mem::offset_of!(longlong1, x) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong1 {
    pub x: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ulonglong1"][::std::mem::size_of::<ulonglong1>() - 8usize];
    ["Alignment of ulonglong1"][::std::mem::align_of::<ulonglong1>() - 8usize];
    ["Offset of field: ulonglong1::x"][::std::mem::offset_of!(ulonglong1, x) - 0usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct longlong2 {
    pub x: ::std::os::raw::c_longlong,
    pub y: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of longlong2"][::std::mem::size_of::<longlong2>() - 16usize];
    ["Alignment of longlong2"][::std::mem::align_of::<longlong2>() - 16usize];
    ["Offset of field: longlong2::x"][::std::mem::offset_of!(longlong2, x) - 0usize];
    ["Offset of field: longlong2::y"][::std::mem::offset_of!(longlong2, y) - 8usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong2 {
    pub x: ::std::os::raw::c_ulonglong,
    pub y: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ulonglong2"][::std::mem::size_of::<ulonglong2>() - 16usize];
    ["Alignment of ulonglong2"][::std::mem::align_of::<ulonglong2>() - 16usize];
    ["Offset of field: ulonglong2::x"][::std::mem::offset_of!(ulonglong2, x) - 0usize];
    ["Offset of field: ulonglong2::y"][::std::mem::offset_of!(ulonglong2, y) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong3 {
    pub x: ::std::os::raw::c_longlong,
    pub y: ::std::os::raw::c_longlong,
    pub z: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of longlong3"][::std::mem::size_of::<longlong3>() - 24usize];
    ["Alignment of longlong3"][::std::mem::align_of::<longlong3>() - 8usize];
    ["Offset of field: longlong3::x"][::std::mem::offset_of!(longlong3, x) - 0usize];
    ["Offset of field: longlong3::y"][::std::mem::offset_of!(longlong3, y) - 8usize];
    ["Offset of field: longlong3::z"][::std::mem::offset_of!(longlong3, z) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong3 {
    pub x: ::std::os::raw::c_ulonglong,
    pub y: ::std::os::raw::c_ulonglong,
    pub z: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ulonglong3"][::std::mem::size_of::<ulonglong3>() - 24usize];
    ["Alignment of ulonglong3"][::std::mem::align_of::<ulonglong3>() - 8usize];
    ["Offset of field: ulonglong3::x"][::std::mem::offset_of!(ulonglong3, x) - 0usize];
    ["Offset of field: ulonglong3::y"][::std::mem::offset_of!(ulonglong3, y) - 8usize];
    ["Offset of field: ulonglong3::z"][::std::mem::offset_of!(ulonglong3, z) - 16usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct longlong4 {
    pub x: ::std::os::raw::c_longlong,
    pub y: ::std::os::raw::c_longlong,
    pub z: ::std::os::raw::c_longlong,
    pub w: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of longlong4"][::std::mem::size_of::<longlong4>() - 32usize];
    ["Alignment of longlong4"][::std::mem::align_of::<longlong4>() - 16usize];
    ["Offset of field: longlong4::x"][::std::mem::offset_of!(longlong4, x) - 0usize];
    ["Offset of field: longlong4::y"][::std::mem::offset_of!(longlong4, y) - 8usize];
    ["Offset of field: longlong4::z"][::std::mem::offset_of!(longlong4, z) - 16usize];
    ["Offset of field: longlong4::w"][::std::mem::offset_of!(longlong4, w) - 24usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong4 {
    pub x: ::std::os::raw::c_ulonglong,
    pub y: ::std::os::raw::c_ulonglong,
    pub z: ::std::os::raw::c_ulonglong,
    pub w: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ulonglong4"][::std::mem::size_of::<ulonglong4>() - 32usize];
    ["Alignment of ulonglong4"][::std::mem::align_of::<ulonglong4>() - 16usize];
    ["Offset of field: ulonglong4::x"][::std::mem::offset_of!(ulonglong4, x) - 0usize];
    ["Offset of field: ulonglong4::y"][::std::mem::offset_of!(ulonglong4, y) - 8usize];
    ["Offset of field: ulonglong4::z"][::std::mem::offset_of!(ulonglong4, z) - 16usize];
    ["Offset of field: ulonglong4::w"][::std::mem::offset_of!(ulonglong4, w) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double1 {
    pub x: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of double1"][::std::mem::size_of::<double1>() - 8usize];
    ["Alignment of double1"][::std::mem::align_of::<double1>() - 8usize];
    ["Offset of field: double1::x"][::std::mem::offset_of!(double1, x) - 0usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct double2 {
    pub x: f64,
    pub y: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of double2"][::std::mem::size_of::<double2>() - 16usize];
    ["Alignment of double2"][::std::mem::align_of::<double2>() - 16usize];
    ["Offset of field: double2::x"][::std::mem::offset_of!(double2, x) - 0usize];
    ["Offset of field: double2::y"][::std::mem::offset_of!(double2, y) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double3 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of double3"][::std::mem::size_of::<double3>() - 24usize];
    ["Alignment of double3"][::std::mem::align_of::<double3>() - 8usize];
    ["Offset of field: double3::x"][::std::mem::offset_of!(double3, x) - 0usize];
    ["Offset of field: double3::y"][::std::mem::offset_of!(double3, y) - 8usize];
    ["Offset of field: double3::z"][::std::mem::offset_of!(double3, z) - 16usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct double4 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of double4"][::std::mem::size_of::<double4>() - 32usize];
    ["Alignment of double4"][::std::mem::align_of::<double4>() - 16usize];
    ["Offset of field: double4::x"][::std::mem::offset_of!(double4, x) - 0usize];
    ["Offset of field: double4::y"][::std::mem::offset_of!(double4, y) - 8usize];
    ["Offset of field: double4::z"][::std::mem::offset_of!(double4, z) - 16usize];
    ["Offset of field: double4::w"][::std::mem::offset_of!(double4, w) - 24usize];
};
#[doc = "                                                                              *\n                                                                              *\n                                                                              *"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim3 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dim3"][::std::mem::size_of::<dim3>() - 12usize];
    ["Alignment of dim3"][::std::mem::align_of::<dim3>() - 4usize];
    ["Offset of field: dim3::x"][::std::mem::offset_of!(dim3, x) - 0usize];
    ["Offset of field: dim3::y"][::std::mem::offset_of!(dim3, y) - 4usize];
    ["Offset of field: dim3::z"][::std::mem::offset_of!(dim3, z) - 8usize];
};
pub type va_list = *mut ::std::os::raw::c_char;
unsafe extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
unsafe extern "C" {
    pub fn __security_init_cookie();
}
unsafe extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
unsafe extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
unsafe extern "C" {
    pub static mut __security_cookie: usize;
}
pub type max_align_t = f64;
#[doc = " The API call returned with no errors. In the case of query calls, this\n also means that the operation being queried is complete (see\n ::cudaEventQuery() and ::cudaStreamQuery())."]
pub const cudaError_cudaSuccess: cudaError = 0;
#[doc = " This indicates that one or more of the parameters passed to the API call\n is not within an acceptable range of values."]
pub const cudaError_cudaErrorInvalidValue: cudaError = 1;
#[doc = " The API call failed because it was unable to allocate enough memory to\n perform the requested operation."]
pub const cudaError_cudaErrorMemoryAllocation: cudaError = 2;
#[doc = " The API call failed because the CUDA driver and runtime could not be\n initialized."]
pub const cudaError_cudaErrorInitializationError: cudaError = 3;
#[doc = " This indicates that a CUDA Runtime API call cannot be executed because\n it is being called during process shut down, at a point in time after\n CUDA driver has been unloaded."]
pub const cudaError_cudaErrorCudartUnloading: cudaError = 4;
#[doc = " This indicates profiler is not initialized for this run. This can\n happen when the application is running with external profiling tools\n like visual profiler."]
pub const cudaError_cudaErrorProfilerDisabled: cudaError = 5;
#[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to attempt to enable/disable the profiling via ::cudaProfilerStart or\n ::cudaProfilerStop without initialization."]
pub const cudaError_cudaErrorProfilerNotInitialized: cudaError = 6;
#[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to call cudaProfilerStart() when profiling is already enabled."]
pub const cudaError_cudaErrorProfilerAlreadyStarted: cudaError = 7;
#[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to call cudaProfilerStop() when profiling is already disabled."]
pub const cudaError_cudaErrorProfilerAlreadyStopped: cudaError = 8;
#[doc = " This indicates that a kernel launch is requesting resources that can\n never be satisfied by the current device. Requesting more shared memory\n per block than the device supports will trigger this error, as will\n requesting too many threads or blocks. See ::cudaDeviceProp for more\n device limitations."]
pub const cudaError_cudaErrorInvalidConfiguration: cudaError = 9;
#[doc = " This indicates that one or more of the pitch-related parameters passed\n to the API call is not within the acceptable range for pitch."]
pub const cudaError_cudaErrorInvalidPitchValue: cudaError = 12;
#[doc = " This indicates that the symbol name/identifier passed to the API call\n is not a valid name or identifier."]
pub const cudaError_cudaErrorInvalidSymbol: cudaError = 13;
#[doc = " This indicates that at least one host pointer passed to the API call is\n not a valid host pointer.\n \\deprecated\n This error return is deprecated as of CUDA 10.1."]
pub const cudaError_cudaErrorInvalidHostPointer: cudaError = 16;
#[doc = " This indicates that at least one device pointer passed to the API call is\n not a valid device pointer.\n \\deprecated\n This error return is deprecated as of CUDA 10.1."]
pub const cudaError_cudaErrorInvalidDevicePointer: cudaError = 17;
#[doc = " This indicates that the texture passed to the API call is not a valid\n texture."]
pub const cudaError_cudaErrorInvalidTexture: cudaError = 18;
#[doc = " This indicates that the texture binding is not valid. This occurs if you\n call ::cudaGetTextureAlignmentOffset() with an unbound texture."]
pub const cudaError_cudaErrorInvalidTextureBinding: cudaError = 19;
#[doc = " This indicates that the channel descriptor passed to the API call is not\n valid. This occurs if the format is not one of the formats specified by\n ::cudaChannelFormatKind, or if one of the dimensions is invalid."]
pub const cudaError_cudaErrorInvalidChannelDescriptor: cudaError = 20;
#[doc = " This indicates that the direction of the memcpy passed to the API call is\n not one of the types specified by ::cudaMemcpyKind."]
pub const cudaError_cudaErrorInvalidMemcpyDirection: cudaError = 21;
#[doc = " This indicated that the user has taken the address of a constant variable,\n which was forbidden up until the CUDA 3.1 release.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Variables in constant\n memory may now have their address taken by the runtime via\n ::cudaGetSymbolAddress()."]
pub const cudaError_cudaErrorAddressOfConstant: cudaError = 22;
#[doc = " This indicated that a texture fetch was not able to be performed.\n This was previously used for device emulation of texture operations.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorTextureFetchFailed: cudaError = 23;
#[doc = " This indicated that a texture was not bound for access.\n This was previously used for device emulation of texture operations.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorTextureNotBound: cudaError = 24;
#[doc = " This indicated that a synchronization operation had failed.\n This was previously used for some device emulation functions.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorSynchronizationError: cudaError = 25;
#[doc = " This indicates that a non-float texture was being accessed with linear\n filtering. This is not supported by CUDA."]
pub const cudaError_cudaErrorInvalidFilterSetting: cudaError = 26;
#[doc = " This indicates that an attempt was made to read a non-float texture as a\n normalized float. This is not supported by CUDA."]
pub const cudaError_cudaErrorInvalidNormSetting: cudaError = 27;
#[doc = " Mixing of device and device emulation code was not allowed.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorMixedDeviceExecution: cudaError = 28;
#[doc = " This indicates that the API call is not yet implemented. Production\n releases of CUDA will never return this error.\n \\deprecated\n This error return is deprecated as of CUDA 4.1."]
pub const cudaError_cudaErrorNotYetImplemented: cudaError = 31;
#[doc = " This indicated that an emulated device pointer exceeded the 32-bit address\n range.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorMemoryValueTooLarge: cudaError = 32;
#[doc = " This indicates that the CUDA driver that the application has loaded is a\n stub library. Applications that run with the stub rather than a real\n driver loaded will result in CUDA API returning this error."]
pub const cudaError_cudaErrorStubLibrary: cudaError = 34;
#[doc = " This indicates that the installed NVIDIA CUDA driver is older than the\n CUDA runtime library. This is not a supported configuration. Users should\n install an updated NVIDIA display driver to allow the application to run."]
pub const cudaError_cudaErrorInsufficientDriver: cudaError = 35;
#[doc = " This indicates that the API call requires a newer CUDA driver than the one\n currently installed. Users should install an updated NVIDIA CUDA driver\n to allow the API call to succeed."]
pub const cudaError_cudaErrorCallRequiresNewerDriver: cudaError = 36;
#[doc = " This indicates that the surface passed to the API call is not a valid\n surface."]
pub const cudaError_cudaErrorInvalidSurface: cudaError = 37;
#[doc = " This indicates that multiple global or constant variables (across separate\n CUDA source files in the application) share the same string name."]
pub const cudaError_cudaErrorDuplicateVariableName: cudaError = 43;
#[doc = " This indicates that multiple textures (across separate CUDA source\n files in the application) share the same string name."]
pub const cudaError_cudaErrorDuplicateTextureName: cudaError = 44;
#[doc = " This indicates that multiple surfaces (across separate CUDA source\n files in the application) share the same string name."]
pub const cudaError_cudaErrorDuplicateSurfaceName: cudaError = 45;
#[doc = " This indicates that all CUDA devices are busy or unavailable at the current\n time. Devices are often busy/unavailable due to use of\n ::cudaComputeModeProhibited, ::cudaComputeModeExclusiveProcess, or when long\n running CUDA kernels have filled up the GPU and are blocking new work\n from starting. They can also be unavailable due to memory constraints\n on a device that already has active CUDA work being performed."]
pub const cudaError_cudaErrorDevicesUnavailable: cudaError = 46;
#[doc = " This indicates that the current context is not compatible with this\n the CUDA Runtime. This can only occur if you are using CUDA\n Runtime/Driver interoperability and have created an existing Driver\n context using the driver API. The Driver context may be incompatible\n either because the Driver context was created using an older version\n of the API, because the Runtime API call expects a primary driver\n context and the Driver context is not primary, or because the Driver\n context has been destroyed. Please see \\ref CUDART_DRIVER \"Interactions\n with the CUDA Driver API\" for more information."]
pub const cudaError_cudaErrorIncompatibleDriverContext: cudaError = 49;
#[doc = " The device function being invoked (usually via ::cudaLaunchKernel()) was not\n previously configured via the ::cudaConfigureCall() function."]
pub const cudaError_cudaErrorMissingConfiguration: cudaError = 52;
#[doc = " This indicated that a previous kernel launch failed. This was previously\n used for device emulation of kernel launches.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorPriorLaunchFailure: cudaError = 53;
#[doc = " This error indicates that a device runtime grid launch did not occur\n because the depth of the child grid would exceed the maximum supported\n number of nested grid launches."]
pub const cudaError_cudaErrorLaunchMaxDepthExceeded: cudaError = 65;
#[doc = " This error indicates that a grid launch did not occur because the kernel\n uses file-scoped textures which are unsupported by the device runtime.\n Kernels launched via the device runtime only support textures created with\n the Texture Object API's."]
pub const cudaError_cudaErrorLaunchFileScopedTex: cudaError = 66;
#[doc = " This error indicates that a grid launch did not occur because the kernel\n uses file-scoped surfaces which are unsupported by the device runtime.\n Kernels launched via the device runtime only support surfaces created with\n the Surface Object API's."]
pub const cudaError_cudaErrorLaunchFileScopedSurf: cudaError = 67;
#[doc = " This error indicates that a call to ::cudaDeviceSynchronize made from\n the device runtime failed because the call was made at grid depth greater\n than than either the default (2 levels of grids) or user specified device\n limit ::cudaLimitDevRuntimeSyncDepth. To be able to synchronize on\n launched grids at a greater depth successfully, the maximum nested\n depth at which ::cudaDeviceSynchronize will be called must be specified\n with the ::cudaLimitDevRuntimeSyncDepth limit to the ::cudaDeviceSetLimit\n api before the host-side launch of a kernel using the device runtime.\n Keep in mind that additional levels of sync depth require the runtime\n to reserve large amounts of device memory that cannot be used for\n user allocations."]
pub const cudaError_cudaErrorSyncDepthExceeded: cudaError = 68;
#[doc = " This error indicates that a device runtime grid launch failed because\n the launch would exceed the limit ::cudaLimitDevRuntimePendingLaunchCount.\n For this launch to proceed successfully, ::cudaDeviceSetLimit must be\n called to set the ::cudaLimitDevRuntimePendingLaunchCount to be higher\n than the upper bound of outstanding launches that can be issued to the\n device runtime. Keep in mind that raising the limit of pending device\n runtime launches will require the runtime to reserve device memory that\n cannot be used for user allocations."]
pub const cudaError_cudaErrorLaunchPendingCountExceeded: cudaError = 69;
#[doc = " The requested device function does not exist or is not compiled for the\n proper device architecture."]
pub const cudaError_cudaErrorInvalidDeviceFunction: cudaError = 98;
#[doc = " This indicates that no CUDA-capable devices were detected by the installed\n CUDA driver."]
pub const cudaError_cudaErrorNoDevice: cudaError = 100;
#[doc = " This indicates that the device ordinal supplied by the user does not\n correspond to a valid CUDA device or that the action requested is\n invalid for the specified device."]
pub const cudaError_cudaErrorInvalidDevice: cudaError = 101;
#[doc = " This indicates that the device doesn't have a valid Grid License."]
pub const cudaError_cudaErrorDeviceNotLicensed: cudaError = 102;
#[doc = " By default, the CUDA runtime may perform a minimal set of self-tests,\n as well as CUDA driver tests, to establish the validity of both.\n Introduced in CUDA 11.2, this error return indicates that at least one\n of these tests has failed and the validity of either the runtime\n or the driver could not be established."]
pub const cudaError_cudaErrorSoftwareValidityNotEstablished: cudaError = 103;
#[doc = " This indicates an internal startup failure in the CUDA runtime."]
pub const cudaError_cudaErrorStartupFailure: cudaError = 127;
#[doc = " This indicates that the device kernel image is invalid."]
pub const cudaError_cudaErrorInvalidKernelImage: cudaError = 200;
#[doc = " This most frequently indicates that there is no context bound to the\n current thread. This can also be returned if the context passed to an\n API call is not a valid handle (such as a context that has had\n ::cuCtxDestroy() invoked on it). This can also be returned if a user\n mixes different API versions (i.e. 3010 context with 3020 API calls).\n See ::cuCtxGetApiVersion() for more details."]
pub const cudaError_cudaErrorDeviceUninitialized: cudaError = 201;
#[doc = " This indicates that the buffer object could not be mapped."]
pub const cudaError_cudaErrorMapBufferObjectFailed: cudaError = 205;
#[doc = " This indicates that the buffer object could not be unmapped."]
pub const cudaError_cudaErrorUnmapBufferObjectFailed: cudaError = 206;
#[doc = " This indicates that the specified array is currently mapped and thus\n cannot be destroyed."]
pub const cudaError_cudaErrorArrayIsMapped: cudaError = 207;
#[doc = " This indicates that the resource is already mapped."]
pub const cudaError_cudaErrorAlreadyMapped: cudaError = 208;
#[doc = " This indicates that there is no kernel image available that is suitable\n for the device. This can occur when a user specifies code generation\n options for a particular CUDA source file that do not include the\n corresponding device configuration."]
pub const cudaError_cudaErrorNoKernelImageForDevice: cudaError = 209;
#[doc = " This indicates that a resource has already been acquired."]
pub const cudaError_cudaErrorAlreadyAcquired: cudaError = 210;
#[doc = " This indicates that a resource is not mapped."]
pub const cudaError_cudaErrorNotMapped: cudaError = 211;
#[doc = " This indicates that a mapped resource is not available for access as an\n array."]
pub const cudaError_cudaErrorNotMappedAsArray: cudaError = 212;
#[doc = " This indicates that a mapped resource is not available for access as a\n pointer."]
pub const cudaError_cudaErrorNotMappedAsPointer: cudaError = 213;
#[doc = " This indicates that an uncorrectable ECC error was detected during\n execution."]
pub const cudaError_cudaErrorECCUncorrectable: cudaError = 214;
#[doc = " This indicates that the ::cudaLimit passed to the API call is not\n supported by the active device."]
pub const cudaError_cudaErrorUnsupportedLimit: cudaError = 215;
#[doc = " This indicates that a call tried to access an exclusive-thread device that\n is already in use by a different thread."]
pub const cudaError_cudaErrorDeviceAlreadyInUse: cudaError = 216;
#[doc = " This error indicates that P2P access is not supported across the given\n devices."]
pub const cudaError_cudaErrorPeerAccessUnsupported: cudaError = 217;
#[doc = " A PTX compilation failed. The runtime may fall back to compiling PTX if\n an application does not contain a suitable binary for the current device."]
pub const cudaError_cudaErrorInvalidPtx: cudaError = 218;
#[doc = " This indicates an error with the OpenGL or DirectX context."]
pub const cudaError_cudaErrorInvalidGraphicsContext: cudaError = 219;
#[doc = " This indicates that an uncorrectable NVLink error was detected during the\n execution."]
pub const cudaError_cudaErrorNvlinkUncorrectable: cudaError = 220;
#[doc = " This indicates that the PTX JIT compiler library was not found. The JIT Compiler\n library is used for PTX compilation. The runtime may fall back to compiling PTX\n if an application does not contain a suitable binary for the current device."]
pub const cudaError_cudaErrorJitCompilerNotFound: cudaError = 221;
#[doc = " This indicates that the provided PTX was compiled with an unsupported toolchain.\n The most common reason for this, is the PTX was generated by a compiler newer\n than what is supported by the CUDA driver and PTX JIT compiler."]
pub const cudaError_cudaErrorUnsupportedPtxVersion: cudaError = 222;
#[doc = " This indicates that the JIT compilation was disabled. The JIT compilation compiles\n PTX. The runtime may fall back to compiling PTX if an application does not contain\n a suitable binary for the current device."]
pub const cudaError_cudaErrorJitCompilationDisabled: cudaError = 223;
#[doc = " This indicates that the provided execution affinity is not supported by the device."]
pub const cudaError_cudaErrorUnsupportedExecAffinity: cudaError = 224;
#[doc = " This indicates that the device kernel source is invalid."]
pub const cudaError_cudaErrorInvalidSource: cudaError = 300;
#[doc = " This indicates that the file specified was not found."]
pub const cudaError_cudaErrorFileNotFound: cudaError = 301;
#[doc = " This indicates that a link to a shared object failed to resolve."]
pub const cudaError_cudaErrorSharedObjectSymbolNotFound: cudaError = 302;
#[doc = " This indicates that initialization of a shared object failed."]
pub const cudaError_cudaErrorSharedObjectInitFailed: cudaError = 303;
#[doc = " This error indicates that an OS call failed."]
pub const cudaError_cudaErrorOperatingSystem: cudaError = 304;
#[doc = " This indicates that a resource handle passed to the API call was not\n valid. Resource handles are opaque types like ::cudaStream_t and\n ::cudaEvent_t."]
pub const cudaError_cudaErrorInvalidResourceHandle: cudaError = 400;
#[doc = " This indicates that a resource required by the API call is not in a\n valid state to perform the requested operation."]
pub const cudaError_cudaErrorIllegalState: cudaError = 401;
#[doc = " This indicates that a named symbol was not found. Examples of symbols\n are global/constant variable names, driver function names, texture names,\n and surface names."]
pub const cudaError_cudaErrorSymbolNotFound: cudaError = 500;
#[doc = " This indicates that asynchronous operations issued previously have not\n completed yet. This result is not actually an error, but must be indicated\n differently than ::cudaSuccess (which indicates completion). Calls that\n may return this value include ::cudaEventQuery() and ::cudaStreamQuery()."]
pub const cudaError_cudaErrorNotReady: cudaError = 600;
#[doc = " The device encountered a load or store instruction on an invalid memory address.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorIllegalAddress: cudaError = 700;
#[doc = " This indicates that a launch did not occur because it did not have\n appropriate resources. Although this error is similar to\n ::cudaErrorInvalidConfiguration, this error usually indicates that the\n user has attempted to pass too many arguments to the device kernel, or the\n kernel launch specifies too many threads for the kernel's register count."]
pub const cudaError_cudaErrorLaunchOutOfResources: cudaError = 701;
#[doc = " This indicates that the device kernel took too long to execute. This can\n only occur if timeouts are enabled - see the device property\n \\ref ::cudaDeviceProp::kernelExecTimeoutEnabled \"kernelExecTimeoutEnabled\"\n for more information.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorLaunchTimeout: cudaError = 702;
#[doc = " This error indicates a kernel launch that uses an incompatible texturing\n mode."]
pub const cudaError_cudaErrorLaunchIncompatibleTexturing: cudaError = 703;
#[doc = " This error indicates that a call to ::cudaDeviceEnablePeerAccess() is\n trying to re-enable peer addressing on from a context which has already\n had peer addressing enabled."]
pub const cudaError_cudaErrorPeerAccessAlreadyEnabled: cudaError = 704;
#[doc = " This error indicates that ::cudaDeviceDisablePeerAccess() is trying to\n disable peer addressing which has not been enabled yet via\n ::cudaDeviceEnablePeerAccess()."]
pub const cudaError_cudaErrorPeerAccessNotEnabled: cudaError = 705;
#[doc = " This indicates that the user has called ::cudaSetValidDevices(),\n ::cudaSetDeviceFlags(), ::cudaD3D9SetDirect3DDevice(),\n ::cudaD3D10SetDirect3DDevice, ::cudaD3D11SetDirect3DDevice(), or\n ::cudaVDPAUSetVDPAUDevice() after initializing the CUDA runtime by\n calling non-device management operations (allocating memory and\n launching kernels are examples of non-device management operations).\n This error can also be returned if using runtime/driver\n interoperability and there is an existing ::CUcontext active on the\n host thread."]
pub const cudaError_cudaErrorSetOnActiveProcess: cudaError = 708;
#[doc = " This error indicates that the context current to the calling thread\n has been destroyed using ::cuCtxDestroy, or is a primary context which\n has not yet been initialized."]
pub const cudaError_cudaErrorContextIsDestroyed: cudaError = 709;
#[doc = " An assert triggered in device code during kernel execution. The device\n cannot be used again. All existing allocations are invalid. To continue\n using CUDA, the process must be terminated and relaunched."]
pub const cudaError_cudaErrorAssert: cudaError = 710;
#[doc = " This error indicates that the hardware resources required to enable\n peer access have been exhausted for one or more of the devices\n passed to ::cudaEnablePeerAccess()."]
pub const cudaError_cudaErrorTooManyPeers: cudaError = 711;
#[doc = " This error indicates that the memory range passed to ::cudaHostRegister()\n has already been registered."]
pub const cudaError_cudaErrorHostMemoryAlreadyRegistered: cudaError = 712;
#[doc = " This error indicates that the pointer passed to ::cudaHostUnregister()\n does not correspond to any currently registered memory region."]
pub const cudaError_cudaErrorHostMemoryNotRegistered: cudaError = 713;
#[doc = " Device encountered an error in the call stack during kernel execution,\n possibly due to stack corruption or exceeding the stack size limit.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorHardwareStackError: cudaError = 714;
#[doc = " The device encountered an illegal instruction during kernel execution\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorIllegalInstruction: cudaError = 715;
#[doc = " The device encountered a load or store instruction\n on a memory address which is not aligned.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorMisalignedAddress: cudaError = 716;
#[doc = " While executing a kernel, the device encountered an instruction\n which can only operate on memory locations in certain address spaces\n (global, shared, or local), but was supplied a memory address not\n belonging to an allowed address space.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorInvalidAddressSpace: cudaError = 717;
#[doc = " The device encountered an invalid program counter.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorInvalidPc: cudaError = 718;
#[doc = " An exception occurred on the device while executing a kernel. Common\n causes include dereferencing an invalid device pointer and accessing\n out of bounds shared memory. Less common cases can be system specific - more\n information about these cases can be found in the system specific user guide.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorLaunchFailure: cudaError = 719;
#[doc = " This error indicates that the number of blocks launched per grid for a kernel that was\n launched via either ::cudaLaunchCooperativeKernel or ::cudaLaunchCooperativeKernelMultiDevice\n exceeds the maximum number of blocks as allowed by ::cudaOccupancyMaxActiveBlocksPerMultiprocessor\n or ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags times the number of multiprocessors\n as specified by the device attribute ::cudaDevAttrMultiProcessorCount."]
pub const cudaError_cudaErrorCooperativeLaunchTooLarge: cudaError = 720;
#[doc = " This error indicates the attempted operation is not permitted."]
pub const cudaError_cudaErrorNotPermitted: cudaError = 800;
#[doc = " This error indicates the attempted operation is not supported\n on the current system or device."]
pub const cudaError_cudaErrorNotSupported: cudaError = 801;
#[doc = " This error indicates that the system is not yet ready to start any CUDA\n work.  To continue using CUDA, verify the system configuration is in a\n valid state and all required driver daemons are actively running.\n More information about this error can be found in the system specific\n user guide."]
pub const cudaError_cudaErrorSystemNotReady: cudaError = 802;
#[doc = " This error indicates that there is a mismatch between the versions of\n the display driver and the CUDA driver. Refer to the compatibility documentation\n for supported versions."]
pub const cudaError_cudaErrorSystemDriverMismatch: cudaError = 803;
#[doc = " This error indicates that the system was upgraded to run with forward compatibility\n but the visible hardware detected by CUDA does not support this configuration.\n Refer to the compatibility documentation for the supported hardware matrix or ensure\n that only supported hardware is visible during initialization via the CUDA_VISIBLE_DEVICES\n environment variable."]
pub const cudaError_cudaErrorCompatNotSupportedOnDevice: cudaError = 804;
#[doc = " This error indicates that the MPS client failed to connect to the MPS control daemon or the MPS server."]
pub const cudaError_cudaErrorMpsConnectionFailed: cudaError = 805;
#[doc = " This error indicates that the remote procedural call between the MPS server and the MPS client failed."]
pub const cudaError_cudaErrorMpsRpcFailure: cudaError = 806;
#[doc = " This error indicates that the MPS server is not ready to accept new MPS client requests.\n This error can be returned when the MPS server is in the process of recovering from a fatal failure."]
pub const cudaError_cudaErrorMpsServerNotReady: cudaError = 807;
#[doc = " This error indicates that the hardware resources required to create MPS client have been exhausted."]
pub const cudaError_cudaErrorMpsMaxClientsReached: cudaError = 808;
#[doc = " This error indicates the the hardware resources required to device connections have been exhausted."]
pub const cudaError_cudaErrorMpsMaxConnectionsReached: cudaError = 809;
#[doc = " This error indicates that the MPS client has been terminated by the server. To continue using CUDA, the process must be terminated and relaunched."]
pub const cudaError_cudaErrorMpsClientTerminated: cudaError = 810;
#[doc = " The operation is not permitted when the stream is capturing."]
pub const cudaError_cudaErrorStreamCaptureUnsupported: cudaError = 900;
#[doc = " The current capture sequence on the stream has been invalidated due to\n a previous error."]
pub const cudaError_cudaErrorStreamCaptureInvalidated: cudaError = 901;
#[doc = " The operation would have resulted in a merge of two independent capture\n sequences."]
pub const cudaError_cudaErrorStreamCaptureMerge: cudaError = 902;
#[doc = " The capture was not initiated in this stream."]
pub const cudaError_cudaErrorStreamCaptureUnmatched: cudaError = 903;
#[doc = " The capture sequence contains a fork that was not joined to the primary\n stream."]
pub const cudaError_cudaErrorStreamCaptureUnjoined: cudaError = 904;
#[doc = " A dependency would have been created which crosses the capture sequence\n boundary. Only implicit in-stream ordering dependencies are allowed to\n cross the boundary."]
pub const cudaError_cudaErrorStreamCaptureIsolation: cudaError = 905;
#[doc = " The operation would have resulted in a disallowed implicit dependency on\n a current capture sequence from cudaStreamLegacy."]
pub const cudaError_cudaErrorStreamCaptureImplicit: cudaError = 906;
#[doc = " The operation is not permitted on an event which was last recorded in a\n capturing stream."]
pub const cudaError_cudaErrorCapturedEvent: cudaError = 907;
#[doc = " A stream capture sequence not initiated with the ::cudaStreamCaptureModeRelaxed\n argument to ::cudaStreamBeginCapture was passed to ::cudaStreamEndCapture in a\n different thread."]
pub const cudaError_cudaErrorStreamCaptureWrongThread: cudaError = 908;
#[doc = " This indicates that the wait operation has timed out."]
pub const cudaError_cudaErrorTimeout: cudaError = 909;
#[doc = " This error indicates that the graph update was not performed because it included\n changes which violated constraints specific to instantiated graph update."]
pub const cudaError_cudaErrorGraphExecUpdateFailure: cudaError = 910;
#[doc = " This indicates that an async error has occurred in a device outside of CUDA.\n If CUDA was waiting for an external device's signal before consuming shared data,\n the external device signaled an error indicating that the data is not valid for\n consumption. This leaves the process in an inconsistent state and any further CUDA\n work will return the same error. To continue using CUDA, the process must be\n terminated and relaunched."]
pub const cudaError_cudaErrorExternalDevice: cudaError = 911;
#[doc = " This indicates that a kernel launch error has occurred due to cluster\n misconfiguration."]
pub const cudaError_cudaErrorInvalidClusterSize: cudaError = 912;
#[doc = " This indicates that an unknown internal error has occurred."]
pub const cudaError_cudaErrorUnknown: cudaError = 999;
#[doc = " Any unhandled CUDA driver error is added to this value and returned via\n the runtime. Production releases of CUDA should not return such errors.\n \\deprecated\n This error return is deprecated as of CUDA 4.1."]
pub const cudaError_cudaErrorApiFailureBase: cudaError = 10000;
#[doc = " CUDA error types"]
pub type cudaError = ::std::os::raw::c_int;
#[doc = "< Signed channel format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindSigned: cudaChannelFormatKind = 0;
#[doc = "< Unsigned channel format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsigned: cudaChannelFormatKind = 1;
#[doc = "< Float channel format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindFloat: cudaChannelFormatKind = 2;
#[doc = "< No channel format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindNone: cudaChannelFormatKind = 3;
#[doc = "< Unsigned 8-bit integers, planar 4:2:0 YUV format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindNV12: cudaChannelFormatKind = 4;
#[doc = "< 1 channel unsigned 8-bit normalized integer"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized8X1: cudaChannelFormatKind =
    5;
#[doc = "< 2 channel unsigned 8-bit normalized integer"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized8X2: cudaChannelFormatKind =
    6;
#[doc = "< 4 channel unsigned 8-bit normalized integer"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized8X4: cudaChannelFormatKind =
    7;
#[doc = "< 1 channel unsigned 16-bit normalized integer"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized16X1: cudaChannelFormatKind =
    8;
#[doc = "< 2 channel unsigned 16-bit normalized integer"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized16X2: cudaChannelFormatKind =
    9;
#[doc = "< 4 channel unsigned 16-bit normalized integer"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized16X4: cudaChannelFormatKind =
    10;
#[doc = "< 1 channel signed 8-bit normalized integer"]
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized8X1: cudaChannelFormatKind =
    11;
#[doc = "< 2 channel signed 8-bit normalized integer"]
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized8X2: cudaChannelFormatKind =
    12;
#[doc = "< 4 channel signed 8-bit normalized integer"]
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized8X4: cudaChannelFormatKind =
    13;
#[doc = "< 1 channel signed 16-bit normalized integer"]
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized16X1: cudaChannelFormatKind =
    14;
#[doc = "< 2 channel signed 16-bit normalized integer"]
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized16X2: cudaChannelFormatKind =
    15;
#[doc = "< 4 channel signed 16-bit normalized integer"]
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized16X4: cudaChannelFormatKind =
    16;
#[doc = "< 4 channel unsigned normalized block-compressed (BC1 compression) format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed1:
cudaChannelFormatKind = 17;
#[doc = "< 4 channel unsigned normalized block-compressed (BC1 compression) format with sRGB encoding"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed1SRGB:
cudaChannelFormatKind = 18;
#[doc = "< 4 channel unsigned normalized block-compressed (BC2 compression) format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed2:
cudaChannelFormatKind = 19;
#[doc = "< 4 channel unsigned normalized block-compressed (BC2 compression) format with sRGB encoding"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed2SRGB:
cudaChannelFormatKind = 20;
#[doc = "< 4 channel unsigned normalized block-compressed (BC3 compression) format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed3:
cudaChannelFormatKind = 21;
#[doc = "< 4 channel unsigned normalized block-compressed (BC3 compression) format with sRGB encoding"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed3SRGB:
cudaChannelFormatKind = 22;
#[doc = "< 1 channel unsigned normalized block-compressed (BC4 compression) format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed4:
cudaChannelFormatKind = 23;
#[doc = "< 1 channel signed normalized block-compressed (BC4 compression) format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedBlockCompressed4: cudaChannelFormatKind =
    24;
#[doc = "< 2 channel unsigned normalized block-compressed (BC5 compression) format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed5:
cudaChannelFormatKind = 25;
#[doc = "< 2 channel signed normalized block-compressed (BC5 compression) format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedBlockCompressed5: cudaChannelFormatKind =
    26;
#[doc = "< 3 channel unsigned half-float block-compressed (BC6H compression) format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed6H:
cudaChannelFormatKind = 27;
#[doc = "< 3 channel signed half-float block-compressed (BC6H compression) format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedBlockCompressed6H:
cudaChannelFormatKind = 28;
#[doc = "< 4 channel unsigned normalized block-compressed (BC7 compression) format"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed7:
cudaChannelFormatKind = 29;
#[doc = "< 4 channel unsigned normalized block-compressed (BC7 compression) format with sRGB encoding"]
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed7SRGB:
cudaChannelFormatKind = 30;
#[doc = " Channel format kind"]
pub type cudaChannelFormatKind = ::std::os::raw::c_int;
#[doc = " CUDA Channel format descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaChannelFormatDesc {
    #[doc = "< x"]
    pub x: ::std::os::raw::c_int,
    #[doc = "< y"]
    pub y: ::std::os::raw::c_int,
    #[doc = "< z"]
    pub z: ::std::os::raw::c_int,
    #[doc = "< w"]
    pub w: ::std::os::raw::c_int,
    #[doc = "< Channel format kind"]
    pub f: cudaChannelFormatKind,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaChannelFormatDesc"][::std::mem::size_of::<cudaChannelFormatDesc>() - 20usize];
    ["Alignment of cudaChannelFormatDesc"]
        [::std::mem::align_of::<cudaChannelFormatDesc>() - 4usize];
    ["Offset of field: cudaChannelFormatDesc::x"]
        [::std::mem::offset_of!(cudaChannelFormatDesc, x) - 0usize];
    ["Offset of field: cudaChannelFormatDesc::y"]
        [::std::mem::offset_of!(cudaChannelFormatDesc, y) - 4usize];
    ["Offset of field: cudaChannelFormatDesc::z"]
        [::std::mem::offset_of!(cudaChannelFormatDesc, z) - 8usize];
    ["Offset of field: cudaChannelFormatDesc::w"]
        [::std::mem::offset_of!(cudaChannelFormatDesc, w) - 12usize];
    ["Offset of field: cudaChannelFormatDesc::f"]
        [::std::mem::offset_of!(cudaChannelFormatDesc, f) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArray {
    _unused: [u8; 0],
}
#[doc = " CUDA array"]
pub type cudaArray_t = *mut cudaArray;
#[doc = " CUDA array (as source copy argument)"]
pub type cudaArray_const_t = *const cudaArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMipmappedArray {
    _unused: [u8; 0],
}
#[doc = " CUDA mipmapped array"]
pub type cudaMipmappedArray_t = *mut cudaMipmappedArray;
#[doc = " CUDA mipmapped array (as source argument)"]
pub type cudaMipmappedArray_const_t = *const cudaMipmappedArray;
#[doc = " Sparse CUDA array and CUDA mipmapped array properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArraySparseProperties {
    pub tileExtent: cudaArraySparseProperties__bindgen_ty_1,
    #[doc = "< First mip level at which the mip tail begins"]
    pub miptailFirstLevel: ::std::os::raw::c_uint,
    #[doc = "< Total size of the mip tail."]
    pub miptailSize: ::std::os::raw::c_ulonglong,
    #[doc = "< Flags will either be zero or ::cudaArraySparsePropertiesSingleMipTail"]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArraySparseProperties__bindgen_ty_1 {
    #[doc = "< Tile width in elements"]
    pub width: ::std::os::raw::c_uint,
    #[doc = "< Tile height in elements"]
    pub height: ::std::os::raw::c_uint,
    #[doc = "< Tile depth in elements"]
    pub depth: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaArraySparseProperties__bindgen_ty_1"]
        [::std::mem::size_of::<cudaArraySparseProperties__bindgen_ty_1>() - 12usize];
    ["Alignment of cudaArraySparseProperties__bindgen_ty_1"]
        [::std::mem::align_of::<cudaArraySparseProperties__bindgen_ty_1>() - 4usize];
    ["Offset of field: cudaArraySparseProperties__bindgen_ty_1::width"]
        [::std::mem::offset_of!(cudaArraySparseProperties__bindgen_ty_1, width) - 0usize];
    ["Offset of field: cudaArraySparseProperties__bindgen_ty_1::height"]
        [::std::mem::offset_of!(cudaArraySparseProperties__bindgen_ty_1, height) - 4usize];
    ["Offset of field: cudaArraySparseProperties__bindgen_ty_1::depth"]
        [::std::mem::offset_of!(cudaArraySparseProperties__bindgen_ty_1, depth) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaArraySparseProperties"]
        [::std::mem::size_of::<cudaArraySparseProperties>() - 48usize];
    ["Alignment of cudaArraySparseProperties"]
        [::std::mem::align_of::<cudaArraySparseProperties>() - 8usize];
    ["Offset of field: cudaArraySparseProperties::tileExtent"]
        [::std::mem::offset_of!(cudaArraySparseProperties, tileExtent) - 0usize];
    ["Offset of field: cudaArraySparseProperties::miptailFirstLevel"]
        [::std::mem::offset_of!(cudaArraySparseProperties, miptailFirstLevel) - 12usize];
    ["Offset of field: cudaArraySparseProperties::miptailSize"]
        [::std::mem::offset_of!(cudaArraySparseProperties, miptailSize) - 16usize];
    ["Offset of field: cudaArraySparseProperties::flags"]
        [::std::mem::offset_of!(cudaArraySparseProperties, flags) - 24usize];
    ["Offset of field: cudaArraySparseProperties::reserved"]
        [::std::mem::offset_of!(cudaArraySparseProperties, reserved) - 28usize];
};
#[doc = " CUDA array and CUDA mipmapped array memory requirements"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArrayMemoryRequirements {
    #[doc = "< Total size of the array."]
    pub size: usize,
    #[doc = "< Alignment necessary for mapping the array."]
    pub alignment: usize,
    pub reserved: [::std::os::raw::c_uint; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaArrayMemoryRequirements"]
        [::std::mem::size_of::<cudaArrayMemoryRequirements>() - 32usize];
    ["Alignment of cudaArrayMemoryRequirements"]
        [::std::mem::align_of::<cudaArrayMemoryRequirements>() - 8usize];
    ["Offset of field: cudaArrayMemoryRequirements::size"]
        [::std::mem::offset_of!(cudaArrayMemoryRequirements, size) - 0usize];
    ["Offset of field: cudaArrayMemoryRequirements::alignment"]
        [::std::mem::offset_of!(cudaArrayMemoryRequirements, alignment) - 8usize];
    ["Offset of field: cudaArrayMemoryRequirements::reserved"]
        [::std::mem::offset_of!(cudaArrayMemoryRequirements, reserved) - 16usize];
};
#[doc = "< Unregistered memory"]
pub const cudaMemoryType_cudaMemoryTypeUnregistered: cudaMemoryType = 0;
#[doc = "< Host memory"]
pub const cudaMemoryType_cudaMemoryTypeHost: cudaMemoryType = 1;
#[doc = "< Device memory"]
pub const cudaMemoryType_cudaMemoryTypeDevice: cudaMemoryType = 2;
#[doc = "< Managed memory"]
pub const cudaMemoryType_cudaMemoryTypeManaged: cudaMemoryType = 3;
#[doc = " CUDA memory types"]
pub type cudaMemoryType = ::std::os::raw::c_int;
#[doc = "< Host   -> Host"]
pub const cudaMemcpyKind_cudaMemcpyHostToHost: cudaMemcpyKind = 0;
#[doc = "< Host   -> Device"]
pub const cudaMemcpyKind_cudaMemcpyHostToDevice: cudaMemcpyKind = 1;
#[doc = "< Device -> Host"]
pub const cudaMemcpyKind_cudaMemcpyDeviceToHost: cudaMemcpyKind = 2;
#[doc = "< Device -> Device"]
pub const cudaMemcpyKind_cudaMemcpyDeviceToDevice: cudaMemcpyKind = 3;
#[doc = "< Direction of the transfer is inferred from the pointer values. Requires unified virtual addressing"]
pub const cudaMemcpyKind_cudaMemcpyDefault: cudaMemcpyKind = 4;
#[doc = " CUDA memory copy types"]
pub type cudaMemcpyKind = ::std::os::raw::c_int;
#[doc = " CUDA Pitched memory pointer\n\n \\sa ::make_cudaPitchedPtr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPitchedPtr {
    #[doc = "< Pointer to allocated memory"]
    pub ptr: *mut ::std::os::raw::c_void,
    #[doc = "< Pitch of allocated memory in bytes"]
    pub pitch: usize,
    #[doc = "< Logical width of allocation in elements"]
    pub xsize: usize,
    #[doc = "< Logical height of allocation in elements"]
    pub ysize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaPitchedPtr"][::std::mem::size_of::<cudaPitchedPtr>() - 32usize];
    ["Alignment of cudaPitchedPtr"][::std::mem::align_of::<cudaPitchedPtr>() - 8usize];
    ["Offset of field: cudaPitchedPtr::ptr"][::std::mem::offset_of!(cudaPitchedPtr, ptr) - 0usize];
    ["Offset of field: cudaPitchedPtr::pitch"]
        [::std::mem::offset_of!(cudaPitchedPtr, pitch) - 8usize];
    ["Offset of field: cudaPitchedPtr::xsize"]
        [::std::mem::offset_of!(cudaPitchedPtr, xsize) - 16usize];
    ["Offset of field: cudaPitchedPtr::ysize"]
        [::std::mem::offset_of!(cudaPitchedPtr, ysize) - 24usize];
};
#[doc = " CUDA extent\n\n \\sa ::make_cudaExtent"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExtent {
    #[doc = "< Width in elements when referring to array memory, in bytes when referring to linear memory"]
    pub width: usize,
    #[doc = "< Height in elements"]
    pub height: usize,
    #[doc = "< Depth in elements"]
    pub depth: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExtent"][::std::mem::size_of::<cudaExtent>() - 24usize];
    ["Alignment of cudaExtent"][::std::mem::align_of::<cudaExtent>() - 8usize];
    ["Offset of field: cudaExtent::width"][::std::mem::offset_of!(cudaExtent, width) - 0usize];
    ["Offset of field: cudaExtent::height"][::std::mem::offset_of!(cudaExtent, height) - 8usize];
    ["Offset of field: cudaExtent::depth"][::std::mem::offset_of!(cudaExtent, depth) - 16usize];
};
#[doc = " CUDA 3D position\n\n \\sa ::make_cudaPos"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPos {
    #[doc = "< x"]
    pub x: usize,
    #[doc = "< y"]
    pub y: usize,
    #[doc = "< z"]
    pub z: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaPos"][::std::mem::size_of::<cudaPos>() - 24usize];
    ["Alignment of cudaPos"][::std::mem::align_of::<cudaPos>() - 8usize];
    ["Offset of field: cudaPos::x"][::std::mem::offset_of!(cudaPos, x) - 0usize];
    ["Offset of field: cudaPos::y"][::std::mem::offset_of!(cudaPos, y) - 8usize];
    ["Offset of field: cudaPos::z"][::std::mem::offset_of!(cudaPos, z) - 16usize];
};
#[doc = " CUDA 3D memory copying parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemcpy3DParms {
    #[doc = "< Source memory address"]
    pub srcArray: cudaArray_t,
    #[doc = "< Source position offset"]
    pub srcPos: cudaPos,
    #[doc = "< Pitched source memory address"]
    pub srcPtr: cudaPitchedPtr,
    #[doc = "< Destination memory address"]
    pub dstArray: cudaArray_t,
    #[doc = "< Destination position offset"]
    pub dstPos: cudaPos,
    #[doc = "< Pitched destination memory address"]
    pub dstPtr: cudaPitchedPtr,
    #[doc = "< Requested memory copy size"]
    pub extent: cudaExtent,
    #[doc = "< Type of transfer"]
    pub kind: cudaMemcpyKind,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaMemcpy3DParms"][::std::mem::size_of::<cudaMemcpy3DParms>() - 160usize];
    ["Alignment of cudaMemcpy3DParms"][::std::mem::align_of::<cudaMemcpy3DParms>() - 8usize];
    ["Offset of field: cudaMemcpy3DParms::srcArray"]
        [::std::mem::offset_of!(cudaMemcpy3DParms, srcArray) - 0usize];
    ["Offset of field: cudaMemcpy3DParms::srcPos"]
        [::std::mem::offset_of!(cudaMemcpy3DParms, srcPos) - 8usize];
    ["Offset of field: cudaMemcpy3DParms::srcPtr"]
        [::std::mem::offset_of!(cudaMemcpy3DParms, srcPtr) - 32usize];
    ["Offset of field: cudaMemcpy3DParms::dstArray"]
        [::std::mem::offset_of!(cudaMemcpy3DParms, dstArray) - 64usize];
    ["Offset of field: cudaMemcpy3DParms::dstPos"]
        [::std::mem::offset_of!(cudaMemcpy3DParms, dstPos) - 72usize];
    ["Offset of field: cudaMemcpy3DParms::dstPtr"]
        [::std::mem::offset_of!(cudaMemcpy3DParms, dstPtr) - 96usize];
    ["Offset of field: cudaMemcpy3DParms::extent"]
        [::std::mem::offset_of!(cudaMemcpy3DParms, extent) - 128usize];
    ["Offset of field: cudaMemcpy3DParms::kind"]
        [::std::mem::offset_of!(cudaMemcpy3DParms, kind) - 152usize];
};
#[doc = " CUDA 3D cross-device memory copying parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemcpy3DPeerParms {
    #[doc = "< Source memory address"]
    pub srcArray: cudaArray_t,
    #[doc = "< Source position offset"]
    pub srcPos: cudaPos,
    #[doc = "< Pitched source memory address"]
    pub srcPtr: cudaPitchedPtr,
    #[doc = "< Source device"]
    pub srcDevice: ::std::os::raw::c_int,
    #[doc = "< Destination memory address"]
    pub dstArray: cudaArray_t,
    #[doc = "< Destination position offset"]
    pub dstPos: cudaPos,
    #[doc = "< Pitched destination memory address"]
    pub dstPtr: cudaPitchedPtr,
    #[doc = "< Destination device"]
    pub dstDevice: ::std::os::raw::c_int,
    #[doc = "< Requested memory copy size"]
    pub extent: cudaExtent,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaMemcpy3DPeerParms"][::std::mem::size_of::<cudaMemcpy3DPeerParms>() - 168usize];
    ["Alignment of cudaMemcpy3DPeerParms"]
        [::std::mem::align_of::<cudaMemcpy3DPeerParms>() - 8usize];
    ["Offset of field: cudaMemcpy3DPeerParms::srcArray"]
        [::std::mem::offset_of!(cudaMemcpy3DPeerParms, srcArray) - 0usize];
    ["Offset of field: cudaMemcpy3DPeerParms::srcPos"]
        [::std::mem::offset_of!(cudaMemcpy3DPeerParms, srcPos) - 8usize];
    ["Offset of field: cudaMemcpy3DPeerParms::srcPtr"]
        [::std::mem::offset_of!(cudaMemcpy3DPeerParms, srcPtr) - 32usize];
    ["Offset of field: cudaMemcpy3DPeerParms::srcDevice"]
        [::std::mem::offset_of!(cudaMemcpy3DPeerParms, srcDevice) - 64usize];
    ["Offset of field: cudaMemcpy3DPeerParms::dstArray"]
        [::std::mem::offset_of!(cudaMemcpy3DPeerParms, dstArray) - 72usize];
    ["Offset of field: cudaMemcpy3DPeerParms::dstPos"]
        [::std::mem::offset_of!(cudaMemcpy3DPeerParms, dstPos) - 80usize];
    ["Offset of field: cudaMemcpy3DPeerParms::dstPtr"]
        [::std::mem::offset_of!(cudaMemcpy3DPeerParms, dstPtr) - 104usize];
    ["Offset of field: cudaMemcpy3DPeerParms::dstDevice"]
        [::std::mem::offset_of!(cudaMemcpy3DPeerParms, dstDevice) - 136usize];
    ["Offset of field: cudaMemcpy3DPeerParms::extent"]
        [::std::mem::offset_of!(cudaMemcpy3DPeerParms, extent) - 144usize];
};
#[doc = " CUDA Memset node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemsetParams {
    #[doc = "< Destination device pointer"]
    pub dst: *mut ::std::os::raw::c_void,
    #[doc = "< Pitch of destination device pointer. Unused if height is 1"]
    pub pitch: usize,
    #[doc = "< Value to be set"]
    pub value: ::std::os::raw::c_uint,
    #[doc = "< Size of each element in bytes. Must be 1, 2, or 4."]
    pub elementSize: ::std::os::raw::c_uint,
    #[doc = "< Width of the row in elements"]
    pub width: usize,
    #[doc = "< Number of rows"]
    pub height: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaMemsetParams"][::std::mem::size_of::<cudaMemsetParams>() - 40usize];
    ["Alignment of cudaMemsetParams"][::std::mem::align_of::<cudaMemsetParams>() - 8usize];
    ["Offset of field: cudaMemsetParams::dst"]
        [::std::mem::offset_of!(cudaMemsetParams, dst) - 0usize];
    ["Offset of field: cudaMemsetParams::pitch"]
        [::std::mem::offset_of!(cudaMemsetParams, pitch) - 8usize];
    ["Offset of field: cudaMemsetParams::value"]
        [::std::mem::offset_of!(cudaMemsetParams, value) - 16usize];
    ["Offset of field: cudaMemsetParams::elementSize"]
        [::std::mem::offset_of!(cudaMemsetParams, elementSize) - 20usize];
    ["Offset of field: cudaMemsetParams::width"]
        [::std::mem::offset_of!(cudaMemsetParams, width) - 24usize];
    ["Offset of field: cudaMemsetParams::height"]
        [::std::mem::offset_of!(cudaMemsetParams, height) - 32usize];
};
#[doc = "< Normal cache persistence."]
pub const cudaAccessProperty_cudaAccessPropertyNormal: cudaAccessProperty = 0;
#[doc = "< Streaming access is less likely to persit from cache."]
pub const cudaAccessProperty_cudaAccessPropertyStreaming: cudaAccessProperty = 1;
#[doc = "< Persisting access is more likely to persist in cache."]
pub const cudaAccessProperty_cudaAccessPropertyPersisting: cudaAccessProperty = 2;
#[doc = " Specifies performance hint with ::cudaAccessPolicyWindow for hitProp and missProp members."]
pub type cudaAccessProperty = ::std::os::raw::c_int;
#[doc = " Specifies an access policy for a window, a contiguous extent of memory\n beginning at base_ptr and ending at base_ptr + num_bytes.\n Partition into many segments and assign segments such that.\n sum of \"hit segments\" / window == approx. ratio.\n sum of \"miss segments\" / window == approx 1-ratio.\n Segments and ratio specifications are fitted to the capabilities of\n the architecture.\n Accesses in a hit segment apply the hitProp access policy.\n Accesses in a miss segment apply the missProp access policy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaAccessPolicyWindow {
    #[doc = "< Starting address of the access policy window. CUDA driver may align it."]
    pub base_ptr: *mut ::std::os::raw::c_void,
    #[doc = "< Size in bytes of the window policy. CUDA driver may restrict the maximum size and alignment."]
    pub num_bytes: usize,
    #[doc = "< hitRatio specifies percentage of lines assigned hitProp, rest are assigned missProp."]
    pub hitRatio: f32,
    #[doc = "< ::CUaccessProperty set for hit."]
    pub hitProp: cudaAccessProperty,
    #[doc = "< ::CUaccessProperty set for miss. Must be either NORMAL or STREAMING."]
    pub missProp: cudaAccessProperty,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaAccessPolicyWindow"][::std::mem::size_of::<cudaAccessPolicyWindow>() - 32usize];
    ["Alignment of cudaAccessPolicyWindow"]
        [::std::mem::align_of::<cudaAccessPolicyWindow>() - 8usize];
    ["Offset of field: cudaAccessPolicyWindow::base_ptr"]
        [::std::mem::offset_of!(cudaAccessPolicyWindow, base_ptr) - 0usize];
    ["Offset of field: cudaAccessPolicyWindow::num_bytes"]
        [::std::mem::offset_of!(cudaAccessPolicyWindow, num_bytes) - 8usize];
    ["Offset of field: cudaAccessPolicyWindow::hitRatio"]
        [::std::mem::offset_of!(cudaAccessPolicyWindow, hitRatio) - 16usize];
    ["Offset of field: cudaAccessPolicyWindow::hitProp"]
        [::std::mem::offset_of!(cudaAccessPolicyWindow, hitProp) - 20usize];
    ["Offset of field: cudaAccessPolicyWindow::missProp"]
        [::std::mem::offset_of!(cudaAccessPolicyWindow, missProp) - 24usize];
};
#[doc = " CUDA host function\n \\param userData Argument value passed to the function"]
pub type cudaHostFn_t =
::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
#[doc = " CUDA host node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaHostNodeParams {
    #[doc = "< The function to call when the node executes"]
    pub fn_: cudaHostFn_t,
    #[doc = "< Argument to pass to the function"]
    pub userData: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaHostNodeParams"][::std::mem::size_of::<cudaHostNodeParams>() - 16usize];
    ["Alignment of cudaHostNodeParams"][::std::mem::align_of::<cudaHostNodeParams>() - 8usize];
    ["Offset of field: cudaHostNodeParams::fn_"]
        [::std::mem::offset_of!(cudaHostNodeParams, fn_) - 0usize];
    ["Offset of field: cudaHostNodeParams::userData"]
        [::std::mem::offset_of!(cudaHostNodeParams, userData) - 8usize];
};
#[doc = "< Stream is not capturing"]
pub const cudaStreamCaptureStatus_cudaStreamCaptureStatusNone: cudaStreamCaptureStatus = 0;
#[doc = "< Stream is actively capturing"]
pub const cudaStreamCaptureStatus_cudaStreamCaptureStatusActive: cudaStreamCaptureStatus = 1;
#[doc = "< Stream is part of a capture sequence that\nhas been invalidated, but not terminated"]
pub const cudaStreamCaptureStatus_cudaStreamCaptureStatusInvalidated: cudaStreamCaptureStatus = 2;
#[doc = " Possible stream capture statuses returned by ::cudaStreamIsCapturing"]
pub type cudaStreamCaptureStatus = ::std::os::raw::c_int;
pub const cudaStreamCaptureMode_cudaStreamCaptureModeGlobal: cudaStreamCaptureMode = 0;
pub const cudaStreamCaptureMode_cudaStreamCaptureModeThreadLocal: cudaStreamCaptureMode = 1;
pub const cudaStreamCaptureMode_cudaStreamCaptureModeRelaxed: cudaStreamCaptureMode = 2;
#[doc = " Possible modes for stream capture thread interactions. For more details see\n ::cudaStreamBeginCapture and ::cudaThreadExchangeStreamCaptureMode"]
pub type cudaStreamCaptureMode = ::std::os::raw::c_int;
pub const cudaSynchronizationPolicy_cudaSyncPolicyAuto: cudaSynchronizationPolicy = 1;
pub const cudaSynchronizationPolicy_cudaSyncPolicySpin: cudaSynchronizationPolicy = 2;
pub const cudaSynchronizationPolicy_cudaSyncPolicyYield: cudaSynchronizationPolicy = 3;
pub const cudaSynchronizationPolicy_cudaSyncPolicyBlockingSync: cudaSynchronizationPolicy = 4;
pub type cudaSynchronizationPolicy = ::std::os::raw::c_int;
#[doc = "< the default policy"]
pub const cudaClusterSchedulingPolicy_cudaClusterSchedulingPolicyDefault:
cudaClusterSchedulingPolicy = 0;
#[doc = "< spread the blocks within a cluster to the SMs"]
pub const cudaClusterSchedulingPolicy_cudaClusterSchedulingPolicySpread:
cudaClusterSchedulingPolicy = 1;
#[doc = "< allow the hardware to load-balance the blocks in a cluster to the SMs"]
pub const cudaClusterSchedulingPolicy_cudaClusterSchedulingPolicyLoadBalancing:
cudaClusterSchedulingPolicy = 2;
#[doc = " Cluster scheduling policies. These may be passed to ::cudaFuncSetAttribute"]
pub type cudaClusterSchedulingPolicy = ::std::os::raw::c_int;
#[doc = "< Add new nodes to the dependency set"]
pub const cudaStreamUpdateCaptureDependenciesFlags_cudaStreamAddCaptureDependencies:
cudaStreamUpdateCaptureDependenciesFlags = 0;
#[doc = "< Replace the dependency set with the new nodes"]
pub const cudaStreamUpdateCaptureDependenciesFlags_cudaStreamSetCaptureDependencies:
cudaStreamUpdateCaptureDependenciesFlags = 1;
#[doc = " Flags for ::cudaStreamUpdateCaptureDependencies"]
pub type cudaStreamUpdateCaptureDependenciesFlags = ::std::os::raw::c_int;
#[doc = "< Indicates the destructor execution is not synchronized by any CUDA handle."]
pub const cudaUserObjectFlags_cudaUserObjectNoDestructorSync: cudaUserObjectFlags = 1;
#[doc = " Flags for user objects for graphs"]
pub type cudaUserObjectFlags = ::std::os::raw::c_int;
#[doc = "< Transfer references from the caller rather than creating new references."]
pub const cudaUserObjectRetainFlags_cudaGraphUserObjectMove: cudaUserObjectRetainFlags = 1;
#[doc = " Flags for retaining user object references for graphs"]
pub type cudaUserObjectRetainFlags = ::std::os::raw::c_int;
#[doc = " CUDA graphics interop resource"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaGraphicsResource {
    _unused: [u8; 0],
}
#[doc = "< Default"]
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsNone: cudaGraphicsRegisterFlags = 0;
#[doc = "< CUDA will not write to this resource"]
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsReadOnly: cudaGraphicsRegisterFlags =
    1;
#[doc = "< CUDA will only write to and will not read from this resource"]
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsWriteDiscard:
cudaGraphicsRegisterFlags = 2;
#[doc = "< CUDA will bind this resource to a surface reference"]
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsSurfaceLoadStore:
cudaGraphicsRegisterFlags = 4;
#[doc = "< CUDA will perform texture gather operations on this resource"]
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsTextureGather:
cudaGraphicsRegisterFlags = 8;
#[doc = " CUDA graphics interop register flags"]
pub type cudaGraphicsRegisterFlags = ::std::os::raw::c_int;
#[doc = "< Default; Assume resource can be read/written"]
pub const cudaGraphicsMapFlags_cudaGraphicsMapFlagsNone: cudaGraphicsMapFlags = 0;
#[doc = "< CUDA will not write to this resource"]
pub const cudaGraphicsMapFlags_cudaGraphicsMapFlagsReadOnly: cudaGraphicsMapFlags = 1;
#[doc = "< CUDA will only write to and will not read from this resource"]
pub const cudaGraphicsMapFlags_cudaGraphicsMapFlagsWriteDiscard: cudaGraphicsMapFlags = 2;
#[doc = " CUDA graphics interop map flags"]
pub type cudaGraphicsMapFlags = ::std::os::raw::c_int;
#[doc = "< Positive X face of cubemap"]
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFacePositiveX: cudaGraphicsCubeFace = 0;
#[doc = "< Negative X face of cubemap"]
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFaceNegativeX: cudaGraphicsCubeFace = 1;
#[doc = "< Positive Y face of cubemap"]
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFacePositiveY: cudaGraphicsCubeFace = 2;
#[doc = "< Negative Y face of cubemap"]
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFaceNegativeY: cudaGraphicsCubeFace = 3;
#[doc = "< Positive Z face of cubemap"]
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFacePositiveZ: cudaGraphicsCubeFace = 4;
#[doc = "< Negative Z face of cubemap"]
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFaceNegativeZ: cudaGraphicsCubeFace = 5;
#[doc = " CUDA graphics interop array indices for cube maps"]
pub type cudaGraphicsCubeFace = ::std::os::raw::c_int;
#[doc = "< Array resource"]
pub const cudaResourceType_cudaResourceTypeArray: cudaResourceType = 0;
#[doc = "< Mipmapped array resource"]
pub const cudaResourceType_cudaResourceTypeMipmappedArray: cudaResourceType = 1;
#[doc = "< Linear resource"]
pub const cudaResourceType_cudaResourceTypeLinear: cudaResourceType = 2;
#[doc = "< Pitch 2D resource"]
pub const cudaResourceType_cudaResourceTypePitch2D: cudaResourceType = 3;
#[doc = " CUDA resource types"]
pub type cudaResourceType = ::std::os::raw::c_int;
#[doc = "< No resource view format (use underlying resource format)"]
pub const cudaResourceViewFormat_cudaResViewFormatNone: cudaResourceViewFormat = 0;
#[doc = "< 1 channel unsigned 8-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedChar1: cudaResourceViewFormat = 1;
#[doc = "< 2 channel unsigned 8-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedChar2: cudaResourceViewFormat = 2;
#[doc = "< 4 channel unsigned 8-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedChar4: cudaResourceViewFormat = 3;
#[doc = "< 1 channel signed 8-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedChar1: cudaResourceViewFormat = 4;
#[doc = "< 2 channel signed 8-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedChar2: cudaResourceViewFormat = 5;
#[doc = "< 4 channel signed 8-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedChar4: cudaResourceViewFormat = 6;
#[doc = "< 1 channel unsigned 16-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedShort1: cudaResourceViewFormat = 7;
#[doc = "< 2 channel unsigned 16-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedShort2: cudaResourceViewFormat = 8;
#[doc = "< 4 channel unsigned 16-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedShort4: cudaResourceViewFormat = 9;
#[doc = "< 1 channel signed 16-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedShort1: cudaResourceViewFormat = 10;
#[doc = "< 2 channel signed 16-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedShort2: cudaResourceViewFormat = 11;
#[doc = "< 4 channel signed 16-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedShort4: cudaResourceViewFormat = 12;
#[doc = "< 1 channel unsigned 32-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedInt1: cudaResourceViewFormat = 13;
#[doc = "< 2 channel unsigned 32-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedInt2: cudaResourceViewFormat = 14;
#[doc = "< 4 channel unsigned 32-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedInt4: cudaResourceViewFormat = 15;
#[doc = "< 1 channel signed 32-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedInt1: cudaResourceViewFormat = 16;
#[doc = "< 2 channel signed 32-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedInt2: cudaResourceViewFormat = 17;
#[doc = "< 4 channel signed 32-bit integers"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedInt4: cudaResourceViewFormat = 18;
#[doc = "< 1 channel 16-bit floating point"]
pub const cudaResourceViewFormat_cudaResViewFormatHalf1: cudaResourceViewFormat = 19;
#[doc = "< 2 channel 16-bit floating point"]
pub const cudaResourceViewFormat_cudaResViewFormatHalf2: cudaResourceViewFormat = 20;
#[doc = "< 4 channel 16-bit floating point"]
pub const cudaResourceViewFormat_cudaResViewFormatHalf4: cudaResourceViewFormat = 21;
#[doc = "< 1 channel 32-bit floating point"]
pub const cudaResourceViewFormat_cudaResViewFormatFloat1: cudaResourceViewFormat = 22;
#[doc = "< 2 channel 32-bit floating point"]
pub const cudaResourceViewFormat_cudaResViewFormatFloat2: cudaResourceViewFormat = 23;
#[doc = "< 4 channel 32-bit floating point"]
pub const cudaResourceViewFormat_cudaResViewFormatFloat4: cudaResourceViewFormat = 24;
#[doc = "< Block compressed 1"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed1: cudaResourceViewFormat =
    25;
#[doc = "< Block compressed 2"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed2: cudaResourceViewFormat =
    26;
#[doc = "< Block compressed 3"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed3: cudaResourceViewFormat =
    27;
#[doc = "< Block compressed 4 unsigned"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed4: cudaResourceViewFormat =
    28;
#[doc = "< Block compressed 4 signed"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedBlockCompressed4: cudaResourceViewFormat =
    29;
#[doc = "< Block compressed 5 unsigned"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed5: cudaResourceViewFormat =
    30;
#[doc = "< Block compressed 5 signed"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedBlockCompressed5: cudaResourceViewFormat =
    31;
#[doc = "< Block compressed 6 unsigned half-float"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed6H:
cudaResourceViewFormat = 32;
#[doc = "< Block compressed 6 signed half-float"]
pub const cudaResourceViewFormat_cudaResViewFormatSignedBlockCompressed6H: cudaResourceViewFormat =
    33;
#[doc = "< Block compressed 7"]
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed7: cudaResourceViewFormat =
    34;
#[doc = " CUDA texture resource view formats"]
pub type cudaResourceViewFormat = ::std::os::raw::c_int;
#[doc = " CUDA resource descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaResourceDesc {
    #[doc = "< Resource type"]
    pub resType: cudaResourceType,
    pub res: cudaResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaResourceDesc__bindgen_ty_1 {
    pub array: cudaResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: cudaResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: cudaResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: cudaResourceDesc__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< CUDA array"]
    pub array: cudaArray_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaResourceDesc__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of cudaResourceDesc__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1__bindgen_ty_1::array"]
        [::std::mem::offset_of!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1, array) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< CUDA mipmapped array"]
    pub mipmap: cudaMipmappedArray_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaResourceDesc__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Alignment of cudaResourceDesc__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1__bindgen_ty_2::mipmap"]
        [::std::mem::offset_of!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2, mipmap) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: *mut ::std::os::raw::c_void,
    #[doc = "< Channel descriptor"]
    pub desc: cudaChannelFormatDesc,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaResourceDesc__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>() - 40usize];
    ["Alignment of cudaResourceDesc__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1__bindgen_ty_3::devPtr"]
        [::std::mem::offset_of!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3, devPtr) - 0usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1__bindgen_ty_3::desc"]
        [::std::mem::offset_of!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3, desc) - 8usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1__bindgen_ty_3::sizeInBytes"][::std::mem::offset_of!(
        cudaResourceDesc__bindgen_ty_1__bindgen_ty_3,
        sizeInBytes
    ) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: *mut ::std::os::raw::c_void,
    #[doc = "< Channel descriptor"]
    pub desc: cudaChannelFormatDesc,
    #[doc = "< Width of the array in elements"]
    pub width: usize,
    #[doc = "< Height of the array in elements"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaResourceDesc__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>() - 56usize];
    ["Alignment of cudaResourceDesc__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>() - 8usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1__bindgen_ty_4::devPtr"]
        [::std::mem::offset_of!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4, devPtr) - 0usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1__bindgen_ty_4::desc"]
        [::std::mem::offset_of!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4, desc) - 8usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1__bindgen_ty_4::width"]
        [::std::mem::offset_of!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4, width) - 32usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1__bindgen_ty_4::height"]
        [::std::mem::offset_of!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4, height) - 40usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1__bindgen_ty_4::pitchInBytes"][::std::mem::offset_of!(
        cudaResourceDesc__bindgen_ty_1__bindgen_ty_4,
        pitchInBytes
    ) - 48usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaResourceDesc__bindgen_ty_1"]
        [::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1>() - 56usize];
    ["Alignment of cudaResourceDesc__bindgen_ty_1"]
        [::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1>() - 8usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1::array"]
        [::std::mem::offset_of!(cudaResourceDesc__bindgen_ty_1, array) - 0usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1::mipmap"]
        [::std::mem::offset_of!(cudaResourceDesc__bindgen_ty_1, mipmap) - 0usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1::linear"]
        [::std::mem::offset_of!(cudaResourceDesc__bindgen_ty_1, linear) - 0usize];
    ["Offset of field: cudaResourceDesc__bindgen_ty_1::pitch2D"]
        [::std::mem::offset_of!(cudaResourceDesc__bindgen_ty_1, pitch2D) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaResourceDesc"][::std::mem::size_of::<cudaResourceDesc>() - 64usize];
    ["Alignment of cudaResourceDesc"][::std::mem::align_of::<cudaResourceDesc>() - 8usize];
    ["Offset of field: cudaResourceDesc::resType"]
        [::std::mem::offset_of!(cudaResourceDesc, resType) - 0usize];
    ["Offset of field: cudaResourceDesc::res"]
        [::std::mem::offset_of!(cudaResourceDesc, res) - 8usize];
};
#[doc = " CUDA resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceViewDesc {
    #[doc = "< Resource view format"]
    pub format: cudaResourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: usize,
    #[doc = "< Height of the resource view"]
    pub height: usize,
    #[doc = "< Depth of the resource view"]
    pub depth: usize,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::std::os::raw::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaResourceViewDesc"][::std::mem::size_of::<cudaResourceViewDesc>() - 48usize];
    ["Alignment of cudaResourceViewDesc"][::std::mem::align_of::<cudaResourceViewDesc>() - 8usize];
    ["Offset of field: cudaResourceViewDesc::format"]
        [::std::mem::offset_of!(cudaResourceViewDesc, format) - 0usize];
    ["Offset of field: cudaResourceViewDesc::width"]
        [::std::mem::offset_of!(cudaResourceViewDesc, width) - 8usize];
    ["Offset of field: cudaResourceViewDesc::height"]
        [::std::mem::offset_of!(cudaResourceViewDesc, height) - 16usize];
    ["Offset of field: cudaResourceViewDesc::depth"]
        [::std::mem::offset_of!(cudaResourceViewDesc, depth) - 24usize];
    ["Offset of field: cudaResourceViewDesc::firstMipmapLevel"]
        [::std::mem::offset_of!(cudaResourceViewDesc, firstMipmapLevel) - 32usize];
    ["Offset of field: cudaResourceViewDesc::lastMipmapLevel"]
        [::std::mem::offset_of!(cudaResourceViewDesc, lastMipmapLevel) - 36usize];
    ["Offset of field: cudaResourceViewDesc::firstLayer"]
        [::std::mem::offset_of!(cudaResourceViewDesc, firstLayer) - 40usize];
    ["Offset of field: cudaResourceViewDesc::lastLayer"]
        [::std::mem::offset_of!(cudaResourceViewDesc, lastLayer) - 44usize];
};
#[doc = " CUDA pointer attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPointerAttributes {
    #[doc = " The type of memory - ::cudaMemoryTypeUnregistered, ::cudaMemoryTypeHost,\n ::cudaMemoryTypeDevice or ::cudaMemoryTypeManaged."]
    pub type_: cudaMemoryType,
    #[doc = " The device against which the memory was allocated or registered.\n If the memory type is ::cudaMemoryTypeDevice then this identifies\n the device on which the memory referred physically resides.  If\n the memory type is ::cudaMemoryTypeHost or::cudaMemoryTypeManaged then\n this identifies the device which was current when the memory was allocated\n or registered (and if that device is deinitialized then this allocation\n will vanish with that device's state)."]
    pub device: ::std::os::raw::c_int,
    #[doc = " The address which may be dereferenced on the current device to access\n the memory or NULL if no such address exists."]
    pub devicePointer: *mut ::std::os::raw::c_void,
    #[doc = " The address which may be dereferenced on the host to access the\n memory or NULL if no such address exists.\n\n \\note CUDA doesn't check if unregistered memory is allocated so this field\n may contain invalid pointer if an invalid pointer has been passed to CUDA."]
    pub hostPointer: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaPointerAttributes"][::std::mem::size_of::<cudaPointerAttributes>() - 24usize];
    ["Alignment of cudaPointerAttributes"]
        [::std::mem::align_of::<cudaPointerAttributes>() - 8usize];
    ["Offset of field: cudaPointerAttributes::type_"]
        [::std::mem::offset_of!(cudaPointerAttributes, type_) - 0usize];
    ["Offset of field: cudaPointerAttributes::device"]
        [::std::mem::offset_of!(cudaPointerAttributes, device) - 4usize];
    ["Offset of field: cudaPointerAttributes::devicePointer"]
        [::std::mem::offset_of!(cudaPointerAttributes, devicePointer) - 8usize];
    ["Offset of field: cudaPointerAttributes::hostPointer"]
        [::std::mem::offset_of!(cudaPointerAttributes, hostPointer) - 16usize];
};
#[doc = " CUDA function attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaFuncAttributes {
    #[doc = " The size in bytes of statically-allocated shared memory per block\n required by this function. This does not include dynamically-allocated\n shared memory requested by the user at runtime."]
    pub sharedSizeBytes: usize,
    #[doc = " The size in bytes of user-allocated constant memory required by this\n function."]
    pub constSizeBytes: usize,
    #[doc = " The size in bytes of local memory used by each thread of this function."]
    pub localSizeBytes: usize,
    #[doc = " The maximum number of threads per block, beyond which a launch of the\n function would fail. This number depends on both the function and the\n device on which the function is currently loaded."]
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    #[doc = " The number of registers used by each thread of this function."]
    pub numRegs: ::std::os::raw::c_int,
    #[doc = " The PTX virtual architecture version for which the function was\n compiled. This value is the major PTX version * 10 + the minor PTX\n version, so a PTX version 1.3 function would return the value 13."]
    pub ptxVersion: ::std::os::raw::c_int,
    #[doc = " The binary architecture version for which the function was compiled.\n This value is the major binary version * 10 + the minor binary version,\n so a binary version 1.3 function would return the value 13."]
    pub binaryVersion: ::std::os::raw::c_int,
    #[doc = " The attribute to indicate whether the function has been compiled with\n user specified option \"-Xptxas --dlcm=ca\" set."]
    pub cacheModeCA: ::std::os::raw::c_int,
    #[doc = " The maximum size in bytes of dynamic shared memory per block for\n this function. Any launch must have a dynamic shared memory size\n smaller than this value."]
    pub maxDynamicSharedSizeBytes: ::std::os::raw::c_int,
    #[doc = " On devices where the L1 cache and shared memory use the same hardware resources,\n this sets the shared memory carveout preference, in percent of the maximum shared memory.\n Refer to ::cudaDevAttrMaxSharedMemoryPerMultiprocessor.\n This is only a hint, and the driver can choose a different ratio if required to execute the function.\n See ::cudaFuncSetAttribute"]
    pub preferredShmemCarveout: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaFuncAttributes"][::std::mem::size_of::<cudaFuncAttributes>() - 56usize];
    ["Alignment of cudaFuncAttributes"][::std::mem::align_of::<cudaFuncAttributes>() - 8usize];
    ["Offset of field: cudaFuncAttributes::sharedSizeBytes"]
        [::std::mem::offset_of!(cudaFuncAttributes, sharedSizeBytes) - 0usize];
    ["Offset of field: cudaFuncAttributes::constSizeBytes"]
        [::std::mem::offset_of!(cudaFuncAttributes, constSizeBytes) - 8usize];
    ["Offset of field: cudaFuncAttributes::localSizeBytes"]
        [::std::mem::offset_of!(cudaFuncAttributes, localSizeBytes) - 16usize];
    ["Offset of field: cudaFuncAttributes::maxThreadsPerBlock"]
        [::std::mem::offset_of!(cudaFuncAttributes, maxThreadsPerBlock) - 24usize];
    ["Offset of field: cudaFuncAttributes::numRegs"]
        [::std::mem::offset_of!(cudaFuncAttributes, numRegs) - 28usize];
    ["Offset of field: cudaFuncAttributes::ptxVersion"]
        [::std::mem::offset_of!(cudaFuncAttributes, ptxVersion) - 32usize];
    ["Offset of field: cudaFuncAttributes::binaryVersion"]
        [::std::mem::offset_of!(cudaFuncAttributes, binaryVersion) - 36usize];
    ["Offset of field: cudaFuncAttributes::cacheModeCA"]
        [::std::mem::offset_of!(cudaFuncAttributes, cacheModeCA) - 40usize];
    ["Offset of field: cudaFuncAttributes::maxDynamicSharedSizeBytes"]
        [::std::mem::offset_of!(cudaFuncAttributes, maxDynamicSharedSizeBytes) - 44usize];
    ["Offset of field: cudaFuncAttributes::preferredShmemCarveout"]
        [::std::mem::offset_of!(cudaFuncAttributes, preferredShmemCarveout) - 48usize];
};
#[doc = "< Maximum dynamic shared memory size"]
pub const cudaFuncAttribute_cudaFuncAttributeMaxDynamicSharedMemorySize: cudaFuncAttribute = 8;
#[doc = "< Preferred shared memory-L1 cache split"]
pub const cudaFuncAttribute_cudaFuncAttributePreferredSharedMemoryCarveout: cudaFuncAttribute = 9;
#[doc = "< Indicator to enforce valid cluster dimension specification on kernel launch"]
pub const cudaFuncAttribute_cudaFuncAttributeClusterDimMustBeSet: cudaFuncAttribute = 10;
#[doc = "< Required cluster width"]
pub const cudaFuncAttribute_cudaFuncAttributeRequiredClusterWidth: cudaFuncAttribute = 11;
#[doc = "< Required cluster height"]
pub const cudaFuncAttribute_cudaFuncAttributeRequiredClusterHeight: cudaFuncAttribute = 12;
#[doc = "< Required cluster depth"]
pub const cudaFuncAttribute_cudaFuncAttributeRequiredClusterDepth: cudaFuncAttribute = 13;
#[doc = "< Whether non-portable cluster scheduling policy is supported"]
pub const cudaFuncAttribute_cudaFuncAttributeNonPortableClusterSizeAllowed: cudaFuncAttribute = 14;
#[doc = "< Required cluster scheduling policy preference"]
pub const cudaFuncAttribute_cudaFuncAttributeClusterSchedulingPolicyPreference: cudaFuncAttribute =
    15;
pub const cudaFuncAttribute_cudaFuncAttributeMax: cudaFuncAttribute = 16;
#[doc = " CUDA function attributes that can be set using ::cudaFuncSetAttribute"]
pub type cudaFuncAttribute = ::std::os::raw::c_int;
#[doc = "< Default function cache configuration, no preference"]
pub const cudaFuncCache_cudaFuncCachePreferNone: cudaFuncCache = 0;
#[doc = "< Prefer larger shared memory and smaller L1 cache"]
pub const cudaFuncCache_cudaFuncCachePreferShared: cudaFuncCache = 1;
#[doc = "< Prefer larger L1 cache and smaller shared memory"]
pub const cudaFuncCache_cudaFuncCachePreferL1: cudaFuncCache = 2;
#[doc = "< Prefer equal size L1 cache and shared memory"]
pub const cudaFuncCache_cudaFuncCachePreferEqual: cudaFuncCache = 3;
#[doc = " CUDA function cache configurations"]
pub type cudaFuncCache = ::std::os::raw::c_int;
pub const cudaSharedMemConfig_cudaSharedMemBankSizeDefault: cudaSharedMemConfig = 0;
pub const cudaSharedMemConfig_cudaSharedMemBankSizeFourByte: cudaSharedMemConfig = 1;
pub const cudaSharedMemConfig_cudaSharedMemBankSizeEightByte: cudaSharedMemConfig = 2;
#[doc = " CUDA shared memory configuration"]
pub type cudaSharedMemConfig = ::std::os::raw::c_int;
#[doc = "< No preference for shared memory or L1 (default)"]
pub const cudaSharedCarveout_cudaSharedmemCarveoutDefault: cudaSharedCarveout = -1;
#[doc = "< Prefer maximum available shared memory, minimum L1 cache"]
pub const cudaSharedCarveout_cudaSharedmemCarveoutMaxShared: cudaSharedCarveout = 100;
#[doc = "< Prefer maximum available L1 cache, minimum shared memory"]
pub const cudaSharedCarveout_cudaSharedmemCarveoutMaxL1: cudaSharedCarveout = 0;
#[doc = " Shared memory carveout configurations. These may be passed to cudaFuncSetAttribute"]
pub type cudaSharedCarveout = ::std::os::raw::c_int;
#[doc = "< Default compute mode (Multiple threads can use ::cudaSetDevice() with this device)"]
pub const cudaComputeMode_cudaComputeModeDefault: cudaComputeMode = 0;
#[doc = "< Compute-exclusive-thread mode (Only one thread in one process will be able to use ::cudaSetDevice() with this device)"]
pub const cudaComputeMode_cudaComputeModeExclusive: cudaComputeMode = 1;
#[doc = "< Compute-prohibited mode (No threads can use ::cudaSetDevice() with this device)"]
pub const cudaComputeMode_cudaComputeModeProhibited: cudaComputeMode = 2;
#[doc = "< Compute-exclusive-process mode (Many threads in one process will be able to use ::cudaSetDevice() with this device)"]
pub const cudaComputeMode_cudaComputeModeExclusiveProcess: cudaComputeMode = 3;
#[doc = " CUDA device compute modes"]
pub type cudaComputeMode = ::std::os::raw::c_int;
#[doc = "< GPU thread stack size"]
pub const cudaLimit_cudaLimitStackSize: cudaLimit = 0;
#[doc = "< GPU printf FIFO size"]
pub const cudaLimit_cudaLimitPrintfFifoSize: cudaLimit = 1;
#[doc = "< GPU malloc heap size"]
pub const cudaLimit_cudaLimitMallocHeapSize: cudaLimit = 2;
#[doc = "< GPU device runtime synchronize depth"]
pub const cudaLimit_cudaLimitDevRuntimeSyncDepth: cudaLimit = 3;
#[doc = "< GPU device runtime pending launch count"]
pub const cudaLimit_cudaLimitDevRuntimePendingLaunchCount: cudaLimit = 4;
#[doc = "< A value between 0 and 128 that indicates the maximum fetch granularity of L2 (in Bytes). This is a hint"]
pub const cudaLimit_cudaLimitMaxL2FetchGranularity: cudaLimit = 5;
#[doc = "< A size in bytes for L2 persisting lines cache size"]
pub const cudaLimit_cudaLimitPersistingL2CacheSize: cudaLimit = 6;
#[doc = " CUDA Limits"]
pub type cudaLimit = ::std::os::raw::c_int;
#[doc = "< Data will mostly be read and only occassionally be written to"]
pub const cudaMemoryAdvise_cudaMemAdviseSetReadMostly: cudaMemoryAdvise = 1;
#[doc = "< Undo the effect of ::cudaMemAdviseSetReadMostly"]
pub const cudaMemoryAdvise_cudaMemAdviseUnsetReadMostly: cudaMemoryAdvise = 2;
#[doc = "< Set the preferred location for the data as the specified device"]
pub const cudaMemoryAdvise_cudaMemAdviseSetPreferredLocation: cudaMemoryAdvise = 3;
#[doc = "< Clear the preferred location for the data"]
pub const cudaMemoryAdvise_cudaMemAdviseUnsetPreferredLocation: cudaMemoryAdvise = 4;
#[doc = "< Data will be accessed by the specified device, so prevent page faults as much as possible"]
pub const cudaMemoryAdvise_cudaMemAdviseSetAccessedBy: cudaMemoryAdvise = 5;
#[doc = "< Let the Unified Memory subsystem decide on the page faulting policy for the specified device"]
pub const cudaMemoryAdvise_cudaMemAdviseUnsetAccessedBy: cudaMemoryAdvise = 6;
#[doc = " CUDA Memory Advise values"]
pub type cudaMemoryAdvise = ::std::os::raw::c_int;
#[doc = "< Whether the range will mostly be read and only occassionally be written to"]
pub const cudaMemRangeAttribute_cudaMemRangeAttributeReadMostly: cudaMemRangeAttribute = 1;
#[doc = "< The preferred location of the range"]
pub const cudaMemRangeAttribute_cudaMemRangeAttributePreferredLocation: cudaMemRangeAttribute = 2;
#[doc = "< Memory range has ::cudaMemAdviseSetAccessedBy set for specified device"]
pub const cudaMemRangeAttribute_cudaMemRangeAttributeAccessedBy: cudaMemRangeAttribute = 3;
#[doc = "< The last location to which the range was prefetched"]
pub const cudaMemRangeAttribute_cudaMemRangeAttributeLastPrefetchLocation: cudaMemRangeAttribute =
    4;
#[doc = " CUDA range attributes"]
pub type cudaMemRangeAttribute = ::std::os::raw::c_int;
#[doc = "< Output mode Key-Value pair format."]
pub const cudaOutputMode_cudaKeyValuePair: cudaOutputMode = 0;
#[doc = "< Output mode Comma separated values format."]
pub const cudaOutputMode_cudaCSV: cudaOutputMode = 1;
#[doc = " CUDA Profiler Output modes"]
pub type cudaOutputMode = ::std::os::raw::c_int;
#[doc = "< ::cudaDeviceFlushGPUDirectRDMAWrites() and its CUDA Driver API counterpart are supported on the device."]
pub const cudaFlushGPUDirectRDMAWritesOptions_cudaFlushGPUDirectRDMAWritesOptionHost:
cudaFlushGPUDirectRDMAWritesOptions = 1;
#[doc = "< The ::CU_STREAM_WAIT_VALUE_FLUSH flag and the ::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES MemOp are supported on the CUDA device."]
pub const cudaFlushGPUDirectRDMAWritesOptions_cudaFlushGPUDirectRDMAWritesOptionMemOps:
cudaFlushGPUDirectRDMAWritesOptions = 2;
#[doc = " CUDA GPUDirect RDMA flush writes APIs supported on the device"]
pub type cudaFlushGPUDirectRDMAWritesOptions = ::std::os::raw::c_int;
#[doc = "< The device does not natively support ordering of GPUDirect RDMA writes. ::cudaFlushGPUDirectRDMAWrites() can be leveraged if supported."]
pub const cudaGPUDirectRDMAWritesOrdering_cudaGPUDirectRDMAWritesOrderingNone:
cudaGPUDirectRDMAWritesOrdering = 0;
#[doc = "< Natively, the device can consistently consume GPUDirect RDMA writes, although other CUDA devices may not."]
pub const cudaGPUDirectRDMAWritesOrdering_cudaGPUDirectRDMAWritesOrderingOwner:
cudaGPUDirectRDMAWritesOrdering = 100;
#[doc = "< Any CUDA device in the system can consistently consume GPUDirect RDMA writes to this device."]
pub const cudaGPUDirectRDMAWritesOrdering_cudaGPUDirectRDMAWritesOrderingAllDevices:
cudaGPUDirectRDMAWritesOrdering = 200;
#[doc = " CUDA GPUDirect RDMA flush writes ordering features of the device"]
pub type cudaGPUDirectRDMAWritesOrdering = ::std::os::raw::c_int;
#[doc = "< Blocks until remote writes are visible to the CUDA device context owning the data."]
pub const cudaFlushGPUDirectRDMAWritesScope_cudaFlushGPUDirectRDMAWritesToOwner:
cudaFlushGPUDirectRDMAWritesScope = 100;
#[doc = "< Blocks until remote writes are visible to all CUDA device contexts."]
pub const cudaFlushGPUDirectRDMAWritesScope_cudaFlushGPUDirectRDMAWritesToAllDevices:
cudaFlushGPUDirectRDMAWritesScope = 200;
#[doc = " CUDA GPUDirect RDMA flush writes scopes"]
pub type cudaFlushGPUDirectRDMAWritesScope = ::std::os::raw::c_int;
#[doc = "< Sets the target for ::cudaDeviceFlushGPUDirectRDMAWrites() to the currently active CUDA device context."]
pub const cudaFlushGPUDirectRDMAWritesTarget_cudaFlushGPUDirectRDMAWritesTargetCurrentDevice:
cudaFlushGPUDirectRDMAWritesTarget = 0;
#[doc = " CUDA GPUDirect RDMA flush writes targets"]
pub type cudaFlushGPUDirectRDMAWritesTarget = ::std::os::raw::c_int;
#[doc = "< Maximum number of threads per block"]
pub const cudaDeviceAttr_cudaDevAttrMaxThreadsPerBlock: cudaDeviceAttr = 1;
#[doc = "< Maximum block dimension X"]
pub const cudaDeviceAttr_cudaDevAttrMaxBlockDimX: cudaDeviceAttr = 2;
#[doc = "< Maximum block dimension Y"]
pub const cudaDeviceAttr_cudaDevAttrMaxBlockDimY: cudaDeviceAttr = 3;
#[doc = "< Maximum block dimension Z"]
pub const cudaDeviceAttr_cudaDevAttrMaxBlockDimZ: cudaDeviceAttr = 4;
#[doc = "< Maximum grid dimension X"]
pub const cudaDeviceAttr_cudaDevAttrMaxGridDimX: cudaDeviceAttr = 5;
#[doc = "< Maximum grid dimension Y"]
pub const cudaDeviceAttr_cudaDevAttrMaxGridDimY: cudaDeviceAttr = 6;
#[doc = "< Maximum grid dimension Z"]
pub const cudaDeviceAttr_cudaDevAttrMaxGridDimZ: cudaDeviceAttr = 7;
#[doc = "< Maximum shared memory available per block in bytes"]
pub const cudaDeviceAttr_cudaDevAttrMaxSharedMemoryPerBlock: cudaDeviceAttr = 8;
#[doc = "< Memory available on device for __constant__ variables in a CUDA C kernel in bytes"]
pub const cudaDeviceAttr_cudaDevAttrTotalConstantMemory: cudaDeviceAttr = 9;
#[doc = "< Warp size in threads"]
pub const cudaDeviceAttr_cudaDevAttrWarpSize: cudaDeviceAttr = 10;
#[doc = "< Maximum pitch in bytes allowed by memory copies"]
pub const cudaDeviceAttr_cudaDevAttrMaxPitch: cudaDeviceAttr = 11;
#[doc = "< Maximum number of 32-bit registers available per block"]
pub const cudaDeviceAttr_cudaDevAttrMaxRegistersPerBlock: cudaDeviceAttr = 12;
#[doc = "< Peak clock frequency in kilohertz"]
pub const cudaDeviceAttr_cudaDevAttrClockRate: cudaDeviceAttr = 13;
#[doc = "< Alignment requirement for textures"]
pub const cudaDeviceAttr_cudaDevAttrTextureAlignment: cudaDeviceAttr = 14;
#[doc = "< Device can possibly copy memory and execute a kernel concurrently"]
pub const cudaDeviceAttr_cudaDevAttrGpuOverlap: cudaDeviceAttr = 15;
#[doc = "< Number of multiprocessors on device"]
pub const cudaDeviceAttr_cudaDevAttrMultiProcessorCount: cudaDeviceAttr = 16;
#[doc = "< Specifies whether there is a run time limit on kernels"]
pub const cudaDeviceAttr_cudaDevAttrKernelExecTimeout: cudaDeviceAttr = 17;
#[doc = "< Device is integrated with host memory"]
pub const cudaDeviceAttr_cudaDevAttrIntegrated: cudaDeviceAttr = 18;
#[doc = "< Device can map host memory into CUDA address space"]
pub const cudaDeviceAttr_cudaDevAttrCanMapHostMemory: cudaDeviceAttr = 19;
#[doc = "< Compute mode (See ::cudaComputeMode for details)"]
pub const cudaDeviceAttr_cudaDevAttrComputeMode: cudaDeviceAttr = 20;
#[doc = "< Maximum 1D texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DWidth: cudaDeviceAttr = 21;
#[doc = "< Maximum 2D texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DWidth: cudaDeviceAttr = 22;
#[doc = "< Maximum 2D texture height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DHeight: cudaDeviceAttr = 23;
#[doc = "< Maximum 3D texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DWidth: cudaDeviceAttr = 24;
#[doc = "< Maximum 3D texture height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DHeight: cudaDeviceAttr = 25;
#[doc = "< Maximum 3D texture depth"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DDepth: cudaDeviceAttr = 26;
#[doc = "< Maximum 2D layered texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLayeredWidth: cudaDeviceAttr = 27;
#[doc = "< Maximum 2D layered texture height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLayeredHeight: cudaDeviceAttr = 28;
#[doc = "< Maximum layers in a 2D layered texture"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLayeredLayers: cudaDeviceAttr = 29;
#[doc = "< Alignment requirement for surfaces"]
pub const cudaDeviceAttr_cudaDevAttrSurfaceAlignment: cudaDeviceAttr = 30;
#[doc = "< Device can possibly execute multiple kernels concurrently"]
pub const cudaDeviceAttr_cudaDevAttrConcurrentKernels: cudaDeviceAttr = 31;
#[doc = "< Device has ECC support enabled"]
pub const cudaDeviceAttr_cudaDevAttrEccEnabled: cudaDeviceAttr = 32;
#[doc = "< PCI bus ID of the device"]
pub const cudaDeviceAttr_cudaDevAttrPciBusId: cudaDeviceAttr = 33;
#[doc = "< PCI device ID of the device"]
pub const cudaDeviceAttr_cudaDevAttrPciDeviceId: cudaDeviceAttr = 34;
#[doc = "< Device is using TCC driver model"]
pub const cudaDeviceAttr_cudaDevAttrTccDriver: cudaDeviceAttr = 35;
#[doc = "< Peak memory clock frequency in kilohertz"]
pub const cudaDeviceAttr_cudaDevAttrMemoryClockRate: cudaDeviceAttr = 36;
#[doc = "< Global memory bus width in bits"]
pub const cudaDeviceAttr_cudaDevAttrGlobalMemoryBusWidth: cudaDeviceAttr = 37;
#[doc = "< Size of L2 cache in bytes"]
pub const cudaDeviceAttr_cudaDevAttrL2CacheSize: cudaDeviceAttr = 38;
#[doc = "< Maximum resident threads per multiprocessor"]
pub const cudaDeviceAttr_cudaDevAttrMaxThreadsPerMultiProcessor: cudaDeviceAttr = 39;
#[doc = "< Number of asynchronous engines"]
pub const cudaDeviceAttr_cudaDevAttrAsyncEngineCount: cudaDeviceAttr = 40;
#[doc = "< Device shares a unified address space with the host"]
pub const cudaDeviceAttr_cudaDevAttrUnifiedAddressing: cudaDeviceAttr = 41;
#[doc = "< Maximum 1D layered texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DLayeredWidth: cudaDeviceAttr = 42;
#[doc = "< Maximum layers in a 1D layered texture"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DLayeredLayers: cudaDeviceAttr = 43;
#[doc = "< Maximum 2D texture width if cudaArrayTextureGather is set"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DGatherWidth: cudaDeviceAttr = 45;
#[doc = "< Maximum 2D texture height if cudaArrayTextureGather is set"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DGatherHeight: cudaDeviceAttr = 46;
#[doc = "< Alternate maximum 3D texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DWidthAlt: cudaDeviceAttr = 47;
#[doc = "< Alternate maximum 3D texture height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DHeightAlt: cudaDeviceAttr = 48;
#[doc = "< Alternate maximum 3D texture depth"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DDepthAlt: cudaDeviceAttr = 49;
#[doc = "< PCI domain ID of the device"]
pub const cudaDeviceAttr_cudaDevAttrPciDomainId: cudaDeviceAttr = 50;
#[doc = "< Pitch alignment requirement for textures"]
pub const cudaDeviceAttr_cudaDevAttrTexturePitchAlignment: cudaDeviceAttr = 51;
#[doc = "< Maximum cubemap texture width/height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTextureCubemapWidth: cudaDeviceAttr = 52;
#[doc = "< Maximum cubemap layered texture width/height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTextureCubemapLayeredWidth: cudaDeviceAttr = 53;
#[doc = "< Maximum layers in a cubemap layered texture"]
pub const cudaDeviceAttr_cudaDevAttrMaxTextureCubemapLayeredLayers: cudaDeviceAttr = 54;
#[doc = "< Maximum 1D surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface1DWidth: cudaDeviceAttr = 55;
#[doc = "< Maximum 2D surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DWidth: cudaDeviceAttr = 56;
#[doc = "< Maximum 2D surface height"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DHeight: cudaDeviceAttr = 57;
#[doc = "< Maximum 3D surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface3DWidth: cudaDeviceAttr = 58;
#[doc = "< Maximum 3D surface height"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface3DHeight: cudaDeviceAttr = 59;
#[doc = "< Maximum 3D surface depth"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface3DDepth: cudaDeviceAttr = 60;
#[doc = "< Maximum 1D layered surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface1DLayeredWidth: cudaDeviceAttr = 61;
#[doc = "< Maximum layers in a 1D layered surface"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface1DLayeredLayers: cudaDeviceAttr = 62;
#[doc = "< Maximum 2D layered surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DLayeredWidth: cudaDeviceAttr = 63;
#[doc = "< Maximum 2D layered surface height"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DLayeredHeight: cudaDeviceAttr = 64;
#[doc = "< Maximum layers in a 2D layered surface"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DLayeredLayers: cudaDeviceAttr = 65;
#[doc = "< Maximum cubemap surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurfaceCubemapWidth: cudaDeviceAttr = 66;
#[doc = "< Maximum cubemap layered surface width"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurfaceCubemapLayeredWidth: cudaDeviceAttr = 67;
#[doc = "< Maximum layers in a cubemap layered surface"]
pub const cudaDeviceAttr_cudaDevAttrMaxSurfaceCubemapLayeredLayers: cudaDeviceAttr = 68;
#[doc = "< Maximum 1D linear texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DLinearWidth: cudaDeviceAttr = 69;
#[doc = "< Maximum 2D linear texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLinearWidth: cudaDeviceAttr = 70;
#[doc = "< Maximum 2D linear texture height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLinearHeight: cudaDeviceAttr = 71;
#[doc = "< Maximum 2D linear texture pitch in bytes"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLinearPitch: cudaDeviceAttr = 72;
#[doc = "< Maximum mipmapped 2D texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DMipmappedWidth: cudaDeviceAttr = 73;
#[doc = "< Maximum mipmapped 2D texture height"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DMipmappedHeight: cudaDeviceAttr = 74;
#[doc = "< Major compute capability version number"]
pub const cudaDeviceAttr_cudaDevAttrComputeCapabilityMajor: cudaDeviceAttr = 75;
#[doc = "< Minor compute capability version number"]
pub const cudaDeviceAttr_cudaDevAttrComputeCapabilityMinor: cudaDeviceAttr = 76;
#[doc = "< Maximum mipmapped 1D texture width"]
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DMipmappedWidth: cudaDeviceAttr = 77;
#[doc = "< Device supports stream priorities"]
pub const cudaDeviceAttr_cudaDevAttrStreamPrioritiesSupported: cudaDeviceAttr = 78;
#[doc = "< Device supports caching globals in L1"]
pub const cudaDeviceAttr_cudaDevAttrGlobalL1CacheSupported: cudaDeviceAttr = 79;
#[doc = "< Device supports caching locals in L1"]
pub const cudaDeviceAttr_cudaDevAttrLocalL1CacheSupported: cudaDeviceAttr = 80;
#[doc = "< Maximum shared memory available per multiprocessor in bytes"]
pub const cudaDeviceAttr_cudaDevAttrMaxSharedMemoryPerMultiprocessor: cudaDeviceAttr = 81;
#[doc = "< Maximum number of 32-bit registers available per multiprocessor"]
pub const cudaDeviceAttr_cudaDevAttrMaxRegistersPerMultiprocessor: cudaDeviceAttr = 82;
#[doc = "< Device can allocate managed memory on this system"]
pub const cudaDeviceAttr_cudaDevAttrManagedMemory: cudaDeviceAttr = 83;
#[doc = "< Device is on a multi-GPU board"]
pub const cudaDeviceAttr_cudaDevAttrIsMultiGpuBoard: cudaDeviceAttr = 84;
#[doc = "< Unique identifier for a group of devices on the same multi-GPU board"]
pub const cudaDeviceAttr_cudaDevAttrMultiGpuBoardGroupID: cudaDeviceAttr = 85;
#[doc = "< Link between the device and the host supports native atomic operations"]
pub const cudaDeviceAttr_cudaDevAttrHostNativeAtomicSupported: cudaDeviceAttr = 86;
#[doc = "< Ratio of single precision performance (in floating-point operations per second) to double precision performance"]
pub const cudaDeviceAttr_cudaDevAttrSingleToDoublePrecisionPerfRatio: cudaDeviceAttr = 87;
#[doc = "< Device supports coherently accessing pageable memory without calling cudaHostRegister on it"]
pub const cudaDeviceAttr_cudaDevAttrPageableMemoryAccess: cudaDeviceAttr = 88;
#[doc = "< Device can coherently access managed memory concurrently with the CPU"]
pub const cudaDeviceAttr_cudaDevAttrConcurrentManagedAccess: cudaDeviceAttr = 89;
#[doc = "< Device supports Compute Preemption"]
pub const cudaDeviceAttr_cudaDevAttrComputePreemptionSupported: cudaDeviceAttr = 90;
#[doc = "< Device can access host registered memory at the same virtual address as the CPU"]
pub const cudaDeviceAttr_cudaDevAttrCanUseHostPointerForRegisteredMem: cudaDeviceAttr = 91;
pub const cudaDeviceAttr_cudaDevAttrReserved92: cudaDeviceAttr = 92;
pub const cudaDeviceAttr_cudaDevAttrReserved93: cudaDeviceAttr = 93;
pub const cudaDeviceAttr_cudaDevAttrReserved94: cudaDeviceAttr = 94;
#[doc = "< Device supports launching cooperative kernels via ::cudaLaunchCooperativeKernel"]
pub const cudaDeviceAttr_cudaDevAttrCooperativeLaunch: cudaDeviceAttr = 95;
#[doc = "< Deprecated, cudaLaunchCooperativeKernelMultiDevice is deprecated."]
pub const cudaDeviceAttr_cudaDevAttrCooperativeMultiDeviceLaunch: cudaDeviceAttr = 96;
#[doc = "< The maximum optin shared memory per block. This value may vary by chip. See ::cudaFuncSetAttribute"]
pub const cudaDeviceAttr_cudaDevAttrMaxSharedMemoryPerBlockOptin: cudaDeviceAttr = 97;
#[doc = "< Device supports flushing of outstanding remote writes."]
pub const cudaDeviceAttr_cudaDevAttrCanFlushRemoteWrites: cudaDeviceAttr = 98;
#[doc = "< Device supports host memory registration via ::cudaHostRegister."]
pub const cudaDeviceAttr_cudaDevAttrHostRegisterSupported: cudaDeviceAttr = 99;
#[doc = "< Device accesses pageable memory via the host's page tables."]
pub const cudaDeviceAttr_cudaDevAttrPageableMemoryAccessUsesHostPageTables: cudaDeviceAttr = 100;
#[doc = "< Host can directly access managed memory on the device without migration."]
pub const cudaDeviceAttr_cudaDevAttrDirectManagedMemAccessFromHost: cudaDeviceAttr = 101;
#[doc = "< Maximum number of blocks per multiprocessor"]
pub const cudaDeviceAttr_cudaDevAttrMaxBlocksPerMultiprocessor: cudaDeviceAttr = 106;
#[doc = "< Maximum L2 persisting lines capacity setting in bytes."]
pub const cudaDeviceAttr_cudaDevAttrMaxPersistingL2CacheSize: cudaDeviceAttr = 108;
#[doc = "< Maximum value of cudaAccessPolicyWindow::num_bytes."]
pub const cudaDeviceAttr_cudaDevAttrMaxAccessPolicyWindowSize: cudaDeviceAttr = 109;
#[doc = "< Shared memory reserved by CUDA driver per block in bytes"]
pub const cudaDeviceAttr_cudaDevAttrReservedSharedMemoryPerBlock: cudaDeviceAttr = 111;
#[doc = "< Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays"]
pub const cudaDeviceAttr_cudaDevAttrSparseCudaArraySupported: cudaDeviceAttr = 112;
#[doc = "< Device supports using the ::cudaHostRegister flag cudaHostRegisterReadOnly to register memory that must be mapped as read-only to the GPU"]
pub const cudaDeviceAttr_cudaDevAttrHostRegisterReadOnlySupported: cudaDeviceAttr = 113;
#[doc = "< External timeline semaphore interop is supported on the device"]
pub const cudaDeviceAttr_cudaDevAttrTimelineSemaphoreInteropSupported: cudaDeviceAttr = 114;
#[doc = "< Deprecated, External timeline semaphore interop is supported on the device"]
pub const cudaDeviceAttr_cudaDevAttrMaxTimelineSemaphoreInteropSupported: cudaDeviceAttr = 114;
#[doc = "< Device supports using the ::cudaMallocAsync and ::cudaMemPool family of APIs"]
pub const cudaDeviceAttr_cudaDevAttrMemoryPoolsSupported: cudaDeviceAttr = 115;
#[doc = "< Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see https://docs.nvidia.com/cuda/gpudirect-rdma for more information)"]
pub const cudaDeviceAttr_cudaDevAttrGPUDirectRDMASupported: cudaDeviceAttr = 116;
#[doc = "< The returned attribute shall be interpreted as a bitmask, where the individual bits are listed in the ::cudaFlushGPUDirectRDMAWritesOptions enum"]
pub const cudaDeviceAttr_cudaDevAttrGPUDirectRDMAFlushWritesOptions: cudaDeviceAttr = 117;
#[doc = "< GPUDirect RDMA writes to the device do not need to be flushed for consumers within the scope indicated by the returned attribute. See ::cudaGPUDirectRDMAWritesOrdering for the numerical values returned here."]
pub const cudaDeviceAttr_cudaDevAttrGPUDirectRDMAWritesOrdering: cudaDeviceAttr = 118;
#[doc = "< Handle types supported with mempool based IPC"]
pub const cudaDeviceAttr_cudaDevAttrMemoryPoolSupportedHandleTypes: cudaDeviceAttr = 119;
#[doc = "< Indicates device supports cluster launch"]
pub const cudaDeviceAttr_cudaDevAttrClusterLaunch: cudaDeviceAttr = 120;
#[doc = "< Device supports deferred mapping CUDA arrays and CUDA mipmapped arrays"]
pub const cudaDeviceAttr_cudaDevAttrDeferredMappingCudaArraySupported: cudaDeviceAttr = 121;
pub const cudaDeviceAttr_cudaDevAttrMax: cudaDeviceAttr = 122;
#[doc = " CUDA device attributes"]
pub type cudaDeviceAttr = ::std::os::raw::c_int;
#[doc = " (value type = int)\n Allow cuMemAllocAsync to use memory asynchronously freed\n in another streams as long as a stream ordering dependency\n of the allocating stream on the free action exists.\n Cuda events and null stream interactions can create the required\n stream ordered dependencies. (default enabled)"]
pub const cudaMemPoolAttr_cudaMemPoolReuseFollowEventDependencies: cudaMemPoolAttr = 1;
#[doc = " (value type = int)\n Allow reuse of already completed frees when there is no dependency\n between the free and allocation. (default enabled)"]
pub const cudaMemPoolAttr_cudaMemPoolReuseAllowOpportunistic: cudaMemPoolAttr = 2;
#[doc = " (value type = int)\n Allow cuMemAllocAsync to insert new stream dependencies\n in order to establish the stream ordering required to reuse\n a piece of memory released by cuFreeAsync (default enabled)."]
pub const cudaMemPoolAttr_cudaMemPoolReuseAllowInternalDependencies: cudaMemPoolAttr = 3;
#[doc = " (value type = cuuint64_t)\n Amount of reserved memory in bytes to hold onto before trying\n to release memory back to the OS. When more than the release\n threshold bytes of memory are held by the memory pool, the\n allocator will try to release memory back to the OS on the\n next call to stream, event or context synchronize. (default 0)"]
pub const cudaMemPoolAttr_cudaMemPoolAttrReleaseThreshold: cudaMemPoolAttr = 4;
#[doc = " (value type = cuuint64_t)\n Amount of backing memory currently allocated for the mempool."]
pub const cudaMemPoolAttr_cudaMemPoolAttrReservedMemCurrent: cudaMemPoolAttr = 5;
#[doc = " (value type = cuuint64_t)\n High watermark of backing memory allocated for the mempool since the\n last time it was reset. High watermark can only be reset to zero."]
pub const cudaMemPoolAttr_cudaMemPoolAttrReservedMemHigh: cudaMemPoolAttr = 6;
#[doc = " (value type = cuuint64_t)\n Amount of memory from the pool that is currently in use by the application."]
pub const cudaMemPoolAttr_cudaMemPoolAttrUsedMemCurrent: cudaMemPoolAttr = 7;
#[doc = " (value type = cuuint64_t)\n High watermark of the amount of memory from the pool that was in use by the application since\n the last time it was reset. High watermark can only be reset to zero."]
pub const cudaMemPoolAttr_cudaMemPoolAttrUsedMemHigh: cudaMemPoolAttr = 8;
#[doc = " CUDA memory pool attributes"]
pub type cudaMemPoolAttr = ::std::os::raw::c_int;
pub const cudaMemLocationType_cudaMemLocationTypeInvalid: cudaMemLocationType = 0;
#[doc = "< Location is a device location, thus id is a device ordinal"]
pub const cudaMemLocationType_cudaMemLocationTypeDevice: cudaMemLocationType = 1;
#[doc = " Specifies the type of location"]
pub type cudaMemLocationType = ::std::os::raw::c_int;
#[doc = " Specifies a memory location.\n\n To specify a gpu, set type = ::cudaMemLocationTypeDevice and set id = the gpu's device ordinal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemLocation {
    #[doc = "< Specifies the location type, which modifies the meaning of id."]
    pub type_: cudaMemLocationType,
    #[doc = "< identifier for a given this location's ::CUmemLocationType."]
    pub id: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaMemLocation"][::std::mem::size_of::<cudaMemLocation>() - 8usize];
    ["Alignment of cudaMemLocation"][::std::mem::align_of::<cudaMemLocation>() - 4usize];
    ["Offset of field: cudaMemLocation::type_"]
        [::std::mem::offset_of!(cudaMemLocation, type_) - 0usize];
    ["Offset of field: cudaMemLocation::id"][::std::mem::offset_of!(cudaMemLocation, id) - 4usize];
};
#[doc = "< Default, make the address range not accessible"]
pub const cudaMemAccessFlags_cudaMemAccessFlagsProtNone: cudaMemAccessFlags = 0;
#[doc = "< Make the address range read accessible"]
pub const cudaMemAccessFlags_cudaMemAccessFlagsProtRead: cudaMemAccessFlags = 1;
#[doc = "< Make the address range read-write accessible"]
pub const cudaMemAccessFlags_cudaMemAccessFlagsProtReadWrite: cudaMemAccessFlags = 3;
#[doc = " Specifies the memory protection flags for mapping."]
pub type cudaMemAccessFlags = ::std::os::raw::c_int;
#[doc = " Memory access descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemAccessDesc {
    #[doc = "< Location on which the request is to change it's accessibility"]
    pub location: cudaMemLocation,
    #[doc = "< ::CUmemProt accessibility flags to set on the request"]
    pub flags: cudaMemAccessFlags,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaMemAccessDesc"][::std::mem::size_of::<cudaMemAccessDesc>() - 12usize];
    ["Alignment of cudaMemAccessDesc"][::std::mem::align_of::<cudaMemAccessDesc>() - 4usize];
    ["Offset of field: cudaMemAccessDesc::location"]
        [::std::mem::offset_of!(cudaMemAccessDesc, location) - 0usize];
    ["Offset of field: cudaMemAccessDesc::flags"]
        [::std::mem::offset_of!(cudaMemAccessDesc, flags) - 8usize];
};
pub const cudaMemAllocationType_cudaMemAllocationTypeInvalid: cudaMemAllocationType = 0;
#[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
pub const cudaMemAllocationType_cudaMemAllocationTypePinned: cudaMemAllocationType = 1;
#[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
pub const cudaMemAllocationType_cudaMemAllocationTypeMax: cudaMemAllocationType = 2147483647;
#[doc = " Defines the allocation types available"]
pub type cudaMemAllocationType = ::std::os::raw::c_int;
#[doc = "< Does not allow any export mechanism. >"]
pub const cudaMemAllocationHandleType_cudaMemHandleTypeNone: cudaMemAllocationHandleType = 0;
#[doc = "< Allows a file descriptor to be used for exporting. Permitted only on POSIX systems. (int)"]
pub const cudaMemAllocationHandleType_cudaMemHandleTypePosixFileDescriptor:
cudaMemAllocationHandleType = 1;
#[doc = "< Allows a Win32 NT handle to be used for exporting. (HANDLE)"]
pub const cudaMemAllocationHandleType_cudaMemHandleTypeWin32: cudaMemAllocationHandleType = 2;
#[doc = "< Allows a Win32 KMT handle to be used for exporting. (D3DKMT_HANDLE)"]
pub const cudaMemAllocationHandleType_cudaMemHandleTypeWin32Kmt: cudaMemAllocationHandleType = 4;
#[doc = " Flags for specifying particular handle types"]
pub type cudaMemAllocationHandleType = ::std::os::raw::c_int;
#[doc = " Specifies the properties of allocations made from the pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemPoolProps {
    #[doc = "< Allocation type. Currently must be specified as cudaMemAllocationTypePinned"]
    pub allocType: cudaMemAllocationType,
    #[doc = "< Handle types that will be supported by allocations from the pool."]
    pub handleTypes: cudaMemAllocationHandleType,
    #[doc = "< Location allocations should reside."]
    pub location: cudaMemLocation,
    #[doc = " Windows-specific LPSECURITYATTRIBUTES required when\n ::cudaMemHandleTypeWin32 is specified.  This security attribute defines\n the scope of which exported allocations may be tranferred to other\n processes.  In all other cases, this field is required to be zero."]
    pub win32SecurityAttributes: *mut ::std::os::raw::c_void,
    #[doc = "< reserved for future use, must be 0"]
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaMemPoolProps"][::std::mem::size_of::<cudaMemPoolProps>() - 88usize];
    ["Alignment of cudaMemPoolProps"][::std::mem::align_of::<cudaMemPoolProps>() - 8usize];
    ["Offset of field: cudaMemPoolProps::allocType"]
        [::std::mem::offset_of!(cudaMemPoolProps, allocType) - 0usize];
    ["Offset of field: cudaMemPoolProps::handleTypes"]
        [::std::mem::offset_of!(cudaMemPoolProps, handleTypes) - 4usize];
    ["Offset of field: cudaMemPoolProps::location"]
        [::std::mem::offset_of!(cudaMemPoolProps, location) - 8usize];
    ["Offset of field: cudaMemPoolProps::win32SecurityAttributes"]
        [::std::mem::offset_of!(cudaMemPoolProps, win32SecurityAttributes) - 16usize];
    ["Offset of field: cudaMemPoolProps::reserved"]
        [::std::mem::offset_of!(cudaMemPoolProps, reserved) - 24usize];
};
#[doc = " Opaque data for exporting a pool allocation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemPoolPtrExportData {
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaMemPoolPtrExportData"]
        [::std::mem::size_of::<cudaMemPoolPtrExportData>() - 64usize];
    ["Alignment of cudaMemPoolPtrExportData"]
        [::std::mem::align_of::<cudaMemPoolPtrExportData>() - 1usize];
    ["Offset of field: cudaMemPoolPtrExportData::reserved"]
        [::std::mem::offset_of!(cudaMemPoolPtrExportData, reserved) - 0usize];
};
#[doc = " Memory allocation node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemAllocNodeParams {
    #[doc = "< in: array of memory access descriptors. Used to describe peer GPU access"]
    pub poolProps: cudaMemPoolProps,
    #[doc = "< in: number of memory access descriptors.  Must not exceed the number of GPUs."]
    pub accessDescs: *const cudaMemAccessDesc,
    #[doc = "< in: Number of `accessDescs`s"]
    pub accessDescCount: usize,
    #[doc = "< in: size in bytes of the requested allocation"]
    pub bytesize: usize,
    #[doc = "< out: address of the allocation returned by CUDA"]
    pub dptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaMemAllocNodeParams"][::std::mem::size_of::<cudaMemAllocNodeParams>() - 120usize];
    ["Alignment of cudaMemAllocNodeParams"]
        [::std::mem::align_of::<cudaMemAllocNodeParams>() - 8usize];
    ["Offset of field: cudaMemAllocNodeParams::poolProps"]
        [::std::mem::offset_of!(cudaMemAllocNodeParams, poolProps) - 0usize];
    ["Offset of field: cudaMemAllocNodeParams::accessDescs"]
        [::std::mem::offset_of!(cudaMemAllocNodeParams, accessDescs) - 88usize];
    ["Offset of field: cudaMemAllocNodeParams::accessDescCount"]
        [::std::mem::offset_of!(cudaMemAllocNodeParams, accessDescCount) - 96usize];
    ["Offset of field: cudaMemAllocNodeParams::bytesize"]
        [::std::mem::offset_of!(cudaMemAllocNodeParams, bytesize) - 104usize];
    ["Offset of field: cudaMemAllocNodeParams::dptr"]
        [::std::mem::offset_of!(cudaMemAllocNodeParams, dptr) - 112usize];
};
#[doc = " (value type = cuuint64_t)\n Amount of memory, in bytes, currently associated with graphs."]
pub const cudaGraphMemAttributeType_cudaGraphMemAttrUsedMemCurrent: cudaGraphMemAttributeType = 0;
#[doc = " (value type = cuuint64_t)\n High watermark of memory, in bytes, associated with graphs since the\n last time it was reset.  High watermark can only be reset to zero."]
pub const cudaGraphMemAttributeType_cudaGraphMemAttrUsedMemHigh: cudaGraphMemAttributeType = 1;
#[doc = " (value type = cuuint64_t)\n Amount of memory, in bytes, currently allocated for use by\n the CUDA graphs asynchronous allocator."]
pub const cudaGraphMemAttributeType_cudaGraphMemAttrReservedMemCurrent: cudaGraphMemAttributeType =
    2;
#[doc = " (value type = cuuint64_t)\n High watermark of memory, in bytes, currently allocated for use by\n the CUDA graphs asynchronous allocator."]
pub const cudaGraphMemAttributeType_cudaGraphMemAttrReservedMemHigh: cudaGraphMemAttributeType = 3;
#[doc = " Graph memory attributes"]
pub type cudaGraphMemAttributeType = ::std::os::raw::c_int;
#[doc = "< A relative value indicating the performance of the link between two devices"]
pub const cudaDeviceP2PAttr_cudaDevP2PAttrPerformanceRank: cudaDeviceP2PAttr = 1;
#[doc = "< Peer access is enabled"]
pub const cudaDeviceP2PAttr_cudaDevP2PAttrAccessSupported: cudaDeviceP2PAttr = 2;
#[doc = "< Native atomic operation over the link supported"]
pub const cudaDeviceP2PAttr_cudaDevP2PAttrNativeAtomicSupported: cudaDeviceP2PAttr = 3;
#[doc = "< Accessing CUDA arrays over the link supported"]
pub const cudaDeviceP2PAttr_cudaDevP2PAttrCudaArrayAccessSupported: cudaDeviceP2PAttr = 4;
#[doc = " CUDA device P2P attributes"]
pub type cudaDeviceP2PAttr = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuuid_st {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUuuid_st"][::std::mem::size_of::<CUuuid_st>() - 16usize];
    ["Alignment of CUuuid_st"][::std::mem::align_of::<CUuuid_st>() - 1usize];
    ["Offset of field: CUuuid_st::bytes"][::std::mem::offset_of!(CUuuid_st, bytes) - 0usize];
};
pub type CUuuid = CUuuid_st;
pub type cudaUUID_t = CUuuid_st;
#[doc = " CUDA device properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaDeviceProp {
    #[doc = "< ASCII string identifying device"]
    pub name: [::std::os::raw::c_char; 256usize],
    #[doc = "< 16-byte unique identifier"]
    pub uuid: cudaUUID_t,
    #[doc = "< 8-byte locally unique identifier. Value is undefined on TCC and non-Windows platforms"]
    pub luid: [::std::os::raw::c_char; 8usize],
    #[doc = "< LUID device node mask. Value is undefined on TCC and non-Windows platforms"]
    pub luidDeviceNodeMask: ::std::os::raw::c_uint,
    #[doc = "< Global memory available on device in bytes"]
    pub totalGlobalMem: usize,
    #[doc = "< Shared memory available per block in bytes"]
    pub sharedMemPerBlock: usize,
    #[doc = "< 32-bit registers available per block"]
    pub regsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Warp size in threads"]
    pub warpSize: ::std::os::raw::c_int,
    #[doc = "< Maximum pitch in bytes allowed by memory copies"]
    pub memPitch: usize,
    #[doc = "< Maximum number of threads per block"]
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Maximum size of each dimension of a block"]
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum size of each dimension of a grid"]
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    #[doc = "< Clock frequency in kilohertz"]
    pub clockRate: ::std::os::raw::c_int,
    #[doc = "< Constant memory available on device in bytes"]
    pub totalConstMem: usize,
    #[doc = "< Major compute capability"]
    pub major: ::std::os::raw::c_int,
    #[doc = "< Minor compute capability"]
    pub minor: ::std::os::raw::c_int,
    #[doc = "< Alignment requirement for textures"]
    pub textureAlignment: usize,
    #[doc = "< Pitch alignment requirement for texture references bound to pitched memory"]
    pub texturePitchAlignment: usize,
    #[doc = "< Device can concurrently copy memory and execute a kernel. Deprecated. Use instead asyncEngineCount."]
    pub deviceOverlap: ::std::os::raw::c_int,
    #[doc = "< Number of multiprocessors on device"]
    pub multiProcessorCount: ::std::os::raw::c_int,
    #[doc = "< Specified whether there is a run time limit on kernels"]
    pub kernelExecTimeoutEnabled: ::std::os::raw::c_int,
    #[doc = "< Device is integrated as opposed to discrete"]
    pub integrated: ::std::os::raw::c_int,
    #[doc = "< Device can map host memory with cudaHostAlloc/cudaHostGetDevicePointer"]
    pub canMapHostMemory: ::std::os::raw::c_int,
    #[doc = "< Compute mode (See ::cudaComputeMode)"]
    pub computeMode: ::std::os::raw::c_int,
    #[doc = "< Maximum 1D texture size"]
    pub maxTexture1D: ::std::os::raw::c_int,
    #[doc = "< Maximum 1D mipmapped texture size"]
    pub maxTexture1DMipmap: ::std::os::raw::c_int,
    #[doc = "< Deprecated, do not use. Use cudaDeviceGetTexture1DLinearMaxWidth() or cuDeviceGetTexture1DLinearMaxWidth() instead."]
    pub maxTexture1DLinear: ::std::os::raw::c_int,
    #[doc = "< Maximum 2D texture dimensions"]
    pub maxTexture2D: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 2D mipmapped texture dimensions"]
    pub maxTexture2DMipmap: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum dimensions (width, height, pitch) for 2D textures bound to pitched memory"]
    pub maxTexture2DLinear: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum 2D texture dimensions if texture gather operations have to be performed"]
    pub maxTexture2DGather: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 3D texture dimensions"]
    pub maxTexture3D: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum alternate 3D texture dimensions"]
    pub maxTexture3DAlt: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum Cubemap texture dimensions"]
    pub maxTextureCubemap: ::std::os::raw::c_int,
    #[doc = "< Maximum 1D layered texture dimensions"]
    pub maxTexture1DLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 2D layered texture dimensions"]
    pub maxTexture2DLayered: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum Cubemap layered texture dimensions"]
    pub maxTextureCubemapLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 1D surface size"]
    pub maxSurface1D: ::std::os::raw::c_int,
    #[doc = "< Maximum 2D surface dimensions"]
    pub maxSurface2D: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 3D surface dimensions"]
    pub maxSurface3D: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum 1D layered surface dimensions"]
    pub maxSurface1DLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 2D layered surface dimensions"]
    pub maxSurface2DLayered: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum Cubemap surface dimensions"]
    pub maxSurfaceCubemap: ::std::os::raw::c_int,
    #[doc = "< Maximum Cubemap layered surface dimensions"]
    pub maxSurfaceCubemapLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Alignment requirements for surfaces"]
    pub surfaceAlignment: usize,
    #[doc = "< Device can possibly execute multiple kernels concurrently"]
    pub concurrentKernels: ::std::os::raw::c_int,
    #[doc = "< Device has ECC support enabled"]
    pub ECCEnabled: ::std::os::raw::c_int,
    #[doc = "< PCI bus ID of the device"]
    pub pciBusID: ::std::os::raw::c_int,
    #[doc = "< PCI device ID of the device"]
    pub pciDeviceID: ::std::os::raw::c_int,
    #[doc = "< PCI domain ID of the device"]
    pub pciDomainID: ::std::os::raw::c_int,
    #[doc = "< 1 if device is a Tesla device using TCC driver, 0 otherwise"]
    pub tccDriver: ::std::os::raw::c_int,
    #[doc = "< Number of asynchronous engines"]
    pub asyncEngineCount: ::std::os::raw::c_int,
    #[doc = "< Device shares a unified address space with the host"]
    pub unifiedAddressing: ::std::os::raw::c_int,
    #[doc = "< Peak memory clock frequency in kilohertz"]
    pub memoryClockRate: ::std::os::raw::c_int,
    #[doc = "< Global memory bus width in bits"]
    pub memoryBusWidth: ::std::os::raw::c_int,
    #[doc = "< Size of L2 cache in bytes"]
    pub l2CacheSize: ::std::os::raw::c_int,
    #[doc = "< Device's maximum l2 persisting lines capacity setting in bytes"]
    pub persistingL2CacheMaxSize: ::std::os::raw::c_int,
    #[doc = "< Maximum resident threads per multiprocessor"]
    pub maxThreadsPerMultiProcessor: ::std::os::raw::c_int,
    #[doc = "< Device supports stream priorities"]
    pub streamPrioritiesSupported: ::std::os::raw::c_int,
    #[doc = "< Device supports caching globals in L1"]
    pub globalL1CacheSupported: ::std::os::raw::c_int,
    #[doc = "< Device supports caching locals in L1"]
    pub localL1CacheSupported: ::std::os::raw::c_int,
    #[doc = "< Shared memory available per multiprocessor in bytes"]
    pub sharedMemPerMultiprocessor: usize,
    #[doc = "< 32-bit registers available per multiprocessor"]
    pub regsPerMultiprocessor: ::std::os::raw::c_int,
    #[doc = "< Device supports allocating managed memory on this system"]
    pub managedMemory: ::std::os::raw::c_int,
    #[doc = "< Device is on a multi-GPU board"]
    pub isMultiGpuBoard: ::std::os::raw::c_int,
    #[doc = "< Unique identifier for a group of devices on the same multi-GPU board"]
    pub multiGpuBoardGroupID: ::std::os::raw::c_int,
    #[doc = "< Link between the device and the host supports native atomic operations"]
    pub hostNativeAtomicSupported: ::std::os::raw::c_int,
    #[doc = "< Ratio of single precision performance (in floating-point operations per second) to double precision performance"]
    pub singleToDoublePrecisionPerfRatio: ::std::os::raw::c_int,
    #[doc = "< Device supports coherently accessing pageable memory without calling cudaHostRegister on it"]
    pub pageableMemoryAccess: ::std::os::raw::c_int,
    #[doc = "< Device can coherently access managed memory concurrently with the CPU"]
    pub concurrentManagedAccess: ::std::os::raw::c_int,
    #[doc = "< Device supports Compute Preemption"]
    pub computePreemptionSupported: ::std::os::raw::c_int,
    #[doc = "< Device can access host registered memory at the same virtual address as the CPU"]
    pub canUseHostPointerForRegisteredMem: ::std::os::raw::c_int,
    #[doc = "< Device supports launching cooperative kernels via ::cudaLaunchCooperativeKernel"]
    pub cooperativeLaunch: ::std::os::raw::c_int,
    #[doc = "< Deprecated, cudaLaunchCooperativeKernelMultiDevice is deprecated."]
    pub cooperativeMultiDeviceLaunch: ::std::os::raw::c_int,
    #[doc = "< Per device maximum shared memory per block usable by special opt in"]
    pub sharedMemPerBlockOptin: usize,
    #[doc = "< Device accesses pageable memory via the host's page tables"]
    pub pageableMemoryAccessUsesHostPageTables: ::std::os::raw::c_int,
    #[doc = "< Host can directly access managed memory on the device without migration."]
    pub directManagedMemAccessFromHost: ::std::os::raw::c_int,
    #[doc = "< Maximum number of resident blocks per multiprocessor"]
    pub maxBlocksPerMultiProcessor: ::std::os::raw::c_int,
    #[doc = "< The maximum value of ::cudaAccessPolicyWindow::num_bytes."]
    pub accessPolicyMaxWindowSize: ::std::os::raw::c_int,
    #[doc = "< Shared memory reserved by CUDA driver per block in bytes"]
    pub reservedSharedMemPerBlock: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaDeviceProp"][::std::mem::size_of::<cudaDeviceProp>() - 728usize];
    ["Alignment of cudaDeviceProp"][::std::mem::align_of::<cudaDeviceProp>() - 8usize];
    ["Offset of field: cudaDeviceProp::name"]
        [::std::mem::offset_of!(cudaDeviceProp, name) - 0usize];
    ["Offset of field: cudaDeviceProp::uuid"]
        [::std::mem::offset_of!(cudaDeviceProp, uuid) - 256usize];
    ["Offset of field: cudaDeviceProp::luid"]
        [::std::mem::offset_of!(cudaDeviceProp, luid) - 272usize];
    ["Offset of field: cudaDeviceProp::luidDeviceNodeMask"]
        [::std::mem::offset_of!(cudaDeviceProp, luidDeviceNodeMask) - 280usize];
    ["Offset of field: cudaDeviceProp::totalGlobalMem"]
        [::std::mem::offset_of!(cudaDeviceProp, totalGlobalMem) - 288usize];
    ["Offset of field: cudaDeviceProp::sharedMemPerBlock"]
        [::std::mem::offset_of!(cudaDeviceProp, sharedMemPerBlock) - 296usize];
    ["Offset of field: cudaDeviceProp::regsPerBlock"]
        [::std::mem::offset_of!(cudaDeviceProp, regsPerBlock) - 304usize];
    ["Offset of field: cudaDeviceProp::warpSize"]
        [::std::mem::offset_of!(cudaDeviceProp, warpSize) - 308usize];
    ["Offset of field: cudaDeviceProp::memPitch"]
        [::std::mem::offset_of!(cudaDeviceProp, memPitch) - 312usize];
    ["Offset of field: cudaDeviceProp::maxThreadsPerBlock"]
        [::std::mem::offset_of!(cudaDeviceProp, maxThreadsPerBlock) - 320usize];
    ["Offset of field: cudaDeviceProp::maxThreadsDim"]
        [::std::mem::offset_of!(cudaDeviceProp, maxThreadsDim) - 324usize];
    ["Offset of field: cudaDeviceProp::maxGridSize"]
        [::std::mem::offset_of!(cudaDeviceProp, maxGridSize) - 336usize];
    ["Offset of field: cudaDeviceProp::clockRate"]
        [::std::mem::offset_of!(cudaDeviceProp, clockRate) - 348usize];
    ["Offset of field: cudaDeviceProp::totalConstMem"]
        [::std::mem::offset_of!(cudaDeviceProp, totalConstMem) - 352usize];
    ["Offset of field: cudaDeviceProp::major"]
        [::std::mem::offset_of!(cudaDeviceProp, major) - 360usize];
    ["Offset of field: cudaDeviceProp::minor"]
        [::std::mem::offset_of!(cudaDeviceProp, minor) - 364usize];
    ["Offset of field: cudaDeviceProp::textureAlignment"]
        [::std::mem::offset_of!(cudaDeviceProp, textureAlignment) - 368usize];
    ["Offset of field: cudaDeviceProp::texturePitchAlignment"]
        [::std::mem::offset_of!(cudaDeviceProp, texturePitchAlignment) - 376usize];
    ["Offset of field: cudaDeviceProp::deviceOverlap"]
        [::std::mem::offset_of!(cudaDeviceProp, deviceOverlap) - 384usize];
    ["Offset of field: cudaDeviceProp::multiProcessorCount"]
        [::std::mem::offset_of!(cudaDeviceProp, multiProcessorCount) - 388usize];
    ["Offset of field: cudaDeviceProp::kernelExecTimeoutEnabled"]
        [::std::mem::offset_of!(cudaDeviceProp, kernelExecTimeoutEnabled) - 392usize];
    ["Offset of field: cudaDeviceProp::integrated"]
        [::std::mem::offset_of!(cudaDeviceProp, integrated) - 396usize];
    ["Offset of field: cudaDeviceProp::canMapHostMemory"]
        [::std::mem::offset_of!(cudaDeviceProp, canMapHostMemory) - 400usize];
    ["Offset of field: cudaDeviceProp::computeMode"]
        [::std::mem::offset_of!(cudaDeviceProp, computeMode) - 404usize];
    ["Offset of field: cudaDeviceProp::maxTexture1D"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTexture1D) - 408usize];
    ["Offset of field: cudaDeviceProp::maxTexture1DMipmap"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTexture1DMipmap) - 412usize];
    ["Offset of field: cudaDeviceProp::maxTexture1DLinear"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTexture1DLinear) - 416usize];
    ["Offset of field: cudaDeviceProp::maxTexture2D"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTexture2D) - 420usize];
    ["Offset of field: cudaDeviceProp::maxTexture2DMipmap"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTexture2DMipmap) - 428usize];
    ["Offset of field: cudaDeviceProp::maxTexture2DLinear"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTexture2DLinear) - 436usize];
    ["Offset of field: cudaDeviceProp::maxTexture2DGather"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTexture2DGather) - 448usize];
    ["Offset of field: cudaDeviceProp::maxTexture3D"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTexture3D) - 456usize];
    ["Offset of field: cudaDeviceProp::maxTexture3DAlt"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTexture3DAlt) - 468usize];
    ["Offset of field: cudaDeviceProp::maxTextureCubemap"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTextureCubemap) - 480usize];
    ["Offset of field: cudaDeviceProp::maxTexture1DLayered"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTexture1DLayered) - 484usize];
    ["Offset of field: cudaDeviceProp::maxTexture2DLayered"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTexture2DLayered) - 492usize];
    ["Offset of field: cudaDeviceProp::maxTextureCubemapLayered"]
        [::std::mem::offset_of!(cudaDeviceProp, maxTextureCubemapLayered) - 504usize];
    ["Offset of field: cudaDeviceProp::maxSurface1D"]
        [::std::mem::offset_of!(cudaDeviceProp, maxSurface1D) - 512usize];
    ["Offset of field: cudaDeviceProp::maxSurface2D"]
        [::std::mem::offset_of!(cudaDeviceProp, maxSurface2D) - 516usize];
    ["Offset of field: cudaDeviceProp::maxSurface3D"]
        [::std::mem::offset_of!(cudaDeviceProp, maxSurface3D) - 524usize];
    ["Offset of field: cudaDeviceProp::maxSurface1DLayered"]
        [::std::mem::offset_of!(cudaDeviceProp, maxSurface1DLayered) - 536usize];
    ["Offset of field: cudaDeviceProp::maxSurface2DLayered"]
        [::std::mem::offset_of!(cudaDeviceProp, maxSurface2DLayered) - 544usize];
    ["Offset of field: cudaDeviceProp::maxSurfaceCubemap"]
        [::std::mem::offset_of!(cudaDeviceProp, maxSurfaceCubemap) - 556usize];
    ["Offset of field: cudaDeviceProp::maxSurfaceCubemapLayered"]
        [::std::mem::offset_of!(cudaDeviceProp, maxSurfaceCubemapLayered) - 560usize];
    ["Offset of field: cudaDeviceProp::surfaceAlignment"]
        [::std::mem::offset_of!(cudaDeviceProp, surfaceAlignment) - 568usize];
    ["Offset of field: cudaDeviceProp::concurrentKernels"]
        [::std::mem::offset_of!(cudaDeviceProp, concurrentKernels) - 576usize];
    ["Offset of field: cudaDeviceProp::ECCEnabled"]
        [::std::mem::offset_of!(cudaDeviceProp, ECCEnabled) - 580usize];
    ["Offset of field: cudaDeviceProp::pciBusID"]
        [::std::mem::offset_of!(cudaDeviceProp, pciBusID) - 584usize];
    ["Offset of field: cudaDeviceProp::pciDeviceID"]
        [::std::mem::offset_of!(cudaDeviceProp, pciDeviceID) - 588usize];
    ["Offset of field: cudaDeviceProp::pciDomainID"]
        [::std::mem::offset_of!(cudaDeviceProp, pciDomainID) - 592usize];
    ["Offset of field: cudaDeviceProp::tccDriver"]
        [::std::mem::offset_of!(cudaDeviceProp, tccDriver) - 596usize];
    ["Offset of field: cudaDeviceProp::asyncEngineCount"]
        [::std::mem::offset_of!(cudaDeviceProp, asyncEngineCount) - 600usize];
    ["Offset of field: cudaDeviceProp::unifiedAddressing"]
        [::std::mem::offset_of!(cudaDeviceProp, unifiedAddressing) - 604usize];
    ["Offset of field: cudaDeviceProp::memoryClockRate"]
        [::std::mem::offset_of!(cudaDeviceProp, memoryClockRate) - 608usize];
    ["Offset of field: cudaDeviceProp::memoryBusWidth"]
        [::std::mem::offset_of!(cudaDeviceProp, memoryBusWidth) - 612usize];
    ["Offset of field: cudaDeviceProp::l2CacheSize"]
        [::std::mem::offset_of!(cudaDeviceProp, l2CacheSize) - 616usize];
    ["Offset of field: cudaDeviceProp::persistingL2CacheMaxSize"]
        [::std::mem::offset_of!(cudaDeviceProp, persistingL2CacheMaxSize) - 620usize];
    ["Offset of field: cudaDeviceProp::maxThreadsPerMultiProcessor"]
        [::std::mem::offset_of!(cudaDeviceProp, maxThreadsPerMultiProcessor) - 624usize];
    ["Offset of field: cudaDeviceProp::streamPrioritiesSupported"]
        [::std::mem::offset_of!(cudaDeviceProp, streamPrioritiesSupported) - 628usize];
    ["Offset of field: cudaDeviceProp::globalL1CacheSupported"]
        [::std::mem::offset_of!(cudaDeviceProp, globalL1CacheSupported) - 632usize];
    ["Offset of field: cudaDeviceProp::localL1CacheSupported"]
        [::std::mem::offset_of!(cudaDeviceProp, localL1CacheSupported) - 636usize];
    ["Offset of field: cudaDeviceProp::sharedMemPerMultiprocessor"]
        [::std::mem::offset_of!(cudaDeviceProp, sharedMemPerMultiprocessor) - 640usize];
    ["Offset of field: cudaDeviceProp::regsPerMultiprocessor"]
        [::std::mem::offset_of!(cudaDeviceProp, regsPerMultiprocessor) - 648usize];
    ["Offset of field: cudaDeviceProp::managedMemory"]
        [::std::mem::offset_of!(cudaDeviceProp, managedMemory) - 652usize];
    ["Offset of field: cudaDeviceProp::isMultiGpuBoard"]
        [::std::mem::offset_of!(cudaDeviceProp, isMultiGpuBoard) - 656usize];
    ["Offset of field: cudaDeviceProp::multiGpuBoardGroupID"]
        [::std::mem::offset_of!(cudaDeviceProp, multiGpuBoardGroupID) - 660usize];
    ["Offset of field: cudaDeviceProp::hostNativeAtomicSupported"]
        [::std::mem::offset_of!(cudaDeviceProp, hostNativeAtomicSupported) - 664usize];
    ["Offset of field: cudaDeviceProp::singleToDoublePrecisionPerfRatio"]
        [::std::mem::offset_of!(cudaDeviceProp, singleToDoublePrecisionPerfRatio) - 668usize];
    ["Offset of field: cudaDeviceProp::pageableMemoryAccess"]
        [::std::mem::offset_of!(cudaDeviceProp, pageableMemoryAccess) - 672usize];
    ["Offset of field: cudaDeviceProp::concurrentManagedAccess"]
        [::std::mem::offset_of!(cudaDeviceProp, concurrentManagedAccess) - 676usize];
    ["Offset of field: cudaDeviceProp::computePreemptionSupported"]
        [::std::mem::offset_of!(cudaDeviceProp, computePreemptionSupported) - 680usize];
    ["Offset of field: cudaDeviceProp::canUseHostPointerForRegisteredMem"]
        [::std::mem::offset_of!(cudaDeviceProp, canUseHostPointerForRegisteredMem) - 684usize];
    ["Offset of field: cudaDeviceProp::cooperativeLaunch"]
        [::std::mem::offset_of!(cudaDeviceProp, cooperativeLaunch) - 688usize];
    ["Offset of field: cudaDeviceProp::cooperativeMultiDeviceLaunch"]
        [::std::mem::offset_of!(cudaDeviceProp, cooperativeMultiDeviceLaunch) - 692usize];
    ["Offset of field: cudaDeviceProp::sharedMemPerBlockOptin"]
        [::std::mem::offset_of!(cudaDeviceProp, sharedMemPerBlockOptin) - 696usize];
    ["Offset of field: cudaDeviceProp::pageableMemoryAccessUsesHostPageTables"]
        [::std::mem::offset_of!(cudaDeviceProp, pageableMemoryAccessUsesHostPageTables) - 704usize];
    ["Offset of field: cudaDeviceProp::directManagedMemAccessFromHost"]
        [::std::mem::offset_of!(cudaDeviceProp, directManagedMemAccessFromHost) - 708usize];
    ["Offset of field: cudaDeviceProp::maxBlocksPerMultiProcessor"]
        [::std::mem::offset_of!(cudaDeviceProp, maxBlocksPerMultiProcessor) - 712usize];
    ["Offset of field: cudaDeviceProp::accessPolicyMaxWindowSize"]
        [::std::mem::offset_of!(cudaDeviceProp, accessPolicyMaxWindowSize) - 716usize];
    ["Offset of field: cudaDeviceProp::reservedSharedMemPerBlock"]
        [::std::mem::offset_of!(cudaDeviceProp, reservedSharedMemPerBlock) - 720usize];
};
#[doc = " CUDA IPC event handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaIpcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaIpcEventHandle_st"][::std::mem::size_of::<cudaIpcEventHandle_st>() - 64usize];
    ["Alignment of cudaIpcEventHandle_st"]
        [::std::mem::align_of::<cudaIpcEventHandle_st>() - 1usize];
    ["Offset of field: cudaIpcEventHandle_st::reserved"]
        [::std::mem::offset_of!(cudaIpcEventHandle_st, reserved) - 0usize];
};
#[doc = " CUDA IPC event handle"]
pub type cudaIpcEventHandle_t = cudaIpcEventHandle_st;
#[doc = " CUDA IPC memory handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaIpcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaIpcMemHandle_st"][::std::mem::size_of::<cudaIpcMemHandle_st>() - 64usize];
    ["Alignment of cudaIpcMemHandle_st"][::std::mem::align_of::<cudaIpcMemHandle_st>() - 1usize];
    ["Offset of field: cudaIpcMemHandle_st::reserved"]
        [::std::mem::offset_of!(cudaIpcMemHandle_st, reserved) - 0usize];
};
#[doc = " CUDA IPC memory handle"]
pub type cudaIpcMemHandle_t = cudaIpcMemHandle_st;
#[doc = " Handle is an opaque file descriptor"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeOpaqueFd:
cudaExternalMemoryHandleType = 1;
#[doc = " Handle is an opaque shared NT handle"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeOpaqueWin32:
cudaExternalMemoryHandleType = 2;
#[doc = " Handle is an opaque, globally shared handle"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeOpaqueWin32Kmt:
cudaExternalMemoryHandleType = 3;
#[doc = " Handle is a D3D12 heap object"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D12Heap:
cudaExternalMemoryHandleType = 4;
#[doc = " Handle is a D3D12 committed resource"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D12Resource:
cudaExternalMemoryHandleType = 5;
#[doc = "  Handle is a shared NT handle to a D3D11 resource"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D11Resource:
cudaExternalMemoryHandleType = 6;
#[doc = "  Handle is a globally shared handle to a D3D11 resource"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D11ResourceKmt:
cudaExternalMemoryHandleType = 7;
#[doc = "  Handle is an NvSciBuf object"]
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeNvSciBuf:
cudaExternalMemoryHandleType = 8;
#[doc = " External memory handle types"]
pub type cudaExternalMemoryHandleType = ::std::os::raw::c_int;
#[doc = " External memory handle descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc {
    #[doc = " Type of the handle"]
    pub type_: cudaExternalMemoryHandleType,
    pub handle: cudaExternalMemoryHandleDesc__bindgen_ty_1,
    #[doc = " Size of the memory allocation"]
    pub size: ::std::os::raw::c_ulonglong,
    #[doc = " Flags must either be zero or ::cudaExternalMemoryDedicated"]
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalMemoryHandleDesc__bindgen_ty_1 {
    #[doc = " File descriptor referencing the memory object. Valid\n when type is\n ::cudaExternalMemoryHandleTypeOpaqueFd"]
    pub fd: ::std::os::raw::c_int,
    pub win32: cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
    #[doc = " A handle representing NvSciBuf Object. Valid when type\n is ::cudaExternalMemoryHandleTypeNvSciBuf"]
    pub nvSciBufObject: *const ::std::os::raw::c_void,
}
#[doc = " Win32 handle referencing the semaphore object. Valid when\n type is one of the following:\n - ::cudaExternalMemoryHandleTypeOpaqueWin32\n - ::cudaExternalMemoryHandleTypeOpaqueWin32Kmt\n - ::cudaExternalMemoryHandleTypeD3D12Heap\n - ::cudaExternalMemoryHandleTypeD3D12Resource\n - ::cudaExternalMemoryHandleTypeD3D11Resource\n - ::cudaExternalMemoryHandleTypeD3D11ResourceKmt\n Exactly one of 'handle' and 'name' must be non-NULL. If\n type is one of the following:\n ::cudaExternalMemoryHandleTypeOpaqueWin32Kmt\n ::cudaExternalMemoryHandleTypeD3D11ResourceKmt\n then 'name' must be NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Valid NT handle. Must be NULL if 'name' is non-NULL"]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " Name of a valid memory object.\n Must be NULL if 'handle' is non-NULL."]
    pub name: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1"][::std::mem::size_of::<
        cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
    >() - 16usize];
    ["Alignment of cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1"][::std::mem::align_of::<
        cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
    >() - 8usize];
    ["Offset of field: cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1::handle"][::std::mem::offset_of!(
        cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
        handle
    )
        - 0usize];
    ["Offset of field: cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1::name"][::std::mem::offset_of!(
        cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
        name
    ) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalMemoryHandleDesc__bindgen_ty_1"]
        [::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>() - 16usize];
    ["Alignment of cudaExternalMemoryHandleDesc__bindgen_ty_1"]
        [::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>() - 8usize];
    ["Offset of field: cudaExternalMemoryHandleDesc__bindgen_ty_1::fd"]
        [::std::mem::offset_of!(cudaExternalMemoryHandleDesc__bindgen_ty_1, fd) - 0usize];
    ["Offset of field: cudaExternalMemoryHandleDesc__bindgen_ty_1::win32"]
        [::std::mem::offset_of!(cudaExternalMemoryHandleDesc__bindgen_ty_1, win32) - 0usize];
    ["Offset of field: cudaExternalMemoryHandleDesc__bindgen_ty_1::nvSciBufObject"][::std::mem::offset_of!(
        cudaExternalMemoryHandleDesc__bindgen_ty_1,
        nvSciBufObject
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalMemoryHandleDesc"]
        [::std::mem::size_of::<cudaExternalMemoryHandleDesc>() - 40usize];
    ["Alignment of cudaExternalMemoryHandleDesc"]
        [::std::mem::align_of::<cudaExternalMemoryHandleDesc>() - 8usize];
    ["Offset of field: cudaExternalMemoryHandleDesc::type_"]
        [::std::mem::offset_of!(cudaExternalMemoryHandleDesc, type_) - 0usize];
    ["Offset of field: cudaExternalMemoryHandleDesc::handle"]
        [::std::mem::offset_of!(cudaExternalMemoryHandleDesc, handle) - 8usize];
    ["Offset of field: cudaExternalMemoryHandleDesc::size"]
        [::std::mem::offset_of!(cudaExternalMemoryHandleDesc, size) - 24usize];
    ["Offset of field: cudaExternalMemoryHandleDesc::flags"]
        [::std::mem::offset_of!(cudaExternalMemoryHandleDesc, flags) - 32usize];
};
#[doc = " External memory buffer descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryBufferDesc {
    #[doc = " Offset into the memory object where the buffer's base is"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = " Size of the buffer"]
    pub size: ::std::os::raw::c_ulonglong,
    #[doc = " Flags reserved for future use. Must be zero."]
    pub flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalMemoryBufferDesc"]
        [::std::mem::size_of::<cudaExternalMemoryBufferDesc>() - 24usize];
    ["Alignment of cudaExternalMemoryBufferDesc"]
        [::std::mem::align_of::<cudaExternalMemoryBufferDesc>() - 8usize];
    ["Offset of field: cudaExternalMemoryBufferDesc::offset"]
        [::std::mem::offset_of!(cudaExternalMemoryBufferDesc, offset) - 0usize];
    ["Offset of field: cudaExternalMemoryBufferDesc::size"]
        [::std::mem::offset_of!(cudaExternalMemoryBufferDesc, size) - 8usize];
    ["Offset of field: cudaExternalMemoryBufferDesc::flags"]
        [::std::mem::offset_of!(cudaExternalMemoryBufferDesc, flags) - 16usize];
};
#[doc = " External memory mipmap descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryMipmappedArrayDesc {
    #[doc = " Offset into the memory object where the base level of the\n mipmap chain is."]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = " Format of base level of the mipmap chain"]
    pub formatDesc: cudaChannelFormatDesc,
    #[doc = " Dimensions of base level of the mipmap chain"]
    pub extent: cudaExtent,
    #[doc = " Flags associated with CUDA mipmapped arrays.\n See ::cudaMallocMipmappedArray"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = " Total number of levels in the mipmap chain"]
    pub numLevels: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalMemoryMipmappedArrayDesc"]
        [::std::mem::size_of::<cudaExternalMemoryMipmappedArrayDesc>() - 64usize];
    ["Alignment of cudaExternalMemoryMipmappedArrayDesc"]
        [::std::mem::align_of::<cudaExternalMemoryMipmappedArrayDesc>() - 8usize];
    ["Offset of field: cudaExternalMemoryMipmappedArrayDesc::offset"]
        [::std::mem::offset_of!(cudaExternalMemoryMipmappedArrayDesc, offset) - 0usize];
    ["Offset of field: cudaExternalMemoryMipmappedArrayDesc::formatDesc"]
        [::std::mem::offset_of!(cudaExternalMemoryMipmappedArrayDesc, formatDesc) - 8usize];
    ["Offset of field: cudaExternalMemoryMipmappedArrayDesc::extent"]
        [::std::mem::offset_of!(cudaExternalMemoryMipmappedArrayDesc, extent) - 32usize];
    ["Offset of field: cudaExternalMemoryMipmappedArrayDesc::flags"]
        [::std::mem::offset_of!(cudaExternalMemoryMipmappedArrayDesc, flags) - 56usize];
    ["Offset of field: cudaExternalMemoryMipmappedArrayDesc::numLevels"]
        [::std::mem::offset_of!(cudaExternalMemoryMipmappedArrayDesc, numLevels) - 60usize];
};
#[doc = " Handle is an opaque file descriptor"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeOpaqueFd:
cudaExternalSemaphoreHandleType = 1;
#[doc = " Handle is an opaque shared NT handle"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeOpaqueWin32:
cudaExternalSemaphoreHandleType = 2;
#[doc = " Handle is an opaque, globally shared handle"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt:
cudaExternalSemaphoreHandleType = 3;
#[doc = " Handle is a shared NT handle referencing a D3D12 fence object"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeD3D12Fence:
cudaExternalSemaphoreHandleType = 4;
#[doc = " Handle is a shared NT handle referencing a D3D11 fence object"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeD3D11Fence:
cudaExternalSemaphoreHandleType = 5;
#[doc = " Opaque handle to NvSciSync Object"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeNvSciSync:
cudaExternalSemaphoreHandleType = 6;
#[doc = " Handle is a shared NT handle referencing a D3D11 keyed mutex object"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeKeyedMutex:
cudaExternalSemaphoreHandleType = 7;
#[doc = " Handle is a shared KMT handle referencing a D3D11 keyed mutex object"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeKeyedMutexKmt:
cudaExternalSemaphoreHandleType = 8;
#[doc = " Handle is an opaque handle file descriptor referencing a timeline semaphore"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd:
cudaExternalSemaphoreHandleType = 9;
#[doc = " Handle is an opaque handle file descriptor referencing a timeline semaphore"]
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32:
cudaExternalSemaphoreHandleType = 10;
#[doc = " External semaphore handle types"]
pub type cudaExternalSemaphoreHandleType = ::std::os::raw::c_int;
#[doc = " External semaphore handle descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc {
    #[doc = " Type of the handle"]
    pub type_: cudaExternalSemaphoreHandleType,
    pub handle: cudaExternalSemaphoreHandleDesc__bindgen_ty_1,
    #[doc = " Flags reserved for the future. Must be zero."]
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreHandleDesc__bindgen_ty_1 {
    #[doc = " File descriptor referencing the semaphore object. Valid when\n type is one of the following:\n - ::cudaExternalSemaphoreHandleTypeOpaqueFd\n - ::cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd"]
    pub fd: ::std::os::raw::c_int,
    pub win32: cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
    #[doc = " Valid NvSciSyncObj. Must be non NULL"]
    pub nvSciSyncObj: *const ::std::os::raw::c_void,
}
#[doc = " Win32 handle referencing the semaphore object. Valid when\n type is one of the following:\n - ::cudaExternalSemaphoreHandleTypeOpaqueWin32\n - ::cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt\n - ::cudaExternalSemaphoreHandleTypeD3D12Fence\n - ::cudaExternalSemaphoreHandleTypeD3D11Fence\n - ::cudaExternalSemaphoreHandleTypeKeyedMutex\n - ::cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32\n Exactly one of 'handle' and 'name' must be non-NULL. If\n type is one of the following:\n ::cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt\n ::cudaExternalSemaphoreHandleTypeKeyedMutexKmt\n then 'name' must be NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Valid NT handle. Must be NULL if 'name' is non-NULL"]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " Name of a valid synchronization primitive.\n Must be NULL if 'handle' is non-NULL."]
    pub name: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1"][::std::mem::size_of::<
        cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
    >() - 16usize];
    ["Alignment of cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    ["Offset of field: cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1::handle"][::std::mem::offset_of!(
        cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
        handle
    )
        - 0usize];
    ["Offset of field: cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1::name"][::std::mem::offset_of!(
        cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
        name
    )
        - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreHandleDesc__bindgen_ty_1"]
        [::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>() - 16usize];
    ["Alignment of cudaExternalSemaphoreHandleDesc__bindgen_ty_1"]
        [::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreHandleDesc__bindgen_ty_1::fd"]
        [::std::mem::offset_of!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1, fd) - 0usize];
    ["Offset of field: cudaExternalSemaphoreHandleDesc__bindgen_ty_1::win32"]
        [::std::mem::offset_of!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1, win32) - 0usize];
    ["Offset of field: cudaExternalSemaphoreHandleDesc__bindgen_ty_1::nvSciSyncObj"][::std::mem::offset_of!(
        cudaExternalSemaphoreHandleDesc__bindgen_ty_1,
        nvSciSyncObj
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreHandleDesc"]
        [::std::mem::size_of::<cudaExternalSemaphoreHandleDesc>() - 32usize];
    ["Alignment of cudaExternalSemaphoreHandleDesc"]
        [::std::mem::align_of::<cudaExternalSemaphoreHandleDesc>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreHandleDesc::type_"]
        [::std::mem::offset_of!(cudaExternalSemaphoreHandleDesc, type_) - 0usize];
    ["Offset of field: cudaExternalSemaphoreHandleDesc::handle"]
        [::std::mem::offset_of!(cudaExternalSemaphoreHandleDesc, handle) - 8usize];
    ["Offset of field: cudaExternalSemaphoreHandleDesc::flags"]
        [::std::mem::offset_of!(cudaExternalSemaphoreHandleDesc, flags) - 24usize];
};
#[doc = " External semaphore signal parameters(deprecated)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1 {
    pub params: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
    #[doc = " Only when ::cudaExternalSemaphoreSignalParams is used to\n signal a ::cudaExternalSemaphore_t of type\n ::cudaExternalSemaphoreHandleTypeNvSciSync, the valid flag is\n ::cudaExternalSemaphoreSignalSkipNvSciBufMemSync: which indicates\n that while signaling the ::cudaExternalSemaphore_t, no memory\n synchronization operations should be performed for any external memory\n object imported as ::cudaExternalMemoryHandleTypeNvSciBuf.\n For all other types of ::cudaExternalSemaphore_t, flags must be zero."]
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3,
}
#[doc = " Parameters for fence objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be signaled"]
    pub value: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1"][::std::mem::size_of::<
        cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1,
    >() - 8usize];
    ["Alignment of cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1::value"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1,
        value
    )
        - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Pointer to NvSciSyncFence. Valid if ::cudaExternalSemaphoreHandleType\n is of type ::cudaExternalSemaphoreHandleTypeNvSciSync."]
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2"][::std::mem::size_of::<
        cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2,
    >() - 8usize];
    ["Alignment of cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2::fence"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2,
        fence
    )
        - 0usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2::reserved"][::std::mem::offset_of!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2 , reserved) - 0usize];
};
#[doc = " Parameters for keyed mutex objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3"][::std::mem::size_of::<
        cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3,
    >() - 8usize];
    ["Alignment of cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3::key"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3,
        key
    )
        - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1"]
        [::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1>() - 24usize];
    ["Alignment of cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1"]
        [::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1::fence"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
        fence
    ) - 0usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1::nvSciSync"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
        nvSciSync
    ) - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1::keyedMutex"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
        keyedMutex
    )
        - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreSignalParams_v1"]
        [::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1>() - 32usize];
    ["Alignment of cudaExternalSemaphoreSignalParams_v1"]
        [::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams_v1::params"]
        [::std::mem::offset_of!(cudaExternalSemaphoreSignalParams_v1, params) - 0usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams_v1::flags"]
        [::std::mem::offset_of!(cudaExternalSemaphoreSignalParams_v1, flags) - 24usize];
};
#[doc = " External semaphore wait parameters(deprecated)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1 {
    pub params: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
    #[doc = " Only when ::cudaExternalSemaphoreSignalParams is used to\n signal a ::cudaExternalSemaphore_t of type\n ::cudaExternalSemaphoreHandleTypeNvSciSync, the valid flag is\n ::cudaExternalSemaphoreSignalSkipNvSciBufMemSync: which indicates\n that while waiting for the ::cudaExternalSemaphore_t, no memory\n synchronization operations should be performed for any external memory\n object imported as ::cudaExternalMemoryHandleTypeNvSciBuf.\n For all other types of ::cudaExternalSemaphore_t, flags must be zero."]
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3,
}
#[doc = " Parameters for fence objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be waited on"]
    pub value: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1"][::std::mem::size_of::<
        cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1,
    >() - 8usize];
    ["Alignment of cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1::value"][::std::mem::offset_of!(
        cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1,
        value
    )
        - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Pointer to NvSciSyncFence. Valid if ::cudaExternalSemaphoreHandleType\n is of type ::cudaExternalSemaphoreHandleTypeNvSciSync."]
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2"][::std::mem::size_of::<
        cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
    >() - 8usize];
    ["Alignment of cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2>()
        - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2::fence"][::std::mem::offset_of!(
        cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
        fence
    )
        - 0usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2::reserved"][::std::mem::offset_of!(
        cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
        reserved
    )
        - 0usize];
};
#[doc = " Parameters for keyed mutex objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Value of key to acquire the mutex with"]
    pub key: ::std::os::raw::c_ulonglong,
    #[doc = " Timeout in milliseconds to wait to acquire the mutex"]
    pub timeoutMs: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3"][::std::mem::size_of::<
        cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3,
    >() - 16usize];
    ["Alignment of cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3>()
        - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3::key"][::std::mem::offset_of!(
        cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3,
        key
    )
        - 0usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3::timeoutMs"][::std::mem::offset_of!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3 , timeoutMs) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1"]
        [::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1>() - 32usize];
    ["Alignment of cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1"]
        [::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1::fence"]
        [::std::mem::offset_of!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1, fence) - 0usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1::nvSciSync"][::std::mem::offset_of!(
        cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
        nvSciSync
    ) - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1::keyedMutex"][::std::mem::offset_of!(
        cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
        keyedMutex
    ) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreWaitParams_v1"]
        [::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1>() - 40usize];
    ["Alignment of cudaExternalSemaphoreWaitParams_v1"]
        [::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams_v1::params"]
        [::std::mem::offset_of!(cudaExternalSemaphoreWaitParams_v1, params) - 0usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams_v1::flags"]
        [::std::mem::offset_of!(cudaExternalSemaphoreWaitParams_v1, flags) - 32usize];
};
#[doc = " External semaphore signal parameters, compatible with driver type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams {
    pub params: cudaExternalSemaphoreSignalParams__bindgen_ty_1,
    #[doc = " Only when ::cudaExternalSemaphoreSignalParams is used to\n signal a ::cudaExternalSemaphore_t of type\n ::cudaExternalSemaphoreHandleTypeNvSciSync, the valid flag is\n ::cudaExternalSemaphoreSignalSkipNvSciBufMemSync: which indicates\n that while signaling the ::cudaExternalSemaphore_t, no memory\n synchronization operations should be performed for any external memory\n object imported as ::cudaExternalMemoryHandleTypeNvSciBuf.\n For all other types of ::cudaExternalSemaphore_t, flags must be zero."]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 12usize],
}
#[doc = " Parameters for fence objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be signaled"]
    pub value: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1"][::std::mem::size_of::<
        cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
    >() - 8usize];
    ["Alignment of cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1::value"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
        value
    )
        - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Pointer to NvSciSyncFence. Valid if ::cudaExternalSemaphoreHandleType\n is of type ::cudaExternalSemaphoreHandleTypeNvSciSync."]
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2"][::std::mem::size_of::<
        cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
    >() - 8usize];
    ["Alignment of cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>()
        - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2::fence"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
        fence
    )
        - 0usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2::reserved"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
        reserved
    )
        - 0usize];
};
#[doc = " Parameters for keyed mutex objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3"][::std::mem::size_of::<
        cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
    >() - 8usize];
    ["Alignment of cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3>()
        - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3::key"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
        key
    )
        - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreSignalParams__bindgen_ty_1"]
        [::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>() - 72usize];
    ["Alignment of cudaExternalSemaphoreSignalParams__bindgen_ty_1"]
        [::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams__bindgen_ty_1::fence"]
        [::std::mem::offset_of!(cudaExternalSemaphoreSignalParams__bindgen_ty_1, fence) - 0usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams__bindgen_ty_1::nvSciSync"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams__bindgen_ty_1,
        nvSciSync
    ) - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams__bindgen_ty_1::keyedMutex"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams__bindgen_ty_1,
        keyedMutex
    ) - 16usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams__bindgen_ty_1::reserved"][::std::mem::offset_of!(
        cudaExternalSemaphoreSignalParams__bindgen_ty_1,
        reserved
    ) - 24usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreSignalParams"]
        [::std::mem::size_of::<cudaExternalSemaphoreSignalParams>() - 144usize];
    ["Alignment of cudaExternalSemaphoreSignalParams"]
        [::std::mem::align_of::<cudaExternalSemaphoreSignalParams>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams::params"]
        [::std::mem::offset_of!(cudaExternalSemaphoreSignalParams, params) - 0usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams::flags"]
        [::std::mem::offset_of!(cudaExternalSemaphoreSignalParams, flags) - 72usize];
    ["Offset of field: cudaExternalSemaphoreSignalParams::reserved"]
        [::std::mem::offset_of!(cudaExternalSemaphoreSignalParams, reserved) - 76usize];
};
#[doc = " External semaphore wait parameters, compatible with driver type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams {
    pub params: cudaExternalSemaphoreWaitParams__bindgen_ty_1,
    #[doc = " Only when ::cudaExternalSemaphoreSignalParams is used to\n signal a ::cudaExternalSemaphore_t of type\n ::cudaExternalSemaphoreHandleTypeNvSciSync, the valid flag is\n ::cudaExternalSemaphoreSignalSkipNvSciBufMemSync: which indicates\n that while waiting for the ::cudaExternalSemaphore_t, no memory\n synchronization operations should be performed for any external memory\n object imported as ::cudaExternalMemoryHandleTypeNvSciBuf.\n For all other types of ::cudaExternalSemaphore_t, flags must be zero."]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 10usize],
}
#[doc = " Parameters for fence objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be waited on"]
    pub value: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1"][::std::mem::size_of::<
        cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
    >() - 8usize];
    ["Alignment of cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1::value"][::std::mem::offset_of!(
        cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
        value
    )
        - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Pointer to NvSciSyncFence. Valid if ::cudaExternalSemaphoreHandleType\n is of type ::cudaExternalSemaphoreHandleTypeNvSciSync."]
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2"][::std::mem::size_of::<
        cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
    >() - 8usize];
    ["Alignment of cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>()
        - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2::fence"][::std::mem::offset_of!(
        cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
        fence
    )
        - 0usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2::reserved"][::std::mem::offset_of!(
        cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
        reserved
    )
        - 0usize];
};
#[doc = " Parameters for keyed mutex objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Value of key to acquire the mutex with"]
    pub key: ::std::os::raw::c_ulonglong,
    #[doc = " Timeout in milliseconds to wait to acquire the mutex"]
    pub timeoutMs: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3"][::std::mem::size_of::<
        cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
    >() - 16usize];
    ["Alignment of cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>()
        - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3::key"][::std::mem::offset_of!(
        cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
        key
    )
        - 0usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3::timeoutMs"][::std::mem::offset_of!(
        cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
        timeoutMs
    )
        - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreWaitParams__bindgen_ty_1"]
        [::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>() - 72usize];
    ["Alignment of cudaExternalSemaphoreWaitParams__bindgen_ty_1"]
        [::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams__bindgen_ty_1::fence"]
        [::std::mem::offset_of!(cudaExternalSemaphoreWaitParams__bindgen_ty_1, fence) - 0usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams__bindgen_ty_1::nvSciSync"]
        [::std::mem::offset_of!(cudaExternalSemaphoreWaitParams__bindgen_ty_1, nvSciSync) - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams__bindgen_ty_1::keyedMutex"][::std::mem::offset_of!(
        cudaExternalSemaphoreWaitParams__bindgen_ty_1,
        keyedMutex
    ) - 16usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams__bindgen_ty_1::reserved"]
        [::std::mem::offset_of!(cudaExternalSemaphoreWaitParams__bindgen_ty_1, reserved) - 32usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreWaitParams"]
        [::std::mem::size_of::<cudaExternalSemaphoreWaitParams>() - 144usize];
    ["Alignment of cudaExternalSemaphoreWaitParams"]
        [::std::mem::align_of::<cudaExternalSemaphoreWaitParams>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams::params"]
        [::std::mem::offset_of!(cudaExternalSemaphoreWaitParams, params) - 0usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams::flags"]
        [::std::mem::offset_of!(cudaExternalSemaphoreWaitParams, flags) - 72usize];
    ["Offset of field: cudaExternalSemaphoreWaitParams::reserved"]
        [::std::mem::offset_of!(cudaExternalSemaphoreWaitParams, reserved) - 76usize];
};
#[doc = " CUDA Error types"]
pub use self::cudaError as cudaError_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
#[doc = " CUDA stream"]
pub type cudaStream_t = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
#[doc = " CUDA event types"]
pub type cudaEvent_t = *mut CUevent_st;
#[doc = " CUDA graphics resource types"]
pub type cudaGraphicsResource_t = *mut cudaGraphicsResource;
#[doc = " CUDA output file modes"]
pub use self::cudaOutputMode as cudaOutputMode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexternalMemory_st {
    _unused: [u8; 0],
}
#[doc = " CUDA external memory"]
pub type cudaExternalMemory_t = *mut CUexternalMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexternalSemaphore_st {
    _unused: [u8; 0],
}
#[doc = " CUDA external semaphore"]
pub type cudaExternalSemaphore_t = *mut CUexternalSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
#[doc = " CUDA graph"]
pub type cudaGraph_t = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
#[doc = " CUDA graph node."]
pub type cudaGraphNode_t = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuserObject_st {
    _unused: [u8; 0],
}
#[doc = " CUDA user object for graphs"]
pub type cudaUserObject_t = *mut CUuserObject_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
#[doc = " CUDA function"]
pub type cudaFunction_t = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolHandle_st {
    _unused: [u8; 0],
}
#[doc = " CUDA memory pool"]
pub type cudaMemPool_t = *mut CUmemPoolHandle_st;
#[doc = "< Invalid cooperative group scope"]
pub const cudaCGScope_cudaCGScopeInvalid: cudaCGScope = 0;
#[doc = "< Scope represented by a grid_group"]
pub const cudaCGScope_cudaCGScopeGrid: cudaCGScope = 1;
#[doc = "< Scope represented by a multi_grid_group"]
pub const cudaCGScope_cudaCGScopeMultiGrid: cudaCGScope = 2;
#[doc = " CUDA cooperative group scope"]
pub type cudaCGScope = ::std::os::raw::c_int;
#[doc = " CUDA launch parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchParams {
    #[doc = "< Device function symbol"]
    pub func: *mut ::std::os::raw::c_void,
    #[doc = "< Grid dimentions"]
    pub gridDim: dim3,
    #[doc = "< Block dimentions"]
    pub blockDim: dim3,
    #[doc = "< Arguments"]
    pub args: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Shared memory"]
    pub sharedMem: usize,
    #[doc = "< Stream identifier"]
    pub stream: cudaStream_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaLaunchParams"][::std::mem::size_of::<cudaLaunchParams>() - 56usize];
    ["Alignment of cudaLaunchParams"][::std::mem::align_of::<cudaLaunchParams>() - 8usize];
    ["Offset of field: cudaLaunchParams::func"]
        [::std::mem::offset_of!(cudaLaunchParams, func) - 0usize];
    ["Offset of field: cudaLaunchParams::gridDim"]
        [::std::mem::offset_of!(cudaLaunchParams, gridDim) - 8usize];
    ["Offset of field: cudaLaunchParams::blockDim"]
        [::std::mem::offset_of!(cudaLaunchParams, blockDim) - 20usize];
    ["Offset of field: cudaLaunchParams::args"]
        [::std::mem::offset_of!(cudaLaunchParams, args) - 32usize];
    ["Offset of field: cudaLaunchParams::sharedMem"]
        [::std::mem::offset_of!(cudaLaunchParams, sharedMem) - 40usize];
    ["Offset of field: cudaLaunchParams::stream"]
        [::std::mem::offset_of!(cudaLaunchParams, stream) - 48usize];
};
#[doc = " CUDA GPU kernel node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaKernelNodeParams {
    #[doc = "< Kernel to launch"]
    pub func: *mut ::std::os::raw::c_void,
    #[doc = "< Grid dimensions"]
    pub gridDim: dim3,
    #[doc = "< Block dimensions"]
    pub blockDim: dim3,
    #[doc = "< Dynamic shared-memory size per thread block in bytes"]
    pub sharedMemBytes: ::std::os::raw::c_uint,
    #[doc = "< Array of pointers to individual kernel arguments"]
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to kernel arguments in the \"extra\" format"]
    pub extra: *mut *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaKernelNodeParams"][::std::mem::size_of::<cudaKernelNodeParams>() - 56usize];
    ["Alignment of cudaKernelNodeParams"][::std::mem::align_of::<cudaKernelNodeParams>() - 8usize];
    ["Offset of field: cudaKernelNodeParams::func"]
        [::std::mem::offset_of!(cudaKernelNodeParams, func) - 0usize];
    ["Offset of field: cudaKernelNodeParams::gridDim"]
        [::std::mem::offset_of!(cudaKernelNodeParams, gridDim) - 8usize];
    ["Offset of field: cudaKernelNodeParams::blockDim"]
        [::std::mem::offset_of!(cudaKernelNodeParams, blockDim) - 20usize];
    ["Offset of field: cudaKernelNodeParams::sharedMemBytes"]
        [::std::mem::offset_of!(cudaKernelNodeParams, sharedMemBytes) - 32usize];
    ["Offset of field: cudaKernelNodeParams::kernelParams"]
        [::std::mem::offset_of!(cudaKernelNodeParams, kernelParams) - 40usize];
    ["Offset of field: cudaKernelNodeParams::extra"]
        [::std::mem::offset_of!(cudaKernelNodeParams, extra) - 48usize];
};
#[doc = " External semaphore signal node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalNodeParams {
    #[doc = "< Array of external semaphore handles."]
    pub extSemArray: *mut cudaExternalSemaphore_t,
    #[doc = "< Array of external semaphore signal parameters."]
    pub paramsArray: *const cudaExternalSemaphoreSignalParams,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray."]
    pub numExtSems: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreSignalNodeParams"]
        [::std::mem::size_of::<cudaExternalSemaphoreSignalNodeParams>() - 24usize];
    ["Alignment of cudaExternalSemaphoreSignalNodeParams"]
        [::std::mem::align_of::<cudaExternalSemaphoreSignalNodeParams>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalNodeParams::extSemArray"]
        [::std::mem::offset_of!(cudaExternalSemaphoreSignalNodeParams, extSemArray) - 0usize];
    ["Offset of field: cudaExternalSemaphoreSignalNodeParams::paramsArray"]
        [::std::mem::offset_of!(cudaExternalSemaphoreSignalNodeParams, paramsArray) - 8usize];
    ["Offset of field: cudaExternalSemaphoreSignalNodeParams::numExtSems"]
        [::std::mem::offset_of!(cudaExternalSemaphoreSignalNodeParams, numExtSems) - 16usize];
};
#[doc = " External semaphore wait node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitNodeParams {
    #[doc = "< Array of external semaphore handles."]
    pub extSemArray: *mut cudaExternalSemaphore_t,
    #[doc = "< Array of external semaphore wait parameters."]
    pub paramsArray: *const cudaExternalSemaphoreWaitParams,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray."]
    pub numExtSems: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaExternalSemaphoreWaitNodeParams"]
        [::std::mem::size_of::<cudaExternalSemaphoreWaitNodeParams>() - 24usize];
    ["Alignment of cudaExternalSemaphoreWaitNodeParams"]
        [::std::mem::align_of::<cudaExternalSemaphoreWaitNodeParams>() - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitNodeParams::extSemArray"]
        [::std::mem::offset_of!(cudaExternalSemaphoreWaitNodeParams, extSemArray) - 0usize];
    ["Offset of field: cudaExternalSemaphoreWaitNodeParams::paramsArray"]
        [::std::mem::offset_of!(cudaExternalSemaphoreWaitNodeParams, paramsArray) - 8usize];
    ["Offset of field: cudaExternalSemaphoreWaitNodeParams::numExtSems"]
        [::std::mem::offset_of!(cudaExternalSemaphoreWaitNodeParams, numExtSems) - 16usize];
};
#[doc = "< GPU kernel node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeKernel: cudaGraphNodeType = 0;
#[doc = "< Memcpy node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeMemcpy: cudaGraphNodeType = 1;
#[doc = "< Memset node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeMemset: cudaGraphNodeType = 2;
#[doc = "< Host (executable) node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeHost: cudaGraphNodeType = 3;
#[doc = "< Node which executes an embedded graph"]
pub const cudaGraphNodeType_cudaGraphNodeTypeGraph: cudaGraphNodeType = 4;
#[doc = "< Empty (no-op) node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeEmpty: cudaGraphNodeType = 5;
#[doc = "< External event wait node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeWaitEvent: cudaGraphNodeType = 6;
#[doc = "< External event record node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeEventRecord: cudaGraphNodeType = 7;
#[doc = "< External semaphore signal node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeExtSemaphoreSignal: cudaGraphNodeType = 8;
#[doc = "< External semaphore wait node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeExtSemaphoreWait: cudaGraphNodeType = 9;
#[doc = "< Memory allocation node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeMemAlloc: cudaGraphNodeType = 10;
#[doc = "< Memory free node"]
pub const cudaGraphNodeType_cudaGraphNodeTypeMemFree: cudaGraphNodeType = 11;
pub const cudaGraphNodeType_cudaGraphNodeTypeCount: cudaGraphNodeType = 12;
#[doc = " CUDA Graph node types"]
pub type cudaGraphNodeType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
#[doc = " CUDA executable (launchable) graph"]
pub type cudaGraphExec_t = *mut CUgraphExec_st;
#[doc = "< The update succeeded"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateSuccess: cudaGraphExecUpdateResult = 0;
#[doc = "< The update failed for an unexpected reason which is described in the return value of the function"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateError: cudaGraphExecUpdateResult = 1;
#[doc = "< The update failed because the topology changed"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorTopologyChanged:
cudaGraphExecUpdateResult = 2;
#[doc = "< The update failed because a node type changed"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorNodeTypeChanged:
cudaGraphExecUpdateResult = 3;
#[doc = "< The update failed because the function of a kernel node changed (CUDA driver < 11.2)"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorFunctionChanged:
cudaGraphExecUpdateResult = 4;
#[doc = "< The update failed because the parameters changed in a way that is not supported"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorParametersChanged:
cudaGraphExecUpdateResult = 5;
#[doc = "< The update failed because something about the node is not supported"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorNotSupported:
cudaGraphExecUpdateResult = 6;
#[doc = "< The update failed because the function of a kernel node changed in an unsupported way"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorUnsupportedFunctionChange:
cudaGraphExecUpdateResult = 7;
#[doc = "< The update failed because the node attributes changed in a way that is not supported"]
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorAttributesChanged:
cudaGraphExecUpdateResult = 8;
#[doc = " CUDA Graph Update error types"]
pub type cudaGraphExecUpdateResult = ::std::os::raw::c_int;
#[doc = "< Default search mode for driver symbols."]
pub const cudaGetDriverEntryPointFlags_cudaEnableDefault: cudaGetDriverEntryPointFlags = 0;
#[doc = "< Search for legacy versions of driver symbols."]
pub const cudaGetDriverEntryPointFlags_cudaEnableLegacyStream: cudaGetDriverEntryPointFlags = 1;
#[doc = "< Search for per-thread versions of driver symbols."]
pub const cudaGetDriverEntryPointFlags_cudaEnablePerThreadDefaultStream:
cudaGetDriverEntryPointFlags = 2;
#[doc = " Flags to specify search options to be used with ::cudaGetDriverEntryPoint\n For more details see ::cuGetProcAddress"]
pub type cudaGetDriverEntryPointFlags = ::std::os::raw::c_int;
#[doc = "< Output all debug data as if every debug flag is enabled"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsVerbose: cudaGraphDebugDotFlags = 1;
#[doc = "< Adds cudaKernelNodeParams to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsKernelNodeParams: cudaGraphDebugDotFlags = 4;
#[doc = "< Adds cudaMemcpy3DParms to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsMemcpyNodeParams: cudaGraphDebugDotFlags = 8;
#[doc = "< Adds cudaMemsetParams to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsMemsetNodeParams: cudaGraphDebugDotFlags =
    16;
#[doc = "< Adds cudaHostNodeParams to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsHostNodeParams: cudaGraphDebugDotFlags = 32;
#[doc = "< Adds cudaEvent_t handle from record and wait nodes to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsEventNodeParams: cudaGraphDebugDotFlags = 64;
#[doc = "< Adds cudaExternalSemaphoreSignalNodeParams values to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsExtSemasSignalNodeParams:
cudaGraphDebugDotFlags = 128;
#[doc = "< Adds cudaExternalSemaphoreWaitNodeParams to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsExtSemasWaitNodeParams:
cudaGraphDebugDotFlags = 256;
#[doc = "< Adds cudaKernelNodeAttrID values to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsKernelNodeAttributes:
cudaGraphDebugDotFlags = 512;
#[doc = "< Adds node handles and every kernel function handle to output"]
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsHandles: cudaGraphDebugDotFlags = 1024;
#[doc = " CUDA Graph debug write options"]
pub type cudaGraphDebugDotFlags = ::std::os::raw::c_int;
#[doc = "< Automatically free memory allocated in a graph before relaunching."]
pub const cudaGraphInstantiateFlags_cudaGraphInstantiateFlagAutoFreeOnLaunch:
cudaGraphInstantiateFlags = 1;
#[doc = "< Run the graph using the per-node priority attributes rather than the\npriority of the stream it is launched into."]
pub const cudaGraphInstantiateFlags_cudaGraphInstantiateFlagUseNodePriority:
cudaGraphInstantiateFlags = 8;
#[doc = " Flags for instantiating a graph"]
pub type cudaGraphInstantiateFlags = ::std::os::raw::c_int;
#[doc = "< Ignored entry, for convenient composition"]
pub const cudaLaunchAttributeID_cudaLaunchAttributeIgnore: cudaLaunchAttributeID = 0;
#[doc = "< Valid for streams, graph nodes, launches."]
pub const cudaLaunchAttributeID_cudaLaunchAttributeAccessPolicyWindow: cudaLaunchAttributeID = 1;
#[doc = "< Valid for graph nodes, launches."]
pub const cudaLaunchAttributeID_cudaLaunchAttributeCooperative: cudaLaunchAttributeID = 2;
#[doc = "< Valid for streams."]
pub const cudaLaunchAttributeID_cudaLaunchAttributeSynchronizationPolicy: cudaLaunchAttributeID = 3;
#[doc = "< Valid for graph nodes, launches."]
pub const cudaLaunchAttributeID_cudaLaunchAttributeClusterDimension: cudaLaunchAttributeID = 4;
#[doc = "< Valid for graph nodes, launches."]
pub const cudaLaunchAttributeID_cudaLaunchAttributeClusterSchedulingPolicyPreference:
cudaLaunchAttributeID = 5;
#[doc = "< Valid for launches. Setting\nprogrammaticStreamSerializationAllowed to non-0\nsignals that the kernel will use programmatic\nmeans to resolve its stream dependency, so that\nthe CUDA runtime should opportunistically allow\nthe grid's execution to overlap with the previous\nkernel in the stream, if that kernel requests the\noverlap."]
pub const cudaLaunchAttributeID_cudaLaunchAttributeProgrammaticStreamSerialization:
cudaLaunchAttributeID = 6;
#[doc = "< Valid for launches. Event recorded through this launch\nattribute is guaranteed to only trigger after all\nblock in the associated kernel trigger the event. A\nblock can trigger the event through PTX\ngriddepcontrol.launch_dependents. A trigger can also\nbe inserted at the beginning of each block's execution\nif triggerAtBlockStart is set to non-0. Note that\ndependents (including the CPU thread calling\ncudaEventSynchronize()) are not guaranteed to observe\nthe release precisely when it is released. For\nexample, cudaEventSynchronize() may only observe the\nevent trigger long after the associated kernel has\ncompleted. This recording type is primarily meant for\nestablishing programmatic dependency between device\ntasks. The event supplied must not be an interprocess\nor interop event. The event must disable timing\n(i.e. created with ::cudaEventDisableTiming flag\nset)."]
pub const cudaLaunchAttributeID_cudaLaunchAttributeProgrammaticEvent: cudaLaunchAttributeID = 7;
#[doc = "< Valid for graph nodes."]
pub const cudaLaunchAttributeID_cudaLaunchAttributePriority: cudaLaunchAttributeID = 8;
#[doc = " Launch attributes enum; used as id field of ::cudaLaunchAttribute"]
pub type cudaLaunchAttributeID = ::std::os::raw::c_int;
#[doc = " Launch attributes union; used as value field of ::cudaLaunchAttribute"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaLaunchAttributeValue {
    pub pad: [::std::os::raw::c_char; 64usize],
    pub accessPolicyWindow: cudaAccessPolicyWindow,
    pub cooperative: ::std::os::raw::c_int,
    pub syncPolicy: cudaSynchronizationPolicy,
    pub clusterDim: cudaLaunchAttributeValue__bindgen_ty_1,
    pub clusterSchedulingPolicyPreference: cudaClusterSchedulingPolicy,
    pub programmaticStreamSerializationAllowed: ::std::os::raw::c_int,
    pub programmaticEvent: cudaLaunchAttributeValue__bindgen_ty_2,
    pub priority: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchAttributeValue__bindgen_ty_1 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaLaunchAttributeValue__bindgen_ty_1"]
        [::std::mem::size_of::<cudaLaunchAttributeValue__bindgen_ty_1>() - 12usize];
    ["Alignment of cudaLaunchAttributeValue__bindgen_ty_1"]
        [::std::mem::align_of::<cudaLaunchAttributeValue__bindgen_ty_1>() - 4usize];
    ["Offset of field: cudaLaunchAttributeValue__bindgen_ty_1::x"]
        [::std::mem::offset_of!(cudaLaunchAttributeValue__bindgen_ty_1, x) - 0usize];
    ["Offset of field: cudaLaunchAttributeValue__bindgen_ty_1::y"]
        [::std::mem::offset_of!(cudaLaunchAttributeValue__bindgen_ty_1, y) - 4usize];
    ["Offset of field: cudaLaunchAttributeValue__bindgen_ty_1::z"]
        [::std::mem::offset_of!(cudaLaunchAttributeValue__bindgen_ty_1, z) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchAttributeValue__bindgen_ty_2 {
    pub event: cudaEvent_t,
    pub flags: ::std::os::raw::c_int,
    pub triggerAtBlockStart: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaLaunchAttributeValue__bindgen_ty_2"]
        [::std::mem::size_of::<cudaLaunchAttributeValue__bindgen_ty_2>() - 16usize];
    ["Alignment of cudaLaunchAttributeValue__bindgen_ty_2"]
        [::std::mem::align_of::<cudaLaunchAttributeValue__bindgen_ty_2>() - 8usize];
    ["Offset of field: cudaLaunchAttributeValue__bindgen_ty_2::event"]
        [::std::mem::offset_of!(cudaLaunchAttributeValue__bindgen_ty_2, event) - 0usize];
    ["Offset of field: cudaLaunchAttributeValue__bindgen_ty_2::flags"]
        [::std::mem::offset_of!(cudaLaunchAttributeValue__bindgen_ty_2, flags) - 8usize];
    ["Offset of field: cudaLaunchAttributeValue__bindgen_ty_2::triggerAtBlockStart"][::std::mem::offset_of!(
        cudaLaunchAttributeValue__bindgen_ty_2,
        triggerAtBlockStart
    ) - 12usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaLaunchAttributeValue"]
        [::std::mem::size_of::<cudaLaunchAttributeValue>() - 64usize];
    ["Alignment of cudaLaunchAttributeValue"]
        [::std::mem::align_of::<cudaLaunchAttributeValue>() - 8usize];
    ["Offset of field: cudaLaunchAttributeValue::pad"]
        [::std::mem::offset_of!(cudaLaunchAttributeValue, pad) - 0usize];
    ["Offset of field: cudaLaunchAttributeValue::accessPolicyWindow"]
        [::std::mem::offset_of!(cudaLaunchAttributeValue, accessPolicyWindow) - 0usize];
    ["Offset of field: cudaLaunchAttributeValue::cooperative"]
        [::std::mem::offset_of!(cudaLaunchAttributeValue, cooperative) - 0usize];
    ["Offset of field: cudaLaunchAttributeValue::syncPolicy"]
        [::std::mem::offset_of!(cudaLaunchAttributeValue, syncPolicy) - 0usize];
    ["Offset of field: cudaLaunchAttributeValue::clusterDim"]
        [::std::mem::offset_of!(cudaLaunchAttributeValue, clusterDim) - 0usize];
    ["Offset of field: cudaLaunchAttributeValue::clusterSchedulingPolicyPreference"][::std::mem::offset_of!(
        cudaLaunchAttributeValue,
        clusterSchedulingPolicyPreference
    ) - 0usize];
    ["Offset of field: cudaLaunchAttributeValue::programmaticStreamSerializationAllowed"][::std::mem::offset_of!(
        cudaLaunchAttributeValue,
        programmaticStreamSerializationAllowed
    )
        - 0usize];
    ["Offset of field: cudaLaunchAttributeValue::programmaticEvent"]
        [::std::mem::offset_of!(cudaLaunchAttributeValue, programmaticEvent) - 0usize];
    ["Offset of field: cudaLaunchAttributeValue::priority"]
        [::std::mem::offset_of!(cudaLaunchAttributeValue, priority) - 0usize];
};
#[doc = " Launch attribute"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaLaunchAttribute_st {
    pub id: cudaLaunchAttributeID,
    pub pad: [::std::os::raw::c_char; 4usize],
    pub val: cudaLaunchAttributeValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaLaunchAttribute_st"][::std::mem::size_of::<cudaLaunchAttribute_st>() - 72usize];
    ["Alignment of cudaLaunchAttribute_st"]
        [::std::mem::align_of::<cudaLaunchAttribute_st>() - 8usize];
    ["Offset of field: cudaLaunchAttribute_st::id"]
        [::std::mem::offset_of!(cudaLaunchAttribute_st, id) - 0usize];
    ["Offset of field: cudaLaunchAttribute_st::pad"]
        [::std::mem::offset_of!(cudaLaunchAttribute_st, pad) - 4usize];
    ["Offset of field: cudaLaunchAttribute_st::val"]
        [::std::mem::offset_of!(cudaLaunchAttribute_st, val) - 8usize];
};
#[doc = " Launch attribute"]
pub type cudaLaunchAttribute = cudaLaunchAttribute_st;
#[doc = " CUDA extensible launch configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchConfig_st {
    #[doc = "< Grid dimentions"]
    pub gridDim: dim3,
    #[doc = "< Block dimentions"]
    pub blockDim: dim3,
    #[doc = "< Dynamic shared-memory size per thread block in bytes"]
    pub dynamicSmemBytes: usize,
    #[doc = "< Stream identifier"]
    pub stream: cudaStream_t,
    #[doc = "< nullable if numAttrs == 0"]
    pub attrs: *mut cudaLaunchAttribute,
    #[doc = "< Number of attributes populated in attrs"]
    pub numAttrs: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaLaunchConfig_st"][::std::mem::size_of::<cudaLaunchConfig_st>() - 56usize];
    ["Alignment of cudaLaunchConfig_st"][::std::mem::align_of::<cudaLaunchConfig_st>() - 8usize];
    ["Offset of field: cudaLaunchConfig_st::gridDim"]
        [::std::mem::offset_of!(cudaLaunchConfig_st, gridDim) - 0usize];
    ["Offset of field: cudaLaunchConfig_st::blockDim"]
        [::std::mem::offset_of!(cudaLaunchConfig_st, blockDim) - 12usize];
    ["Offset of field: cudaLaunchConfig_st::dynamicSmemBytes"]
        [::std::mem::offset_of!(cudaLaunchConfig_st, dynamicSmemBytes) - 24usize];
    ["Offset of field: cudaLaunchConfig_st::stream"]
        [::std::mem::offset_of!(cudaLaunchConfig_st, stream) - 32usize];
    ["Offset of field: cudaLaunchConfig_st::attrs"]
        [::std::mem::offset_of!(cudaLaunchConfig_st, attrs) - 40usize];
    ["Offset of field: cudaLaunchConfig_st::numAttrs"]
        [::std::mem::offset_of!(cudaLaunchConfig_st, numAttrs) - 48usize];
};
#[doc = " CUDA extensible launch configuration"]
pub type cudaLaunchConfig_t = cudaLaunchConfig_st;
#[doc = "< Zero boundary mode"]
pub const cudaSurfaceBoundaryMode_cudaBoundaryModeZero: cudaSurfaceBoundaryMode = 0;
#[doc = "< Clamp boundary mode"]
pub const cudaSurfaceBoundaryMode_cudaBoundaryModeClamp: cudaSurfaceBoundaryMode = 1;
#[doc = "< Trap boundary mode"]
pub const cudaSurfaceBoundaryMode_cudaBoundaryModeTrap: cudaSurfaceBoundaryMode = 2;
#[doc = " CUDA Surface boundary modes"]
pub type cudaSurfaceBoundaryMode = ::std::os::raw::c_int;
#[doc = "< Forced format mode"]
pub const cudaSurfaceFormatMode_cudaFormatModeForced: cudaSurfaceFormatMode = 0;
#[doc = "< Auto format mode"]
pub const cudaSurfaceFormatMode_cudaFormatModeAuto: cudaSurfaceFormatMode = 1;
#[doc = " CUDA Surface format modes"]
pub type cudaSurfaceFormatMode = ::std::os::raw::c_int;
#[doc = " CUDA Surface reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct surfaceReference {
    #[doc = " Channel descriptor for surface reference"]
    pub channelDesc: cudaChannelFormatDesc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of surfaceReference"][::std::mem::size_of::<surfaceReference>() - 20usize];
    ["Alignment of surfaceReference"][::std::mem::align_of::<surfaceReference>() - 4usize];
    ["Offset of field: surfaceReference::channelDesc"]
        [::std::mem::offset_of!(surfaceReference, channelDesc) - 0usize];
};
#[doc = " An opaque value that represents a CUDA Surface object"]
pub type cudaSurfaceObject_t = ::std::os::raw::c_ulonglong;
#[doc = "< Wrapping address mode"]
pub const cudaTextureAddressMode_cudaAddressModeWrap: cudaTextureAddressMode = 0;
#[doc = "< Clamp to edge address mode"]
pub const cudaTextureAddressMode_cudaAddressModeClamp: cudaTextureAddressMode = 1;
#[doc = "< Mirror address mode"]
pub const cudaTextureAddressMode_cudaAddressModeMirror: cudaTextureAddressMode = 2;
#[doc = "< Border address mode"]
pub const cudaTextureAddressMode_cudaAddressModeBorder: cudaTextureAddressMode = 3;
#[doc = " CUDA texture address modes"]
pub type cudaTextureAddressMode = ::std::os::raw::c_int;
#[doc = "< Point filter mode"]
pub const cudaTextureFilterMode_cudaFilterModePoint: cudaTextureFilterMode = 0;
#[doc = "< Linear filter mode"]
pub const cudaTextureFilterMode_cudaFilterModeLinear: cudaTextureFilterMode = 1;
#[doc = " CUDA texture filter modes"]
pub type cudaTextureFilterMode = ::std::os::raw::c_int;
#[doc = "< Read texture as specified element type"]
pub const cudaTextureReadMode_cudaReadModeElementType: cudaTextureReadMode = 0;
#[doc = "< Read texture as normalized float"]
pub const cudaTextureReadMode_cudaReadModeNormalizedFloat: cudaTextureReadMode = 1;
#[doc = " CUDA texture read modes"]
pub type cudaTextureReadMode = ::std::os::raw::c_int;
#[doc = " CUDA texture reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct textureReference {
    #[doc = " Indicates whether texture reads are normalized or not"]
    pub normalized: ::std::os::raw::c_int,
    #[doc = " Texture filter mode"]
    pub filterMode: cudaTextureFilterMode,
    #[doc = " Texture address mode for up to 3 dimensions"]
    pub addressMode: [cudaTextureAddressMode; 3usize],
    #[doc = " Channel descriptor for the texture reference"]
    pub channelDesc: cudaChannelFormatDesc,
    #[doc = " Perform sRGB->linear conversion during texture read"]
    pub sRGB: ::std::os::raw::c_int,
    #[doc = " Limit to the anisotropy ratio"]
    pub maxAnisotropy: ::std::os::raw::c_uint,
    #[doc = " Mipmap filter mode"]
    pub mipmapFilterMode: cudaTextureFilterMode,
    #[doc = " Offset applied to the supplied mipmap level"]
    pub mipmapLevelBias: f32,
    #[doc = " Lower end of the mipmap level range to clamp access to"]
    pub minMipmapLevelClamp: f32,
    #[doc = " Upper end of the mipmap level range to clamp access to"]
    pub maxMipmapLevelClamp: f32,
    #[doc = " Disable any trilinear filtering optimizations."]
    pub disableTrilinearOptimization: ::std::os::raw::c_int,
    pub __cudaReserved: [::std::os::raw::c_int; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of textureReference"][::std::mem::size_of::<textureReference>() - 124usize];
    ["Alignment of textureReference"][::std::mem::align_of::<textureReference>() - 4usize];
    ["Offset of field: textureReference::normalized"]
        [::std::mem::offset_of!(textureReference, normalized) - 0usize];
    ["Offset of field: textureReference::filterMode"]
        [::std::mem::offset_of!(textureReference, filterMode) - 4usize];
    ["Offset of field: textureReference::addressMode"]
        [::std::mem::offset_of!(textureReference, addressMode) - 8usize];
    ["Offset of field: textureReference::channelDesc"]
        [::std::mem::offset_of!(textureReference, channelDesc) - 20usize];
    ["Offset of field: textureReference::sRGB"]
        [::std::mem::offset_of!(textureReference, sRGB) - 40usize];
    ["Offset of field: textureReference::maxAnisotropy"]
        [::std::mem::offset_of!(textureReference, maxAnisotropy) - 44usize];
    ["Offset of field: textureReference::mipmapFilterMode"]
        [::std::mem::offset_of!(textureReference, mipmapFilterMode) - 48usize];
    ["Offset of field: textureReference::mipmapLevelBias"]
        [::std::mem::offset_of!(textureReference, mipmapLevelBias) - 52usize];
    ["Offset of field: textureReference::minMipmapLevelClamp"]
        [::std::mem::offset_of!(textureReference, minMipmapLevelClamp) - 56usize];
    ["Offset of field: textureReference::maxMipmapLevelClamp"]
        [::std::mem::offset_of!(textureReference, maxMipmapLevelClamp) - 60usize];
    ["Offset of field: textureReference::disableTrilinearOptimization"]
        [::std::mem::offset_of!(textureReference, disableTrilinearOptimization) - 64usize];
    ["Offset of field: textureReference::__cudaReserved"]
        [::std::mem::offset_of!(textureReference, __cudaReserved) - 68usize];
};
#[doc = " CUDA texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaTextureDesc {
    #[doc = " Texture address mode for up to 3 dimensions"]
    pub addressMode: [cudaTextureAddressMode; 3usize],
    #[doc = " Texture filter mode"]
    pub filterMode: cudaTextureFilterMode,
    #[doc = " Texture read mode"]
    pub readMode: cudaTextureReadMode,
    #[doc = " Perform sRGB->linear conversion during texture read"]
    pub sRGB: ::std::os::raw::c_int,
    #[doc = " Texture Border Color"]
    pub borderColor: [f32; 4usize],
    #[doc = " Indicates whether texture reads are normalized or not"]
    pub normalizedCoords: ::std::os::raw::c_int,
    #[doc = " Limit to the anisotropy ratio"]
    pub maxAnisotropy: ::std::os::raw::c_uint,
    #[doc = " Mipmap filter mode"]
    pub mipmapFilterMode: cudaTextureFilterMode,
    #[doc = " Offset applied to the supplied mipmap level"]
    pub mipmapLevelBias: f32,
    #[doc = " Lower end of the mipmap level range to clamp access to"]
    pub minMipmapLevelClamp: f32,
    #[doc = " Upper end of the mipmap level range to clamp access to"]
    pub maxMipmapLevelClamp: f32,
    #[doc = " Disable any trilinear filtering optimizations."]
    pub disableTrilinearOptimization: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaTextureDesc"][::std::mem::size_of::<cudaTextureDesc>() - 68usize];
    ["Alignment of cudaTextureDesc"][::std::mem::align_of::<cudaTextureDesc>() - 4usize];
    ["Offset of field: cudaTextureDesc::addressMode"]
        [::std::mem::offset_of!(cudaTextureDesc, addressMode) - 0usize];
    ["Offset of field: cudaTextureDesc::filterMode"]
        [::std::mem::offset_of!(cudaTextureDesc, filterMode) - 12usize];
    ["Offset of field: cudaTextureDesc::readMode"]
        [::std::mem::offset_of!(cudaTextureDesc, readMode) - 16usize];
    ["Offset of field: cudaTextureDesc::sRGB"]
        [::std::mem::offset_of!(cudaTextureDesc, sRGB) - 20usize];
    ["Offset of field: cudaTextureDesc::borderColor"]
        [::std::mem::offset_of!(cudaTextureDesc, borderColor) - 24usize];
    ["Offset of field: cudaTextureDesc::normalizedCoords"]
        [::std::mem::offset_of!(cudaTextureDesc, normalizedCoords) - 40usize];
    ["Offset of field: cudaTextureDesc::maxAnisotropy"]
        [::std::mem::offset_of!(cudaTextureDesc, maxAnisotropy) - 44usize];
    ["Offset of field: cudaTextureDesc::mipmapFilterMode"]
        [::std::mem::offset_of!(cudaTextureDesc, mipmapFilterMode) - 48usize];
    ["Offset of field: cudaTextureDesc::mipmapLevelBias"]
        [::std::mem::offset_of!(cudaTextureDesc, mipmapLevelBias) - 52usize];
    ["Offset of field: cudaTextureDesc::minMipmapLevelClamp"]
        [::std::mem::offset_of!(cudaTextureDesc, minMipmapLevelClamp) - 56usize];
    ["Offset of field: cudaTextureDesc::maxMipmapLevelClamp"]
        [::std::mem::offset_of!(cudaTextureDesc, maxMipmapLevelClamp) - 60usize];
    ["Offset of field: cudaTextureDesc::disableTrilinearOptimization"]
        [::std::mem::offset_of!(cudaTextureDesc, disableTrilinearOptimization) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaTextureDesc_v2 {
    #[doc = " Texture address mode for up to 3 dimensions"]
    pub addressMode: [cudaTextureAddressMode; 3usize],
    #[doc = " Texture filter mode"]
    pub filterMode: cudaTextureFilterMode,
    #[doc = " Texture read mode"]
    pub readMode: cudaTextureReadMode,
    #[doc = " Perform sRGB->linear conversion during texture read"]
    pub sRGB: ::std::os::raw::c_int,
    #[doc = " Texture Border Color"]
    pub borderColor: [f32; 4usize],
    #[doc = " Indicates whether texture reads are normalized or not"]
    pub normalizedCoords: ::std::os::raw::c_int,
    #[doc = " Limit to the anisotropy ratio"]
    pub maxAnisotropy: ::std::os::raw::c_uint,
    #[doc = " Mipmap filter mode"]
    pub mipmapFilterMode: cudaTextureFilterMode,
    #[doc = " Offset applied to the supplied mipmap level"]
    pub mipmapLevelBias: f32,
    #[doc = " Lower end of the mipmap level range to clamp access to"]
    pub minMipmapLevelClamp: f32,
    #[doc = " Upper end of the mipmap level range to clamp access to"]
    pub maxMipmapLevelClamp: f32,
    #[doc = " Disable any trilinear filtering optimizations."]
    pub disableTrilinearOptimization: ::std::os::raw::c_int,
    #[doc = " Enable seamless cube map filtering."]
    pub seamlessCubemap: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cudaTextureDesc_v2"][::std::mem::size_of::<cudaTextureDesc_v2>() - 72usize];
    ["Alignment of cudaTextureDesc_v2"][::std::mem::align_of::<cudaTextureDesc_v2>() - 4usize];
    ["Offset of field: cudaTextureDesc_v2::addressMode"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, addressMode) - 0usize];
    ["Offset of field: cudaTextureDesc_v2::filterMode"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, filterMode) - 12usize];
    ["Offset of field: cudaTextureDesc_v2::readMode"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, readMode) - 16usize];
    ["Offset of field: cudaTextureDesc_v2::sRGB"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, sRGB) - 20usize];
    ["Offset of field: cudaTextureDesc_v2::borderColor"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, borderColor) - 24usize];
    ["Offset of field: cudaTextureDesc_v2::normalizedCoords"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, normalizedCoords) - 40usize];
    ["Offset of field: cudaTextureDesc_v2::maxAnisotropy"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, maxAnisotropy) - 44usize];
    ["Offset of field: cudaTextureDesc_v2::mipmapFilterMode"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, mipmapFilterMode) - 48usize];
    ["Offset of field: cudaTextureDesc_v2::mipmapLevelBias"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, mipmapLevelBias) - 52usize];
    ["Offset of field: cudaTextureDesc_v2::minMipmapLevelClamp"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, minMipmapLevelClamp) - 56usize];
    ["Offset of field: cudaTextureDesc_v2::maxMipmapLevelClamp"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, maxMipmapLevelClamp) - 60usize];
    ["Offset of field: cudaTextureDesc_v2::disableTrilinearOptimization"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, disableTrilinearOptimization) - 64usize];
    ["Offset of field: cudaTextureDesc_v2::seamlessCubemap"]
        [::std::mem::offset_of!(cudaTextureDesc_v2, seamlessCubemap) - 68usize];
};
#[doc = " An opaque value that represents a CUDA texture object"]
pub type cudaTextureObject_t = ::std::os::raw::c_ulonglong;
unsafe extern "C" {
    #[doc = " \\brief Destroy all allocations and reset all state on the current device\n in the current process.\n\n Explicitly destroys and cleans up all resources associated with the current\n device in the current process. It is the caller's responsibility to ensure\n that the resources are not accessed or passed in subsequent API calls and\n doing so will result in undefined behavior. These resources include CUDA types\n such as ::cudaStream_t, ::cudaEvent_t, ::cudaArray_t, ::cudaMipmappedArray_t,\n ::cudaTextureObject_t, ::cudaSurfaceObject_t, ::textureReference, ::surfaceReference,\n ::cudaExternalMemory_t, ::cudaExternalSemaphore_t and ::cudaGraphicsResource_t.\n Any subsequent API call to this device will reinitialize the device.\n\n Note that this function will reset the device immediately.  It is the caller's\n responsibility to ensure that the device is not being accessed by any\n other host threads from the process when this function is called.\n\n \\return\n ::cudaSuccess\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceSynchronize"]
    pub fn cudaDeviceReset() -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Wait for compute device to finish\n\n Blocks until the device has completed all preceding requested tasks.\n ::cudaDeviceSynchronize() returns an error if one of the preceding tasks\n has failed. If the ::cudaDeviceScheduleBlockingSync flag was set for\n this device, the host thread will block until the device has finished\n its work.\n\n \\return\n ::cudaSuccess\n \\note_device_sync_deprecated\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaDeviceReset,\n ::cuCtxSynchronize"]
    pub fn cudaDeviceSynchronize() -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Set resource limits\n\n Setting \\p limit to \\p value is a request by the application to update\n the current limit maintained by the device.  The driver is free to\n modify the requested value to meet h/w requirements (this could be\n clamping to minimum or maximum values, rounding up to nearest element\n size, etc).  The application can use ::cudaDeviceGetLimit() to find out\n exactly what the limit has been set to.\n\n Setting each ::cudaLimit has its own specific restrictions, so each is\n discussed here.\n\n - ::cudaLimitStackSize controls the stack size in bytes of each GPU thread.\n\n - ::cudaLimitPrintfFifoSize controls the size in bytes of the shared FIFO\n   used by the ::printf() device system call. Setting\n   ::cudaLimitPrintfFifoSize must not be performed after launching any kernel\n   that uses the ::printf() device system call - in such case\n   ::cudaErrorInvalidValue will be returned.\n\n - ::cudaLimitMallocHeapSize controls the size in bytes of the heap used by\n   the ::malloc() and ::free() device system calls. Setting\n   ::cudaLimitMallocHeapSize must not be performed after launching any kernel\n   that uses the ::malloc() or ::free() device system calls - in such case\n   ::cudaErrorInvalidValue will be returned.\n\n - ::cudaLimitDevRuntimeSyncDepth controls the maximum nesting depth of a\n   grid at which a thread can safely call ::cudaDeviceSynchronize(). Setting\n   this limit must be performed before any launch of a kernel that uses the\n   device runtime and calls ::cudaDeviceSynchronize() above the default sync\n   depth, two levels of grids. Calls to ::cudaDeviceSynchronize() will fail\n   with error code ::cudaErrorSyncDepthExceeded if the limitation is\n   violated. This limit can be set smaller than the default or up the maximum\n   launch depth of 24. When setting this limit, keep in mind that additional\n   levels of sync depth require the runtime to reserve large amounts of\n   device memory which can no longer be used for user allocations. If these\n   reservations of device memory fail, ::cudaDeviceSetLimit will return\n   ::cudaErrorMemoryAllocation, and the limit can be reset to a lower value.\n   This limit is only applicable to devices of compute capability 3.5 and\n   higher. Attempting to set this limit on devices of compute capability less\n   than 3.5 will result in the error ::cudaErrorUnsupportedLimit being\n   returned.\n\n - ::cudaLimitDevRuntimePendingLaunchCount controls the maximum number of\n   outstanding device runtime launches that can be made from the current\n   device. A grid is outstanding from the point of launch up until the grid\n   is known to have been completed. Device runtime launches which violate\n   this limitation fail and return ::cudaErrorLaunchPendingCountExceeded when\n   ::cudaGetLastError() is called after launch. If more pending launches than\n   the default (2048 launches) are needed for a module using the device\n   runtime, this limit can be increased. Keep in mind that being able to\n   sustain additional pending launches will require the runtime to reserve\n   larger amounts of device memory upfront which can no longer be used for\n   allocations. If these reservations fail, ::cudaDeviceSetLimit will return\n   ::cudaErrorMemoryAllocation, and the limit can be reset to a lower value.\n   This limit is only applicable to devices of compute capability 3.5 and\n   higher. Attempting to set this limit on devices of compute capability less\n   than 3.5 will result in the error ::cudaErrorUnsupportedLimit being\n   returned.\n\n - ::cudaLimitMaxL2FetchGranularity controls the L2 cache fetch granularity.\n   Values can range from 0B to 128B. This is purely a performance hint and\n   it can be ignored or clamped depending on the platform.\n\n - ::cudaLimitPersistingL2CacheSize controls size in bytes available\n   for persisting L2 cache. This is purely a performance hint and it\n   can be ignored or clamped depending on the platform.\n\n \\param limit - Limit to set\n \\param value - Size of limit\n\n \\return\n ::cudaSuccess,\n ::cudaErrorUnsupportedLimit,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaDeviceGetLimit,\n ::cuCtxSetLimit"]
    pub fn cudaDeviceSetLimit(limit: cudaLimit, value: usize) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns resource limits\n  * Returns in \\p *pValue the current size of \\p limit. The following ::cudaLimit values are supported.\n - ::cudaLimitStackSize is the stack size in bytes of each GPU thread.\n - ::cudaLimitPrintfFifoSize is the size in bytes of the shared FIFO used by the\n   ::printf() device system call.\n - ::cudaLimitMallocHeapSize is the size in bytes of the heap used by the\n   ::malloc() and ::free() device system calls.\n - ::cudaLimitDevRuntimeSyncDepth is the maximum grid depth at which a\n   thread can isssue the device runtime call ::cudaDeviceSynchronize()\n   to wait on child grid launches to complete.\n - ::cudaLimitDevRuntimePendingLaunchCount is the maximum number of outstanding\n   device runtime launches.\n - ::cudaLimitMaxL2FetchGranularity is the L2 cache fetch granularity.\n - ::cudaLimitPersistingL2CacheSize is the persisting L2 cache size in bytes.\n\n \\param limit  - Limit to query\n \\param pValue - Returned size of the limit\n\n \\return\n ::cudaSuccess,\n ::cudaErrorUnsupportedLimit,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaDeviceSetLimit,\n ::cuCtxGetLimit"]
    pub fn cudaDeviceGetLimit(pValue: *mut usize, limit: cudaLimit) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaDeviceGetTexture1DLinearMaxWidth(
        maxWidthInElements: *mut usize,
        fmtDesc: *const cudaChannelFormatDesc,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the preferred cache configuration for the current device.\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this returns through \\p pCacheConfig the preferred cache\n configuration for the current device. This is only a preference. The\n runtime will use the requested configuration if possible, but it is free to\n choose a different configuration if required to execute functions.\n\n This will return a \\p pCacheConfig of ::cudaFuncCachePreferNone on devices\n where the size of the L1 cache and shared memory are fixed.\n\n The supported cache configurations are:\n - ::cudaFuncCachePreferNone: no preference for shared memory or L1 (default)\n - ::cudaFuncCachePreferShared: prefer larger shared memory and smaller L1 cache\n - ::cudaFuncCachePreferL1: prefer larger L1 cache and smaller shared memory\n - ::cudaFuncCachePreferEqual: prefer equal size L1 cache and shared memory\n\n \\param pCacheConfig - Returned cache configuration\n\n \\return\n ::cudaSuccess\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceSetCacheConfig,\n \\ref ::cudaFuncSetCacheConfig(const void*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C API)\",\n \\ref ::cudaFuncSetCacheConfig(T*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C++ API)\",\n ::cuCtxGetCacheConfig"]
    pub fn cudaDeviceGetCacheConfig(pCacheConfig: *mut cudaFuncCache) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns numerical values that correspond to the least and\n greatest stream priorities.\n\n Returns in \\p *leastPriority and \\p *greatestPriority the numerical values that correspond\n to the least and greatest stream priorities respectively. Stream priorities\n follow a convention where lower numbers imply greater priorities. The range of\n meaningful stream priorities is given by [\\p *greatestPriority, \\p *leastPriority].\n If the user attempts to create a stream with a priority value that is\n outside the the meaningful range as specified by this API, the priority is\n automatically clamped down or up to either \\p *leastPriority or \\p *greatestPriority\n respectively. See ::cudaStreamCreateWithPriority for details on creating a\n priority stream.\n A NULL may be passed in for \\p *leastPriority or \\p *greatestPriority if the value\n is not desired.\n\n This function will return '0' in both \\p *leastPriority and \\p *greatestPriority if\n the current context's device does not support stream priorities\n (see ::cudaDeviceGetAttribute).\n\n \\param leastPriority    - Pointer to an int in which the numerical value for least\n                           stream priority is returned\n \\param greatestPriority - Pointer to an int in which the numerical value for greatest\n                           stream priority is returned\n\n \\return\n ::cudaSuccess\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaStreamCreateWithPriority,\n ::cudaStreamGetPriority,\n ::cuCtxGetStreamPriorityRange"]
    pub fn cudaDeviceGetStreamPriorityRange(
        leastPriority: *mut ::std::os::raw::c_int,
        greatestPriority: *mut ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the preferred cache configuration for the current device.\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this sets through \\p cacheConfig the preferred cache\n configuration for the current device. This is only a preference. The\n runtime will use the requested configuration if possible, but it is free to\n choose a different configuration if required to execute the function. Any\n function preference set via\n \\ref ::cudaFuncSetCacheConfig(const void*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C API)\"\n or\n \\ref ::cudaFuncSetCacheConfig(T*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C++ API)\"\n will be preferred over this device-wide setting. Setting the device-wide\n cache configuration to ::cudaFuncCachePreferNone will cause subsequent\n kernel launches to prefer to not change the cache configuration unless\n required to launch the kernel.\n\n This setting does nothing on devices where the size of the L1 cache and\n shared memory are fixed.\n\n Launching a kernel with a different preference than the most recent\n preference setting may insert a device-side synchronization point.\n\n The supported cache configurations are:\n - ::cudaFuncCachePreferNone: no preference for shared memory or L1 (default)\n - ::cudaFuncCachePreferShared: prefer larger shared memory and smaller L1 cache\n - ::cudaFuncCachePreferL1: prefer larger L1 cache and smaller shared memory\n - ::cudaFuncCachePreferEqual: prefer equal size L1 cache and shared memory\n\n \\param cacheConfig - Requested cache configuration\n\n \\return\n ::cudaSuccess\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceGetCacheConfig,\n \\ref ::cudaFuncSetCacheConfig(const void*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C API)\",\n \\ref ::cudaFuncSetCacheConfig(T*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C++ API)\",\n ::cuCtxSetCacheConfig"]
    pub fn cudaDeviceSetCacheConfig(cacheConfig: cudaFuncCache) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the shared memory configuration for the current device.\n\n This function will return in \\p pConfig the current size of shared memory banks\n on the current device. On devices with configurable shared memory banks,\n ::cudaDeviceSetSharedMemConfig can be used to change this setting, so that all\n subsequent kernel launches will by default use the new bank size. When\n ::cudaDeviceGetSharedMemConfig is called on devices without configurable shared\n memory, it will return the fixed bank size of the hardware.\n\n The returned bank configurations can be either:\n - ::cudaSharedMemBankSizeFourByte - shared memory bank width is four bytes.\n - ::cudaSharedMemBankSizeEightByte - shared memory bank width is eight bytes.\n\n \\param pConfig - Returned cache configuration\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceSetCacheConfig,\n ::cudaDeviceGetCacheConfig,\n ::cudaDeviceSetSharedMemConfig,\n ::cudaFuncSetCacheConfig,\n ::cuCtxGetSharedMemConfig"]
    pub fn cudaDeviceGetSharedMemConfig(pConfig: *mut cudaSharedMemConfig) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the shared memory configuration for the current device.\n\n On devices with configurable shared memory banks, this function will set\n the shared memory bank size which is used for all subsequent kernel launches.\n Any per-function setting of shared memory set via ::cudaFuncSetSharedMemConfig\n will override the device wide setting.\n\n Changing the shared memory configuration between launches may introduce\n a device side synchronization point.\n\n Changing the shared memory bank size will not increase shared memory usage\n or affect occupancy of kernels, but may have major effects on performance.\n Larger bank sizes will allow for greater potential bandwidth to shared memory,\n but will change what kinds of accesses to shared memory will result in bank\n conflicts.\n\n This function will do nothing on devices with fixed shared memory bank size.\n\n The supported bank configurations are:\n - ::cudaSharedMemBankSizeDefault: set bank width the device default (currently,\n   four bytes)\n - ::cudaSharedMemBankSizeFourByte: set shared memory bank width to be four bytes\n   natively.\n - ::cudaSharedMemBankSizeEightByte: set shared memory bank width to be eight\n   bytes natively.\n\n \\param config - Requested cache configuration\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceSetCacheConfig,\n ::cudaDeviceGetCacheConfig,\n ::cudaDeviceGetSharedMemConfig,\n ::cudaFuncSetCacheConfig,\n ::cuCtxSetSharedMemConfig"]
    pub fn cudaDeviceSetSharedMemConfig(config: cudaSharedMemConfig) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a handle to a compute device\n\n Returns in \\p *device a device ordinal given a PCI bus ID string.\n\n \\param device   - Returned device ordinal\n\n \\param pciBusId - String in one of the following forms:\n [domain]:[bus]:[device].[function]\n [domain]:[bus]:[device]\n [bus]:[device].[function]\n where \\p domain, \\p bus, \\p device, and \\p function are all hexadecimal values\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaDeviceGetPCIBusId,\n ::cuDeviceGetByPCIBusId"]
    pub fn cudaDeviceGetByPCIBusId(
        device: *mut ::std::os::raw::c_int,
        pciBusId: *const ::std::os::raw::c_char,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a PCI Bus Id string for the device\n\n Returns an ASCII string identifying the device \\p dev in the NULL-terminated\n string pointed to by \\p pciBusId. \\p len specifies the maximum length of the\n string that may be returned.\n\n \\param pciBusId - Returned identifier string for the device in the following format\n [domain]:[bus]:[device].[function]\n where \\p domain, \\p bus, \\p device, and \\p function are all hexadecimal values.\n pciBusId should be large enough to store 13 characters including the NULL-terminator.\n\n \\param len      - Maximum length of string to store in \\p name\n\n \\param device   - Device to get identifier string for\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaDeviceGetByPCIBusId,\n ::cuDeviceGetPCIBusId"]
    pub fn cudaDeviceGetPCIBusId(
        pciBusId: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Gets an interprocess handle for a previously allocated event\n\n Takes as input a previously allocated event. This event must have been\n created with the ::cudaEventInterprocess and ::cudaEventDisableTiming\n flags set. This opaque handle may be copied into other processes and\n opened with ::cudaIpcOpenEventHandle to allow efficient hardware\n synchronization between GPU work in different processes.\n\n After the event has been been opened in the importing process,\n ::cudaEventRecord, ::cudaEventSynchronize, ::cudaStreamWaitEvent and\n ::cudaEventQuery may be used in either process. Performing operations\n on the imported event after the exported event has been freed\n with ::cudaEventDestroy will result in undefined behavior.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux operating systems. IPC functionality is not supported\n on Tegra platforms.\n\n \\param handle - Pointer to a user allocated cudaIpcEventHandle\n                    in which to return the opaque event handle\n \\param event   - Event allocated with ::cudaEventInterprocess and\n                    ::cudaEventDisableTiming flags.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorMemoryAllocation,\n ::cudaErrorMapBufferObjectFailed,\n ::cudaErrorNotSupported,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaEventCreate,\n ::cudaEventDestroy,\n ::cudaEventSynchronize,\n ::cudaEventQuery,\n ::cudaStreamWaitEvent,\n ::cudaIpcOpenEventHandle,\n ::cudaIpcGetMemHandle,\n ::cudaIpcOpenMemHandle,\n ::cudaIpcCloseMemHandle,\n ::cuIpcGetEventHandle"]
    pub fn cudaIpcGetEventHandle(
        handle: *mut cudaIpcEventHandle_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Opens an interprocess event handle for use in the current process\n\n Opens an interprocess event handle exported from another process with\n ::cudaIpcGetEventHandle. This function returns a ::cudaEvent_t that behaves like\n a locally created event with the ::cudaEventDisableTiming flag specified.\n This event must be freed with ::cudaEventDestroy.\n\n Performing operations on the imported event after the exported event has\n been freed with ::cudaEventDestroy will result in undefined behavior.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux operating systems. IPC functionality is not supported\n on Tegra platforms.\n\n \\param event - Returns the imported event\n \\param handle  - Interprocess handle to open\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorMapBufferObjectFailed,\n ::cudaErrorNotSupported,\n ::cudaErrorInvalidValue,\n ::cudaErrorDeviceUninitialized\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaEventCreate,\n ::cudaEventDestroy,\n ::cudaEventSynchronize,\n ::cudaEventQuery,\n ::cudaStreamWaitEvent,\n ::cudaIpcGetEventHandle,\n ::cudaIpcGetMemHandle,\n ::cudaIpcOpenMemHandle,\n ::cudaIpcCloseMemHandle,\n ::cuIpcOpenEventHandle"]
    pub fn cudaIpcOpenEventHandle(
        event: *mut cudaEvent_t,
        handle: cudaIpcEventHandle_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Gets an interprocess memory handle for an existing device memory\n          allocation\n\n Takes a pointer to the base of an existing device memory allocation created\n with ::cudaMalloc and exports it for use in another process. This is a\n lightweight operation and may be called multiple times on an allocation\n without adverse effects.\n\n If a region of memory is freed with ::cudaFree and a subsequent call\n to ::cudaMalloc returns memory with the same device address,\n ::cudaIpcGetMemHandle will return a unique handle for the\n new memory.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux operating systems. IPC functionality is not supported\n on Tegra platforms.\n\n \\param handle - Pointer to user allocated ::cudaIpcMemHandle to return\n                    the handle in.\n \\param devPtr - Base pointer to previously allocated device memory\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorMemoryAllocation,\n ::cudaErrorMapBufferObjectFailed,\n ::cudaErrorNotSupported,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaMalloc,\n ::cudaFree,\n ::cudaIpcGetEventHandle,\n ::cudaIpcOpenEventHandle,\n ::cudaIpcOpenMemHandle,\n ::cudaIpcCloseMemHandle,\n ::cuIpcGetMemHandle"]
    pub fn cudaIpcGetMemHandle(
        handle: *mut cudaIpcMemHandle_t,
        devPtr: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Opens an interprocess memory handle exported from another process\n          and returns a device pointer usable in the local process.\n\n Maps memory exported from another process with ::cudaIpcGetMemHandle into\n the current device address space. For contexts on different devices\n ::cudaIpcOpenMemHandle can attempt to enable peer access between the\n devices as if the user called ::cudaDeviceEnablePeerAccess. This behavior is\n controlled by the ::cudaIpcMemLazyEnablePeerAccess flag.\n ::cudaDeviceCanAccessPeer can determine if a mapping is possible.\n\n ::cudaIpcOpenMemHandle can open handles to devices that may not be visible\n in the process calling the API.\n\n Contexts that may open ::cudaIpcMemHandles are restricted in the following way.\n ::cudaIpcMemHandles from each device in a given process may only be opened\n by one context per device per other process.\n\n If the memory handle has already been opened by the current context, the\n reference count on the handle is incremented by 1 and the existing device pointer\n is returned.\n\n Memory returned from ::cudaIpcOpenMemHandle must be freed with\n ::cudaIpcCloseMemHandle.\n\n Calling ::cudaFree on an exported memory region before calling\n ::cudaIpcCloseMemHandle in the importing context will result in undefined\n behavior.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux operating systems. IPC functionality is not supported\n on Tegra platforms.\n\n \\param devPtr - Returned device pointer\n \\param handle - ::cudaIpcMemHandle to open\n \\param flags  - Flags for this operation. Must be specified as ::cudaIpcMemLazyEnablePeerAccess\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorMapBufferObjectFailed,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorDeviceUninitialized,\n ::cudaErrorTooManyPeers,\n ::cudaErrorNotSupported,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\note No guarantees are made about the address returned in \\p *devPtr.\n In particular, multiple processes may not receive the same address for the same \\p handle.\n\n \\sa\n ::cudaMalloc,\n ::cudaFree,\n ::cudaIpcGetEventHandle,\n ::cudaIpcOpenEventHandle,\n ::cudaIpcGetMemHandle,\n ::cudaIpcCloseMemHandle,\n ::cudaDeviceEnablePeerAccess,\n ::cudaDeviceCanAccessPeer,\n ::cuIpcOpenMemHandle"]
    pub fn cudaIpcOpenMemHandle(
        devPtr: *mut *mut ::std::os::raw::c_void,
        handle: cudaIpcMemHandle_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Attempts to close memory mapped with cudaIpcOpenMemHandle\n\n Decrements the reference count of the memory returnd by ::cudaIpcOpenMemHandle by 1.\n When the reference count reaches 0, this API unmaps the memory. The original allocation\n in the exporting process as well as imported mappings in other processes\n will be unaffected.\n\n Any resources used to enable peer access will be freed if this is the\n last mapping using them.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux operating systems. IPC functionality is not supported\n on Tegra platforms.\n\n \\param devPtr - Device pointer returned by ::cudaIpcOpenMemHandle\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorMapBufferObjectFailed,\n ::cudaErrorNotSupported,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaMalloc,\n ::cudaFree,\n ::cudaIpcGetEventHandle,\n ::cudaIpcOpenEventHandle,\n ::cudaIpcGetMemHandle,\n ::cudaIpcOpenMemHandle,\n ::cuIpcCloseMemHandle"]
    pub fn cudaIpcCloseMemHandle(devPtr: *mut ::std::os::raw::c_void) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaDeviceFlushGPUDirectRDMAWrites(
        target: cudaFlushGPUDirectRDMAWritesTarget,
        scope: cudaFlushGPUDirectRDMAWritesScope,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Exit and clean up from CUDA launches\n\n \\deprecated\n\n Note that this function is deprecated because its name does not\n reflect its behavior.  Its functionality is identical to the\n non-deprecated function ::cudaDeviceReset(), which should be used\n instead.\n\n Explicitly destroys all cleans up all resources associated with the current\n device in the current process.  Any subsequent API call to this device will\n reinitialize the device.\n\n Note that this function will reset the device immediately.  It is the caller's\n responsibility to ensure that the device is not being accessed by any\n other host threads from the process when this function is called.\n\n \\return\n ::cudaSuccess\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceReset"]
    pub fn cudaThreadExit() -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Wait for compute device to finish\n\n \\deprecated\n\n Note that this function is deprecated because its name does not\n reflect its behavior.  Its functionality is similar to the\n non-deprecated function ::cudaDeviceSynchronize(), which should be used\n instead.\n\n Blocks until the device has completed all preceding requested tasks.\n ::cudaThreadSynchronize() returns an error if one of the preceding tasks\n has failed. If the ::cudaDeviceScheduleBlockingSync flag was set for\n this device, the host thread will block until the device has finished\n its work.\n\n \\return\n ::cudaSuccess\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceSynchronize"]
    pub fn cudaThreadSynchronize() -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Set resource limits\n\n \\deprecated\n\n Note that this function is deprecated because its name does not\n reflect its behavior.  Its functionality is identical to the\n non-deprecated function ::cudaDeviceSetLimit(), which should be used\n instead.\n\n Setting \\p limit to \\p value is a request by the application to update\n the current limit maintained by the device.  The driver is free to\n modify the requested value to meet h/w requirements (this could be\n clamping to minimum or maximum values, rounding up to nearest element\n size, etc).  The application can use ::cudaThreadGetLimit() to find out\n exactly what the limit has been set to.\n\n Setting each ::cudaLimit has its own specific restrictions, so each is\n discussed here.\n\n - ::cudaLimitStackSize controls the stack size of each GPU thread.\n\n - ::cudaLimitPrintfFifoSize controls the size of the shared FIFO\n   used by the ::printf() device system call.\n   Setting ::cudaLimitPrintfFifoSize must be performed before\n   launching any kernel that uses the ::printf() device\n   system call, otherwise ::cudaErrorInvalidValue will be returned.\n\n - ::cudaLimitMallocHeapSize controls the size of the heap used\n   by the ::malloc() and ::free() device system calls.  Setting\n   ::cudaLimitMallocHeapSize must be performed before launching\n   any kernel that uses the ::malloc() or ::free() device system calls,\n   otherwise ::cudaErrorInvalidValue will be returned.\n\n \\param limit - Limit to set\n \\param value - Size in bytes of limit\n\n \\return\n ::cudaSuccess,\n ::cudaErrorUnsupportedLimit,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceSetLimit"]
    pub fn cudaThreadSetLimit(limit: cudaLimit, value: usize) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns resource limits\n\n \\deprecated\n\n Note that this function is deprecated because its name does not\n reflect its behavior.  Its functionality is identical to the\n non-deprecated function ::cudaDeviceGetLimit(), which should be used\n instead.\n\n Returns in \\p *pValue the current size of \\p limit.  The supported\n ::cudaLimit values are:\n - ::cudaLimitStackSize: stack size of each GPU thread;\n - ::cudaLimitPrintfFifoSize: size of the shared FIFO used by the\n   ::printf() device system call.\n - ::cudaLimitMallocHeapSize: size of the heap used by the\n   ::malloc() and ::free() device system calls;\n\n \\param limit  - Limit to query\n \\param pValue - Returned size in bytes of limit\n\n \\return\n ::cudaSuccess,\n ::cudaErrorUnsupportedLimit,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceGetLimit"]
    pub fn cudaThreadGetLimit(pValue: *mut usize, limit: cudaLimit) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the preferred cache configuration for the current device.\n\n \\deprecated\n\n Note that this function is deprecated because its name does not\n reflect its behavior.  Its functionality is identical to the\n non-deprecated function ::cudaDeviceGetCacheConfig(), which should be\n used instead.\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this returns through \\p pCacheConfig the preferred cache\n configuration for the current device. This is only a preference. The\n runtime will use the requested configuration if possible, but it is free to\n choose a different configuration if required to execute functions.\n\n This will return a \\p pCacheConfig of ::cudaFuncCachePreferNone on devices\n where the size of the L1 cache and shared memory are fixed.\n\n The supported cache configurations are:\n - ::cudaFuncCachePreferNone: no preference for shared memory or L1 (default)\n - ::cudaFuncCachePreferShared: prefer larger shared memory and smaller L1 cache\n - ::cudaFuncCachePreferL1: prefer larger L1 cache and smaller shared memory\n\n \\param pCacheConfig - Returned cache configuration\n\n \\return\n ::cudaSuccess\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceGetCacheConfig"]
    pub fn cudaThreadGetCacheConfig(pCacheConfig: *mut cudaFuncCache) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the preferred cache configuration for the current device.\n\n \\deprecated\n\n Note that this function is deprecated because its name does not\n reflect its behavior.  Its functionality is identical to the\n non-deprecated function ::cudaDeviceSetCacheConfig(), which should be\n used instead.\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this sets through \\p cacheConfig the preferred cache\n configuration for the current device. This is only a preference. The\n runtime will use the requested configuration if possible, but it is free to\n choose a different configuration if required to execute the function. Any\n function preference set via\n \\ref ::cudaFuncSetCacheConfig(const void*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C API)\"\n or\n \\ref ::cudaFuncSetCacheConfig(T*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C++ API)\"\n will be preferred over this device-wide setting. Setting the device-wide\n cache configuration to ::cudaFuncCachePreferNone will cause subsequent\n kernel launches to prefer to not change the cache configuration unless\n required to launch the kernel.\n\n This setting does nothing on devices where the size of the L1 cache and\n shared memory are fixed.\n\n Launching a kernel with a different preference than the most recent\n preference setting may insert a device-side synchronization point.\n\n The supported cache configurations are:\n - ::cudaFuncCachePreferNone: no preference for shared memory or L1 (default)\n - ::cudaFuncCachePreferShared: prefer larger shared memory and smaller L1 cache\n - ::cudaFuncCachePreferL1: prefer larger L1 cache and smaller shared memory\n\n \\param cacheConfig - Requested cache configuration\n\n \\return\n ::cudaSuccess\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceSetCacheConfig"]
    pub fn cudaThreadSetCacheConfig(cacheConfig: cudaFuncCache) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the last error from a runtime call\n\n Returns the last error that has been produced by any of the runtime calls\n in the same host thread and resets it to ::cudaSuccess.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorMissingConfiguration,\n ::cudaErrorMemoryAllocation,\n ::cudaErrorInitializationError,\n ::cudaErrorLaunchFailure,\n ::cudaErrorLaunchTimeout,\n ::cudaErrorLaunchOutOfResources,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidConfiguration,\n ::cudaErrorInvalidDevice,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidPitchValue,\n ::cudaErrorInvalidSymbol,\n ::cudaErrorUnmapBufferObjectFailed,\n ::cudaErrorInvalidDevicePointer,\n ::cudaErrorInvalidTexture,\n ::cudaErrorInvalidTextureBinding,\n ::cudaErrorInvalidChannelDescriptor,\n ::cudaErrorInvalidMemcpyDirection,\n ::cudaErrorInvalidFilterSetting,\n ::cudaErrorInvalidNormSetting,\n ::cudaErrorUnknown,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorInsufficientDriver,\n ::cudaErrorNoDevice,\n ::cudaErrorSetOnActiveProcess,\n ::cudaErrorStartupFailure,\n ::cudaErrorInvalidPtx,\n ::cudaErrorUnsupportedPtxVersion,\n ::cudaErrorNoKernelImageForDevice,\n ::cudaErrorJitCompilerNotFound,\n ::cudaErrorJitCompilationDisabled\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaPeekAtLastError, ::cudaGetErrorName, ::cudaGetErrorString, ::cudaError"]
    pub fn cudaGetLastError() -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the last error from a runtime call\n\n Returns the last error that has been produced by any of the runtime calls\n in the same host thread. Note that this call does not reset the error to\n ::cudaSuccess like ::cudaGetLastError().\n\n \\return\n ::cudaSuccess,\n ::cudaErrorMissingConfiguration,\n ::cudaErrorMemoryAllocation,\n ::cudaErrorInitializationError,\n ::cudaErrorLaunchFailure,\n ::cudaErrorLaunchTimeout,\n ::cudaErrorLaunchOutOfResources,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidConfiguration,\n ::cudaErrorInvalidDevice,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidPitchValue,\n ::cudaErrorInvalidSymbol,\n ::cudaErrorUnmapBufferObjectFailed,\n ::cudaErrorInvalidDevicePointer,\n ::cudaErrorInvalidTexture,\n ::cudaErrorInvalidTextureBinding,\n ::cudaErrorInvalidChannelDescriptor,\n ::cudaErrorInvalidMemcpyDirection,\n ::cudaErrorInvalidFilterSetting,\n ::cudaErrorInvalidNormSetting,\n ::cudaErrorUnknown,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorInsufficientDriver,\n ::cudaErrorNoDevice,\n ::cudaErrorSetOnActiveProcess,\n ::cudaErrorStartupFailure,\n ::cudaErrorInvalidPtx,\n ::cudaErrorUnsupportedPtxVersion,\n ::cudaErrorNoKernelImageForDevice,\n ::cudaErrorJitCompilerNotFound,\n ::cudaErrorJitCompilationDisabled\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaGetLastError, ::cudaGetErrorName, ::cudaGetErrorString, ::cudaError"]
    pub fn cudaPeekAtLastError() -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the string representation of an error code enum name\n\n Returns a string containing the name of an error code in the enum.  If the error\n code is not recognized, \"unrecognized error code\" is returned.\n\n \\param error - Error code to convert to string\n\n \\return\n \\p char* pointer to a NULL-terminated string\n\n \\sa ::cudaGetErrorString, ::cudaGetLastError, ::cudaPeekAtLastError, ::cudaError,\n ::cuGetErrorName"]
    pub fn cudaGetErrorName(error: cudaError_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the description string for an error code\n\n Returns the description string for an error code.  If the error\n code is not recognized, \"unrecognized error code\" is returned.\n\n \\param error - Error code to convert to string\n\n \\return\n \\p char* pointer to a NULL-terminated string\n\n \\sa ::cudaGetErrorName, ::cudaGetLastError, ::cudaPeekAtLastError, ::cudaError,\n ::cuGetErrorString"]
    pub fn cudaGetErrorString(error: cudaError_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the number of compute-capable devices\n\n Returns in \\p *count the number of devices with compute capability greater\n or equal to 2.0 that are available for execution.\n\n \\param count - Returns the number of devices with compute capability\n greater or equal to 2.0\n\n \\return\n ::cudaSuccess\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaGetDevice, ::cudaSetDevice, ::cudaGetDeviceProperties,\n ::cudaChooseDevice,\n ::cuDeviceGetCount"]
    pub fn cudaGetDeviceCount(count: *mut ::std::os::raw::c_int) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns information about the compute-device\n\n Returns in \\p *prop the properties of device \\p dev. The ::cudaDeviceProp\n structure is defined as:\n \\code\nstruct cudaDeviceProp {\nchar name[256];\ncudaUUID_t uuid;\nsize_t totalGlobalMem;\nsize_t sharedMemPerBlock;\nint regsPerBlock;\nint warpSize;\nsize_t memPitch;\nint maxThreadsPerBlock;\nint maxThreadsDim[3];\nint maxGridSize[3];\nint clockRate;\nsize_t totalConstMem;\nint major;\nint minor;\nsize_t textureAlignment;\nsize_t texturePitchAlignment;\nint deviceOverlap;\nint multiProcessorCount;\nint kernelExecTimeoutEnabled;\nint integrated;\nint canMapHostMemory;\nint computeMode;\nint maxTexture1D;\nint maxTexture1DMipmap;\nint maxTexture1DLinear;\nint maxTexture2D[2];\nint maxTexture2DMipmap[2];\nint maxTexture2DLinear[3];\nint maxTexture2DGather[2];\nint maxTexture3D[3];\nint maxTexture3DAlt[3];\nint maxTextureCubemap;\nint maxTexture1DLayered[2];\nint maxTexture2DLayered[3];\nint maxTextureCubemapLayered[2];\nint maxSurface1D;\nint maxSurface2D[2];\nint maxSurface3D[3];\nint maxSurface1DLayered[2];\nint maxSurface2DLayered[3];\nint maxSurfaceCubemap;\nint maxSurfaceCubemapLayered[2];\nsize_t surfaceAlignment;\nint concurrentKernels;\nint ECCEnabled;\nint pciBusID;\nint pciDeviceID;\nint pciDomainID;\nint tccDriver;\nint asyncEngineCount;\nint unifiedAddressing;\nint memoryClockRate;\nint memoryBusWidth;\nint l2CacheSize;\nint persistingL2CacheMaxSize;\nint maxThreadsPerMultiProcessor;\nint streamPrioritiesSupported;\nint globalL1CacheSupported;\nint localL1CacheSupported;\nsize_t sharedMemPerMultiprocessor;\nint regsPerMultiprocessor;\nint managedMemory;\nint isMultiGpuBoard;\nint multiGpuBoardGroupID;\nint singleToDoublePrecisionPerfRatio;\nint pageableMemoryAccess;\nint concurrentManagedAccess;\nint computePreemptionSupported;\nint canUseHostPointerForRegisteredMem;\nint cooperativeLaunch;\nint cooperativeMultiDeviceLaunch;\nint pageableMemoryAccessUsesHostPageTables;\nint directManagedMemAccessFromHost;\nint accessPolicyMaxWindowSize;\n}\n\\endcode\n where:\n - \\ref ::cudaDeviceProp::name \"name[256]\" is an ASCII string identifying\n   the device.\n - \\ref ::cudaDeviceProp::uuid \"uuid\" is a 16-byte unique identifier.\n - \\ref ::cudaDeviceProp::totalGlobalMem \"totalGlobalMem\" is the total\n   amount of global memory available on the device in bytes.\n - \\ref ::cudaDeviceProp::sharedMemPerBlock \"sharedMemPerBlock\" is the\n   maximum amount of shared memory available to a thread block in bytes.\n - \\ref ::cudaDeviceProp::regsPerBlock \"regsPerBlock\" is the maximum number\n   of 32-bit registers available to a thread block.\n - \\ref ::cudaDeviceProp::warpSize \"warpSize\" is the warp size in threads.\n - \\ref ::cudaDeviceProp::memPitch \"memPitch\" is the maximum pitch in\n   bytes allowed by the memory copy functions that involve memory regions\n   allocated through ::cudaMallocPitch().\n - \\ref ::cudaDeviceProp::maxThreadsPerBlock \"maxThreadsPerBlock\" is the\n   maximum number of threads per block.\n - \\ref ::cudaDeviceProp::maxThreadsDim \"maxThreadsDim[3]\" contains the\n   maximum size of each dimension of a block.\n - \\ref ::cudaDeviceProp::maxGridSize \"maxGridSize[3]\" contains the\n   maximum size of each dimension of a grid.\n - \\ref ::cudaDeviceProp::clockRate \"clockRate\" is the clock frequency in\n   kilohertz.\n - \\ref ::cudaDeviceProp::totalConstMem \"totalConstMem\" is the total amount\n   of constant memory available on the device in bytes.\n - \\ref ::cudaDeviceProp::major \"major\",\n   \\ref ::cudaDeviceProp::minor \"minor\" are the major and minor revision\n   numbers defining the device's compute capability.\n - \\ref ::cudaDeviceProp::textureAlignment \"textureAlignment\" is the\n   alignment requirement; texture base addresses that are aligned to\n   \\ref ::cudaDeviceProp::textureAlignment \"textureAlignment\" bytes do not\n   need an offset applied to texture fetches.\n - \\ref ::cudaDeviceProp::texturePitchAlignment \"texturePitchAlignment\" is the\n   pitch alignment requirement for 2D texture references that are bound to\n   pitched memory.\n - \\ref ::cudaDeviceProp::deviceOverlap \"deviceOverlap\" is 1 if the device\n   can concurrently copy memory between host and device while executing a\n   kernel, or 0 if not.  Deprecated, use instead asyncEngineCount.\n - \\ref ::cudaDeviceProp::multiProcessorCount \"multiProcessorCount\" is the\n   number of multiprocessors on the device.\n - \\ref ::cudaDeviceProp::kernelExecTimeoutEnabled \"kernelExecTimeoutEnabled\"\n   is 1 if there is a run time limit for kernels executed on the device, or\n   0 if not.\n - \\ref ::cudaDeviceProp::integrated \"integrated\" is 1 if the device is an\n   integrated (motherboard) GPU and 0 if it is a discrete (card) component.\n - \\ref ::cudaDeviceProp::canMapHostMemory \"canMapHostMemory\" is 1 if the\n   device can map host memory into the CUDA address space for use with\n   ::cudaHostAlloc()/::cudaHostGetDevicePointer(), or 0 if not.\n - \\ref ::cudaDeviceProp::computeMode \"computeMode\" is the compute mode\n   that the device is currently in. Available modes are as follows:\n   - cudaComputeModeDefault: Default mode - Device is not restricted and\n     multiple threads can use ::cudaSetDevice() with this device.\n   - cudaComputeModeProhibited: Compute-prohibited mode - No threads can use\n     ::cudaSetDevice() with this device.\n   - cudaComputeModeExclusiveProcess: Compute-exclusive-process mode - Many\n     threads in one process will be able to use ::cudaSetDevice() with this device.\n   <br> When an occupied exclusive mode device is chosen with ::cudaSetDevice,\n   all subsequent non-device management runtime functions will return\n   ::cudaErrorDevicesUnavailable.\n - \\ref ::cudaDeviceProp::maxTexture1D \"maxTexture1D\" is the maximum 1D\n   texture size.\n - \\ref ::cudaDeviceProp::maxTexture1DMipmap \"maxTexture1DMipmap\" is the maximum\n   1D mipmapped texture texture size.\n - \\ref ::cudaDeviceProp::maxTexture1DLinear \"maxTexture1DLinear\" is the maximum\n   1D texture size for textures bound to linear memory.\n - \\ref ::cudaDeviceProp::maxTexture2D \"maxTexture2D[2]\" contains the maximum\n   2D texture dimensions.\n - \\ref ::cudaDeviceProp::maxTexture2DMipmap \"maxTexture2DMipmap[2]\" contains the\n   maximum 2D mipmapped texture dimensions.\n - \\ref ::cudaDeviceProp::maxTexture2DLinear \"maxTexture2DLinear[3]\" contains the\n   maximum 2D texture dimensions for 2D textures bound to pitch linear memory.\n - \\ref ::cudaDeviceProp::maxTexture2DGather \"maxTexture2DGather[2]\" contains the\n   maximum 2D texture dimensions if texture gather operations have to be performed.\n - \\ref ::cudaDeviceProp::maxTexture3D \"maxTexture3D[3]\" contains the maximum\n   3D texture dimensions.\n - \\ref ::cudaDeviceProp::maxTexture3DAlt \"maxTexture3DAlt[3]\"\n   contains the maximum alternate 3D texture dimensions.\n - \\ref ::cudaDeviceProp::maxTextureCubemap \"maxTextureCubemap\" is the\n   maximum cubemap texture width or height.\n - \\ref ::cudaDeviceProp::maxTexture1DLayered \"maxTexture1DLayered[2]\" contains\n   the maximum 1D layered texture dimensions.\n - \\ref ::cudaDeviceProp::maxTexture2DLayered \"maxTexture2DLayered[3]\" contains\n   the maximum 2D layered texture dimensions.\n - \\ref ::cudaDeviceProp::maxTextureCubemapLayered \"maxTextureCubemapLayered[2]\"\n   contains the maximum cubemap layered texture dimensions.\n - \\ref ::cudaDeviceProp::maxSurface1D \"maxSurface1D\" is the maximum 1D\n   surface size.\n - \\ref ::cudaDeviceProp::maxSurface2D \"maxSurface2D[2]\" contains the maximum\n   2D surface dimensions.\n - \\ref ::cudaDeviceProp::maxSurface3D \"maxSurface3D[3]\" contains the maximum\n   3D surface dimensions.\n - \\ref ::cudaDeviceProp::maxSurface1DLayered \"maxSurface1DLayered[2]\" contains\n   the maximum 1D layered surface dimensions.\n - \\ref ::cudaDeviceProp::maxSurface2DLayered \"maxSurface2DLayered[3]\" contains\n   the maximum 2D layered surface dimensions.\n - \\ref ::cudaDeviceProp::maxSurfaceCubemap \"maxSurfaceCubemap\" is the maximum\n   cubemap surface width or height.\n - \\ref ::cudaDeviceProp::maxSurfaceCubemapLayered \"maxSurfaceCubemapLayered[2]\"\n   contains the maximum cubemap layered surface dimensions.\n - \\ref ::cudaDeviceProp::surfaceAlignment \"surfaceAlignment\" specifies the\n   alignment requirements for surfaces.\n - \\ref ::cudaDeviceProp::concurrentKernels \"concurrentKernels\" is 1 if the\n   device supports executing multiple kernels within the same context\n   simultaneously, or 0 if not. It is not guaranteed that multiple kernels\n   will be resident on the device concurrently so this feature should not be\n   relied upon for correctness.\n - \\ref ::cudaDeviceProp::ECCEnabled \"ECCEnabled\" is 1 if the device has ECC\n   support turned on, or 0 if not.\n - \\ref ::cudaDeviceProp::pciBusID \"pciBusID\" is the PCI bus identifier of\n   the device.\n - \\ref ::cudaDeviceProp::pciDeviceID \"pciDeviceID\" is the PCI device\n   (sometimes called slot) identifier of the device.\n - \\ref ::cudaDeviceProp::pciDomainID \"pciDomainID\" is the PCI domain identifier\n   of the device.\n - \\ref ::cudaDeviceProp::tccDriver \"tccDriver\" is 1 if the device is using a\n   TCC driver or 0 if not.\n - \\ref ::cudaDeviceProp::asyncEngineCount \"asyncEngineCount\" is 1 when the\n   device can concurrently copy memory between host and device while executing\n   a kernel. It is 2 when the device can concurrently copy memory between host\n   and device in both directions and execute a kernel at the same time. It is\n   0 if neither of these is supported.\n - \\ref ::cudaDeviceProp::unifiedAddressing \"unifiedAddressing\" is 1 if the device\n   shares a unified address space with the host and 0 otherwise.\n - \\ref ::cudaDeviceProp::memoryClockRate \"memoryClockRate\" is the peak memory\n   clock frequency in kilohertz.\n - \\ref ::cudaDeviceProp::memoryBusWidth \"memoryBusWidth\" is the memory bus width\n   in bits.\n - \\ref ::cudaDeviceProp::l2CacheSize \"l2CacheSize\" is L2 cache size in bytes.\n - \\ref ::cudaDeviceProp::persistingL2CacheMaxSize \"persistingL2CacheMaxSize\" is L2 cache's maximum persisting lines size in bytes.\n - \\ref ::cudaDeviceProp::maxThreadsPerMultiProcessor \"maxThreadsPerMultiProcessor\"\n   is the number of maximum resident threads per multiprocessor.\n - \\ref ::cudaDeviceProp::streamPrioritiesSupported \"streamPrioritiesSupported\"\n   is 1 if the device supports stream priorities, or 0 if it is not supported.\n - \\ref ::cudaDeviceProp::globalL1CacheSupported \"globalL1CacheSupported\"\n   is 1 if the device supports caching of globals in L1 cache, or 0 if it is not supported.\n - \\ref ::cudaDeviceProp::localL1CacheSupported \"localL1CacheSupported\"\n   is 1 if the device supports caching of locals in L1 cache, or 0 if it is not supported.\n - \\ref ::cudaDeviceProp::sharedMemPerMultiprocessor \"sharedMemPerMultiprocessor\" is the\n   maximum amount of shared memory available to a multiprocessor in bytes; this amount is\n   shared by all thread blocks simultaneously resident on a multiprocessor.\n - \\ref ::cudaDeviceProp::regsPerMultiprocessor \"regsPerMultiprocessor\" is the maximum number\n   of 32-bit registers available to a multiprocessor; this number is shared\n   by all thread blocks simultaneously resident on a multiprocessor.\n - \\ref ::cudaDeviceProp::managedMemory \"managedMemory\"\n   is 1 if the device supports allocating managed memory on this system, or 0 if it is not supported.\n - \\ref ::cudaDeviceProp::isMultiGpuBoard \"isMultiGpuBoard\"\n   is 1 if the device is on a multi-GPU board (e.g. Gemini cards), and 0 if not;\n - \\ref ::cudaDeviceProp::multiGpuBoardGroupID \"multiGpuBoardGroupID\" is a unique identifier\n   for a group of devices associated with the same board.\n   Devices on the same multi-GPU board will share the same identifier.\n - \\ref ::cudaDeviceProp::singleToDoublePrecisionPerfRatio \"singleToDoublePrecisionPerfRatio\"\n   is the ratio of single precision performance (in floating-point operations per second)\n   to double precision performance.\n - \\ref ::cudaDeviceProp::pageableMemoryAccess \"pageableMemoryAccess\" is 1 if the device supports\n   coherently accessing pageable memory without calling cudaHostRegister on it, and 0 otherwise.\n - \\ref ::cudaDeviceProp::concurrentManagedAccess \"concurrentManagedAccess\" is 1 if the device can\n   coherently access managed memory concurrently with the CPU, and 0 otherwise.\n - \\ref ::cudaDeviceProp::computePreemptionSupported \"computePreemptionSupported\" is 1 if the device\n   supports Compute Preemption, and 0 otherwise.\n - \\ref ::cudaDeviceProp::canUseHostPointerForRegisteredMem \"canUseHostPointerForRegisteredMem\" is 1 if\n   the device can access host registered memory at the same virtual address as the CPU, and 0 otherwise.\n - \\ref ::cudaDeviceProp::cooperativeLaunch \"cooperativeLaunch\" is 1 if the device supports launching\n   cooperative kernels via ::cudaLaunchCooperativeKernel, and 0 otherwise.\n - \\ref ::cudaDeviceProp::cooperativeMultiDeviceLaunch \"cooperativeMultiDeviceLaunch\" is 1 if the device\n   supports launching cooperative kernels via ::cudaLaunchCooperativeKernelMultiDevice, and 0 otherwise.\n - \\ref ::cudaDeviceProp::pageableMemoryAccessUsesHostPageTables \"pageableMemoryAccessUsesHostPageTables\" is 1 if the device accesses\n   pageable memory via the host's page tables, and 0 otherwise.\n - \\ref ::cudaDeviceProp::directManagedMemAccessFromHost \"directManagedMemAccessFromHost\" is 1 if the host can directly access managed\n   memory on the device without migration, and 0 otherwise.\n - \\ref ::cudaDeviceProp::maxBlocksPerMultiProcessor \"maxBlocksPerMultiProcessor\" is the maximum number of thread blocks\n   that can reside on a multiprocessor.\n - \\ref ::cudaDeviceProp::accessPolicyMaxWindowSize \"accessPolicyMaxWindowSize\" is\n   the maximum value of ::cudaAccessPolicyWindow::num_bytes.\n\n \\param prop   - Properties for the specified device\n \\param device - Device number to get properties for\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaGetDeviceCount, ::cudaGetDevice, ::cudaSetDevice, ::cudaChooseDevice,\n ::cudaDeviceGetAttribute,\n ::cuDeviceGetAttribute,\n ::cuDeviceGetName"]
    pub fn cudaGetDeviceProperties(
        prop: *mut cudaDeviceProp,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns information about the device\n\n Returns in \\p *value the integer value of the attribute \\p attr on device\n \\p device. The supported attributes are:\n - ::cudaDevAttrMaxThreadsPerBlock: Maximum number of threads per block\n - ::cudaDevAttrMaxBlockDimX: Maximum x-dimension of a block\n - ::cudaDevAttrMaxBlockDimY: Maximum y-dimension of a block\n - ::cudaDevAttrMaxBlockDimZ: Maximum z-dimension of a block\n - ::cudaDevAttrMaxGridDimX: Maximum x-dimension of a grid\n - ::cudaDevAttrMaxGridDimY: Maximum y-dimension of a grid\n - ::cudaDevAttrMaxGridDimZ: Maximum z-dimension of a grid\n - ::cudaDevAttrMaxSharedMemoryPerBlock: Maximum amount of shared memory\n   available to a thread block in bytes\n - ::cudaDevAttrTotalConstantMemory: Memory available on device for\n   __constant__ variables in a CUDA C kernel in bytes\n - ::cudaDevAttrWarpSize: Warp size in threads\n - ::cudaDevAttrMaxPitch: Maximum pitch in bytes allowed by the memory copy\n   functions that involve memory regions allocated through ::cudaMallocPitch()\n - ::cudaDevAttrMaxTexture1DWidth: Maximum 1D texture width\n - ::cudaDevAttrMaxTexture1DLinearWidth: Maximum width for a 1D texture bound\n   to linear memory\n - ::cudaDevAttrMaxTexture1DMipmappedWidth: Maximum mipmapped 1D texture width\n - ::cudaDevAttrMaxTexture2DWidth: Maximum 2D texture width\n - ::cudaDevAttrMaxTexture2DHeight: Maximum 2D texture height\n - ::cudaDevAttrMaxTexture2DLinearWidth: Maximum width for a 2D texture\n   bound to linear memory\n - ::cudaDevAttrMaxTexture2DLinearHeight: Maximum height for a 2D texture\n   bound to linear memory\n - ::cudaDevAttrMaxTexture2DLinearPitch: Maximum pitch in bytes for a 2D\n   texture bound to linear memory\n - ::cudaDevAttrMaxTexture2DMipmappedWidth: Maximum mipmapped 2D texture\n   width\n - ::cudaDevAttrMaxTexture2DMipmappedHeight: Maximum mipmapped 2D texture\n   height\n - ::cudaDevAttrMaxTexture3DWidth: Maximum 3D texture width\n - ::cudaDevAttrMaxTexture3DHeight: Maximum 3D texture height\n - ::cudaDevAttrMaxTexture3DDepth: Maximum 3D texture depth\n - ::cudaDevAttrMaxTexture3DWidthAlt: Alternate maximum 3D texture width,\n   0 if no alternate maximum 3D texture size is supported\n - ::cudaDevAttrMaxTexture3DHeightAlt: Alternate maximum 3D texture height,\n   0 if no alternate maximum 3D texture size is supported\n - ::cudaDevAttrMaxTexture3DDepthAlt: Alternate maximum 3D texture depth,\n   0 if no alternate maximum 3D texture size is supported\n - ::cudaDevAttrMaxTextureCubemapWidth: Maximum cubemap texture width or\n   height\n - ::cudaDevAttrMaxTexture1DLayeredWidth: Maximum 1D layered texture width\n - ::cudaDevAttrMaxTexture1DLayeredLayers: Maximum layers in a 1D layered\n   texture\n - ::cudaDevAttrMaxTexture2DLayeredWidth: Maximum 2D layered texture width\n - ::cudaDevAttrMaxTexture2DLayeredHeight: Maximum 2D layered texture height\n - ::cudaDevAttrMaxTexture2DLayeredLayers: Maximum layers in a 2D layered\n   texture\n - ::cudaDevAttrMaxTextureCubemapLayeredWidth: Maximum cubemap layered\n   texture width or height\n - ::cudaDevAttrMaxTextureCubemapLayeredLayers: Maximum layers in a cubemap\n   layered texture\n - ::cudaDevAttrMaxSurface1DWidth: Maximum 1D surface width\n - ::cudaDevAttrMaxSurface2DWidth: Maximum 2D surface width\n - ::cudaDevAttrMaxSurface2DHeight: Maximum 2D surface height\n - ::cudaDevAttrMaxSurface3DWidth: Maximum 3D surface width\n - ::cudaDevAttrMaxSurface3DHeight: Maximum 3D surface height\n - ::cudaDevAttrMaxSurface3DDepth: Maximum 3D surface depth\n - ::cudaDevAttrMaxSurface1DLayeredWidth: Maximum 1D layered surface width\n - ::cudaDevAttrMaxSurface1DLayeredLayers: Maximum layers in a 1D layered\n   surface\n - ::cudaDevAttrMaxSurface2DLayeredWidth: Maximum 2D layered surface width\n - ::cudaDevAttrMaxSurface2DLayeredHeight: Maximum 2D layered surface height\n - ::cudaDevAttrMaxSurface2DLayeredLayers: Maximum layers in a 2D layered\n   surface\n - ::cudaDevAttrMaxSurfaceCubemapWidth: Maximum cubemap surface width\n - ::cudaDevAttrMaxSurfaceCubemapLayeredWidth: Maximum cubemap layered\n   surface width\n - ::cudaDevAttrMaxSurfaceCubemapLayeredLayers: Maximum layers in a cubemap\n   layered surface\n - ::cudaDevAttrMaxRegistersPerBlock: Maximum number of 32-bit registers\n   available to a thread block\n - ::cudaDevAttrClockRate: Peak clock frequency in kilohertz\n - ::cudaDevAttrTextureAlignment: Alignment requirement; texture base\n   addresses aligned to ::textureAlign bytes do not need an offset applied\n   to texture fetches\n - ::cudaDevAttrTexturePitchAlignment: Pitch alignment requirement for 2D\n   texture references bound to pitched memory\n - ::cudaDevAttrGpuOverlap: 1 if the device can concurrently copy memory\n   between host and device while executing a kernel, or 0 if not\n - ::cudaDevAttrMultiProcessorCount: Number of multiprocessors on the device\n - ::cudaDevAttrKernelExecTimeout: 1 if there is a run time limit for kernels\n   executed on the device, or 0 if not\n - ::cudaDevAttrIntegrated: 1 if the device is integrated with the memory\n   subsystem, or 0 if not\n - ::cudaDevAttrCanMapHostMemory: 1 if the device can map host memory into\n   the CUDA address space, or 0 if not\n - ::cudaDevAttrComputeMode: Compute mode is the compute mode that the device\n   is currently in. Available modes are as follows:\n   - ::cudaComputeModeDefault: Default mode - Device is not restricted and\n     multiple threads can use ::cudaSetDevice() with this device.\n   - ::cudaComputeModeProhibited: Compute-prohibited mode - No threads can use\n     ::cudaSetDevice() with this device.\n   - ::cudaComputeModeExclusiveProcess: Compute-exclusive-process mode - Many\n     threads in one process will be able to use ::cudaSetDevice() with this\n     device.\n - ::cudaDevAttrConcurrentKernels: 1 if the device supports executing\n   multiple kernels within the same context simultaneously, or 0 if\n   not. It is not guaranteed that multiple kernels will be resident on the\n   device concurrently so this feature should not be relied upon for\n   correctness.\n - ::cudaDevAttrEccEnabled: 1 if error correction is enabled on the device,\n   0 if error correction is disabled or not supported by the device\n - ::cudaDevAttrPciBusId: PCI bus identifier of the device\n - ::cudaDevAttrPciDeviceId: PCI device (also known as slot) identifier of\n   the device\n - ::cudaDevAttrTccDriver: 1 if the device is using a TCC driver. TCC is only\n   available on Tesla hardware running Windows Vista or later.\n - ::cudaDevAttrMemoryClockRate: Peak memory clock frequency in kilohertz\n - ::cudaDevAttrGlobalMemoryBusWidth: Global memory bus width in bits\n - ::cudaDevAttrL2CacheSize: Size of L2 cache in bytes. 0 if the device\n   doesn't have L2 cache.\n - ::cudaDevAttrMaxThreadsPerMultiProcessor: Maximum resident threads per\n   multiprocessor\n - ::cudaDevAttrUnifiedAddressing: 1 if the device shares a unified address\n   space with the host, or 0 if not\n - ::cudaDevAttrComputeCapabilityMajor: Major compute capability version\n   number\n - ::cudaDevAttrComputeCapabilityMinor: Minor compute capability version\n   number\n - ::cudaDevAttrStreamPrioritiesSupported: 1 if the device supports stream\n   priorities, or 0 if not\n - ::cudaDevAttrGlobalL1CacheSupported: 1 if device supports caching globals\n    in L1 cache, 0 if not\n - ::cudaDevAttrLocalL1CacheSupported: 1 if device supports caching locals\n    in L1 cache, 0 if not\n - ::cudaDevAttrMaxSharedMemoryPerMultiprocessor: Maximum amount of shared memory\n   available to a multiprocessor in bytes; this amount is shared by all\n   thread blocks simultaneously resident on a multiprocessor\n - ::cudaDevAttrMaxRegistersPerMultiprocessor: Maximum number of 32-bit registers\n   available to a multiprocessor; this number is shared by all thread blocks\n   simultaneously resident on a multiprocessor\n - ::cudaDevAttrManagedMemory: 1 if device supports allocating\n   managed memory, 0 if not\n - ::cudaDevAttrIsMultiGpuBoard: 1 if device is on a multi-GPU board, 0 if not\n - ::cudaDevAttrMultiGpuBoardGroupID: Unique identifier for a group of devices on the\n   same multi-GPU board\n - ::cudaDevAttrHostNativeAtomicSupported: 1 if the link between the device and the\n   host supports native atomic operations\n - ::cudaDevAttrSingleToDoublePrecisionPerfRatio: Ratio of single precision performance\n   (in floating-point operations per second) to double precision performance\n - ::cudaDevAttrPageableMemoryAccess: 1 if the device supports coherently accessing\n   pageable memory without calling cudaHostRegister on it, and 0 otherwise\n - ::cudaDevAttrConcurrentManagedAccess: 1 if the device can coherently access managed\n   memory concurrently with the CPU, and 0 otherwise\n - ::cudaDevAttrComputePreemptionSupported: 1 if the device supports\n   Compute Preemption, 0 if not\n - ::cudaDevAttrCanUseHostPointerForRegisteredMem: 1 if the device can access host\n   registered memory at the same virtual address as the CPU, and 0 otherwise\n - ::cudaDevAttrCooperativeLaunch: 1 if the device supports launching cooperative kernels\n   via ::cudaLaunchCooperativeKernel, and 0 otherwise\n - ::cudaDevAttrCooperativeMultiDeviceLaunch: 1 if the device supports launching cooperative\n   kernels via ::cudaLaunchCooperativeKernelMultiDevice, and 0 otherwise\n - ::cudaDevAttrCanFlushRemoteWrites: 1 if the device supports flushing of outstanding\n   remote writes, and 0 otherwise\n - ::cudaDevAttrHostRegisterSupported: 1 if the device supports host memory registration\n   via ::cudaHostRegister, and 0 otherwise\n - ::cudaDevAttrPageableMemoryAccessUsesHostPageTables: 1 if the device accesses pageable memory via the\n   host's page tables, and 0 otherwise\n - ::cudaDevAttrDirectManagedMemAccessFromHost: 1 if the host can directly access managed memory on the device\n   without migration, and 0 otherwise\n - ::cudaDevAttrMaxSharedMemoryPerBlockOptin: Maximum per block shared memory size on the device. This value can\n   be opted into when using ::cudaFuncSetAttribute\n - ::cudaDevAttrMaxBlocksPerMultiprocessor: Maximum number of thread blocks that can reside on a multiprocessor\n - ::cudaDevAttrMaxPersistingL2CacheSize: Maximum L2 persisting lines capacity setting in bytes\n - ::cudaDevAttrMaxAccessPolicyWindowSize: Maximum value of cudaAccessPolicyWindow::num_bytes\n - ::cudaDevAttrReservedSharedMemoryPerBlock: Shared memory reserved by CUDA driver per block in bytes\n - ::cudaDevAttrSparseCudaArraySupported: 1 if the device supports sparse CUDA arrays and sparse CUDA mipmapped arrays.\n - ::cudaDevAttrHostRegisterReadOnlySupported: Device supports using the ::cudaHostRegister flag cudaHostRegisterReadOnly\n   to register memory that must be mapped as read-only to the GPU\n - ::cudaDevAttrMemoryPoolsSupported: 1 if the device supports using the cudaMallocAsync and cudaMemPool family of APIs, and 0 otherwise\n - ::cudaDevAttrGPUDirectRDMASupported: 1 if the device supports GPUDirect RDMA APIs, and 0 otherwise\n - ::cudaDevAttrGPUDirectRDMAFlushWritesOptions: bitmask to be interpreted according to the ::cudaFlushGPUDirectRDMAWritesOptions enum\n - ::cudaDevAttrGPUDirectRDMAWritesOrdering: see the ::cudaGPUDirectRDMAWritesOrdering enum for numerical values\n - ::cudaDevAttrMemoryPoolSupportedHandleTypes: Bitmask of handle types supported with mempool based IPC\n - ::cudaDevAttrDeferredMappingCudaArraySupported : 1 if the device supports deferred mapping CUDA arrays and CUDA mipmapped arrays.\n\n \\param value  - Returned device attribute value\n \\param attr   - Device attribute to query\n \\param device - Device number to query\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDevice,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaGetDeviceCount, ::cudaGetDevice, ::cudaSetDevice, ::cudaChooseDevice,\n ::cudaGetDeviceProperties,\n ::cuDeviceGetAttribute"]
    pub fn cudaDeviceGetAttribute(
        value: *mut ::std::os::raw::c_int,
        attr: cudaDeviceAttr,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the default mempool of a device\n\n The default mempool of a device contains device memory from that device.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDevice,\n ::cudaErrorInvalidValue\n ::cudaErrorNotSupported\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cuDeviceGetDefaultMemPool, ::cudaMallocAsync, ::cudaMemPoolTrimTo, ::cudaMemPoolGetAttribute, ::cudaDeviceSetMemPool, ::cudaMemPoolSetAttribute, ::cudaMemPoolSetAccess"]
    pub fn cudaDeviceGetDefaultMemPool(
        memPool: *mut cudaMemPool_t,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the current memory pool of a device\n\n The memory pool must be local to the specified device.\n Unless a mempool is specified in the ::cudaMallocAsync call,\n ::cudaMallocAsync allocates from the current mempool of the provided stream's device.\n By default, a device's current memory pool is its default memory pool.\n\n \\note Use ::cudaMallocFromPoolAsync to specify asynchronous allocations from a device different\n than the one the stream runs on.\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n ::cudaErrorInvalidDevice\n ::cudaErrorNotSupported\n \\notefnerr\n \\note_callback\n\n \\sa ::cuDeviceSetDefaultMemPool, ::cudaDeviceGetMemPool, ::cudaDeviceGetDefaultMemPool, ::cudaMemPoolCreate, ::cudaMemPoolDestroy, ::cudaMallocFromPoolAsync"]
    pub fn cudaDeviceSetMemPool(
        device: ::std::os::raw::c_int,
        memPool: cudaMemPool_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Gets the current mempool for a device\n\n Returns the last pool provided to ::cudaDeviceSetMemPool for this device\n or the device's default memory pool if ::cudaDeviceSetMemPool has never been called.\n By default the current mempool is the default mempool for a device,\n otherwise the returned pool must have been set with ::cuDeviceSetMemPool or ::cudaDeviceSetMemPool.\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n ::cudaErrorNotSupported\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cuDeviceGetMemPool, ::cudaDeviceGetDefaultMemPool, ::cudaDeviceSetMemPool"]
    pub fn cudaDeviceGetMemPool(
        memPool: *mut cudaMemPool_t,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Return NvSciSync attributes that this device can support.\n\n Returns in \\p nvSciSyncAttrList, the properties of NvSciSync that\n this CUDA device, \\p dev can support. The returned \\p nvSciSyncAttrList\n can be used to create an NvSciSync that matches this device's capabilities.\n\n If NvSciSyncAttrKey_RequiredPerm field in \\p nvSciSyncAttrList is\n already set this API will return ::cudaErrorInvalidValue.\n\n The applications should set \\p nvSciSyncAttrList to a valid\n NvSciSyncAttrList failing which this API will return\n ::cudaErrorInvalidHandle.\n\n The \\p flags controls how applications intends to use\n the NvSciSync created from the \\p nvSciSyncAttrList. The valid flags are:\n - ::cudaNvSciSyncAttrSignal, specifies that the applications intends to\n signal an NvSciSync on this CUDA device.\n - ::cudaNvSciSyncAttrWait, specifies that the applications intends to\n wait on an NvSciSync on this CUDA device.\n\n At least one of these flags must be set, failing which the API\n returns ::cudaErrorInvalidValue. Both the flags are orthogonal\n to one another: a developer may set both these flags that allows to\n set both wait and signal specific attributes in the same \\p nvSciSyncAttrList.\n\n \\param nvSciSyncAttrList     - Return NvSciSync attributes supported.\n \\param device                - Valid Cuda Device to get NvSciSync attributes for.\n \\param flags                 - flags describing NvSciSync usage.\n\n \\return\n\n ::cudaSuccess,\n ::cudaErrorDeviceUninitialized,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidHandle,\n ::cudaErrorInvalidDevice,\n ::cudaErrorNotSupported,\n ::cudaErrorMemoryAllocation\n\n \\sa\n ::cudaImportExternalSemaphore,\n ::cudaDestroyExternalSemaphore,\n ::cudaSignalExternalSemaphoresAsync,\n ::cudaWaitExternalSemaphoresAsync"]
    pub fn cudaDeviceGetNvSciSyncAttributes(
        nvSciSyncAttrList: *mut ::std::os::raw::c_void,
        device: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Queries attributes of the link between two devices.\n\n Returns in \\p *value the value of the requested attribute \\p attrib of the\n link between \\p srcDevice and \\p dstDevice. The supported attributes are:\n - ::cudaDevP2PAttrPerformanceRank: A relative value indicating the\n   performance of the link between two devices. Lower value means better\n   performance (0 being the value used for most performant link).\n - ::cudaDevP2PAttrAccessSupported: 1 if peer access is enabled.\n - ::cudaDevP2PAttrNativeAtomicSupported: 1 if native atomic operations over\n   the link are supported.\n - ::cudaDevP2PAttrCudaArrayAccessSupported: 1 if accessing CUDA arrays over\n   the link is supported.\n\n Returns ::cudaErrorInvalidDevice if \\p srcDevice or \\p dstDevice are not valid\n or if they represent the same device.\n\n Returns ::cudaErrorInvalidValue if \\p attrib is not valid or if \\p value is\n a null pointer.\n\n \\param value         - Returned value of the requested attribute\n \\param attrib        - The requested attribute of the link between \\p srcDevice and \\p dstDevice.\n \\param srcDevice     - The source device of the target link.\n \\param dstDevice     - The destination device of the target link.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDevice,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaCtxEnablePeerAccess,\n ::cudaCtxDisablePeerAccess,\n ::cudaCtxCanAccessPeer,\n ::cuDeviceGetP2PAttribute"]
    pub fn cudaDeviceGetP2PAttribute(
        value: *mut ::std::os::raw::c_int,
        attr: cudaDeviceP2PAttr,
        srcDevice: ::std::os::raw::c_int,
        dstDevice: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Select compute-device which best matches criteria\n\n Returns in \\p *device the device which has properties that best match\n \\p *prop.\n\n \\param device - Device with best match\n \\param prop   - Desired device properties\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaGetDeviceCount, ::cudaGetDevice, ::cudaSetDevice,\n ::cudaGetDeviceProperties"]
    pub fn cudaChooseDevice(
        device: *mut ::std::os::raw::c_int,
        prop: *const cudaDeviceProp,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Set device to be used for GPU executions\n\n Sets \\p device as the current device for the calling host thread.\n Valid device id's are 0 to (::cudaGetDeviceCount() - 1).\n\n Any device memory subsequently allocated from this host thread\n using ::cudaMalloc(), ::cudaMallocPitch() or ::cudaMallocArray()\n will be physically resident on \\p device.  Any host memory allocated\n from this host thread using ::cudaMallocHost() or ::cudaHostAlloc()\n or ::cudaHostRegister() will have its lifetime associated  with\n \\p device.  Any streams or events created from this host thread will\n be associated with \\p device.  Any kernels launched from this host\n thread using the <<<>>> operator or ::cudaLaunchKernel() will be executed\n on \\p device.\n\n This call may be made from any host thread, to any device, and at\n any time.  This function will do no synchronization with the previous\n or new device, and should be considered a very low overhead call.\n If the current context bound to the calling thread is not the primary context,\n this call will bind the primary context to the calling thread and all the\n subsequent memory allocations, stream and event creations, and kernel launches\n will be associated with the primary context. This function will not initialize\n the context until a runtime API requiring the context (such as ::cudaMalloc())\n is used. This function will not return an error if the device is in\n ::cudaComputeModeExclusiveProcess and is occupied by another process or\n if the device is in ::cudaComputeModeProhibited.\n\n \\param device - Device on which the active host thread should execute the\n device code.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaGetDeviceCount, ::cudaGetDevice, ::cudaGetDeviceProperties,\n ::cudaChooseDevice,\n ::cuCtxSetCurrent"]
    pub fn cudaSetDevice(device: ::std::os::raw::c_int) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns which device is currently being used\n\n Returns in \\p *device the current device for the calling host thread.\n\n \\param device - Returns the device on which the active host thread\n executes the device code.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaGetDeviceCount, ::cudaSetDevice, ::cudaGetDeviceProperties,\n ::cudaChooseDevice,\n ::cuCtxGetCurrent"]
    pub fn cudaGetDevice(device: *mut ::std::os::raw::c_int) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Set a list of devices that can be used for CUDA\n\n Sets a list of devices for CUDA execution in priority order using\n \\p device_arr. The parameter \\p len specifies the number of elements in the\n list.  CUDA will try devices from the list sequentially until it finds one\n that works.  If this function is not called, or if it is called with a \\p len\n of 0, then CUDA will go back to its default behavior of trying devices\n sequentially from a default list containing all of the available CUDA\n devices in the system. If a specified device ID in the list does not exist,\n this function will return ::cudaErrorInvalidDevice. If \\p len is not 0 and\n \\p device_arr is NULL or if \\p len exceeds the number of devices in\n the system, then ::cudaErrorInvalidValue is returned.\n\n \\param device_arr - List of devices to try\n \\param len        - Number of devices in specified list\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaGetDeviceCount, ::cudaSetDevice, ::cudaGetDeviceProperties,\n ::cudaSetDeviceFlags,\n ::cudaChooseDevice"]
    pub fn cudaSetValidDevices(
        device_arr: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets flags to be used for device executions\n\n Records \\p flags as the flags for the current device. If the current device\n has been set and that device has already been initialized, the previous flags\n are overwritten. If the current device has not been initialized, it is\n initialized with the provided flags. If no device has been made current to\n the calling thread, a default device is selected and initialized with the\n provided flags.\n\n The two LSBs of the \\p flags parameter can be used to control how the CPU\n thread interacts with the OS scheduler when waiting for results from the\n device.\n\n - ::cudaDeviceScheduleAuto: The default value if the \\p flags parameter is\n zero, uses a heuristic based on the number of active CUDA contexts in the\n process \\p C and the number of logical processors in the system \\p P. If\n \\p C \\> \\p P, then CUDA will yield to other OS threads when waiting for the\n device, otherwise CUDA will not yield while waiting for results and\n actively spin on the processor. Additionally, on Tegra devices,\n ::cudaDeviceScheduleAuto uses a heuristic based on the power profile of\n the platform and may choose ::cudaDeviceScheduleBlockingSync for low-powered\n devices.\n - ::cudaDeviceScheduleSpin: Instruct CUDA to actively spin when waiting for\n results from the device. This can decrease latency when waiting for the\n device, but may lower the performance of CPU threads if they are performing\n work in parallel with the CUDA thread.\n - ::cudaDeviceScheduleYield: Instruct CUDA to yield its thread when waiting\n for results from the device. This can increase latency when waiting for the\n device, but can increase the performance of CPU threads performing work in\n parallel with the device.\n - ::cudaDeviceScheduleBlockingSync: Instruct CUDA to block the CPU thread\n on a synchronization primitive when waiting for the device to finish work.\n - ::cudaDeviceBlockingSync: Instruct CUDA to block the CPU thread on a\n synchronization primitive when waiting for the device to finish work. <br>\n \\ref deprecated \"Deprecated:\" This flag was deprecated as of CUDA 4.0 and\n replaced with ::cudaDeviceScheduleBlockingSync.\n - ::cudaDeviceMapHost: This flag enables allocating pinned\n host memory that is accessible to the device. It is implicit for the\n runtime but may be absent if a context is created using the driver API.\n If this flag is not set, ::cudaHostGetDevicePointer() will always return\n a failure code.\n - ::cudaDeviceLmemResizeToMax: Instruct CUDA to not reduce local memory\n after resizing local memory for a kernel. This can prevent thrashing by\n local memory allocations when launching many kernels with high local\n memory usage at the cost of potentially increased memory usage. <br>\n \\ref deprecated \"Deprecated:\" This flag is deprecated and the behavior enabled\n by this flag is now the default and cannot be disabled.\n\n \\param flags - Parameters for device operation\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaGetDeviceFlags, ::cudaGetDeviceCount, ::cudaGetDevice, ::cudaGetDeviceProperties,\n ::cudaSetDevice, ::cudaSetValidDevices,\n ::cudaChooseDevice,\n ::cuDevicePrimaryCtxSetFlags"]
    pub fn cudaSetDeviceFlags(flags: ::std::os::raw::c_uint) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Gets the flags for the current device\n\n\n Returns in \\p flags the flags for the current device. If there is a current\n device for the calling thread, the flags for the device are returned. If\n there is no current device, the flags for the first device are returned,\n which may be the default flags.  Compare to the behavior of\n ::cudaSetDeviceFlags.\n\n Typically, the flags returned should match the behavior that will be seen\n if the calling thread uses a device after this call, without any change to\n the flags or current device inbetween by this or another thread.  Note that\n if the device is not initialized, it is possible for another thread to\n change the flags for the current device before it is initialized.\n Additionally, when using exclusive mode, if this thread has not requested a\n specific device, it may use a device other than the first device, contrary\n to the assumption made by this function.\n\n If a context has been created via the driver API and is current to the\n calling thread, the flags for that context are always returned.\n\n Flags returned by this function may specifically include ::cudaDeviceMapHost\n even though it is not accepted by ::cudaSetDeviceFlags because it is\n implicit in runtime API flags.  The reason for this is that the current\n context may have been created via the driver API in which case the flag is\n not implicit and may be unset.\n\n \\param flags - Pointer to store the device flags\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaGetDevice, ::cudaGetDeviceProperties,\n ::cudaSetDevice, ::cudaSetDeviceFlags,\n ::cuCtxGetFlags,\n ::cuDevicePrimaryCtxGetState"]
    pub fn cudaGetDeviceFlags(flags: *mut ::std::os::raw::c_uint) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Create an asynchronous stream\n\n Creates a new asynchronous stream.\n\n \\param pStream - Pointer to new stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaStreamCreateWithPriority,\n ::cudaStreamCreateWithFlags,\n ::cudaStreamGetPriority,\n ::cudaStreamGetFlags,\n ::cudaStreamQuery,\n ::cudaStreamSynchronize,\n ::cudaStreamWaitEvent,\n ::cudaStreamAddCallback,\n ::cudaStreamDestroy,\n ::cuStreamCreate"]
    pub fn cudaStreamCreate(pStream: *mut cudaStream_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Create an asynchronous stream\n\n Creates a new asynchronous stream.  The \\p flags argument determines the\n behaviors of the stream.  Valid values for \\p flags are\n - ::cudaStreamDefault: Default stream creation flag.\n - ::cudaStreamNonBlocking: Specifies that work running in the created\n   stream may run concurrently with work in stream 0 (the NULL stream), and that\n   the created stream should perform no implicit synchronization with stream 0.\n\n \\param pStream - Pointer to new stream identifier\n \\param flags   - Parameters for stream creation\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaStreamCreate,\n ::cudaStreamCreateWithPriority,\n ::cudaStreamGetFlags,\n ::cudaStreamQuery,\n ::cudaStreamSynchronize,\n ::cudaStreamWaitEvent,\n ::cudaStreamAddCallback,\n ::cudaStreamDestroy,\n ::cuStreamCreate"]
    pub fn cudaStreamCreateWithFlags(
        pStream: *mut cudaStream_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Create an asynchronous stream with the specified priority\n\n Creates a stream with the specified priority and returns a handle in \\p pStream.\n This API alters the scheduler priority of work in the stream. Work in a higher\n priority stream may preempt work already executing in a low priority stream.\n\n \\p priority follows a convention where lower numbers represent higher priorities.\n '0' represents default priority. The range of meaningful numerical priorities can\n be queried using ::cudaDeviceGetStreamPriorityRange. If the specified priority is\n outside the numerical range returned by ::cudaDeviceGetStreamPriorityRange,\n it will automatically be clamped to the lowest or the highest number in the range.\n\n \\param pStream  - Pointer to new stream identifier\n \\param flags    - Flags for stream creation. See ::cudaStreamCreateWithFlags for a list of valid flags that can be passed\n \\param priority - Priority of the stream. Lower numbers represent higher priorities.\n                   See ::cudaDeviceGetStreamPriorityRange for more information about\n                   the meaningful stream priorities that can be passed.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\note Stream priorities are supported only on GPUs\n with compute capability 3.5 or higher.\n\n \\note In the current implementation, only compute kernels launched in\n priority streams are affected by the stream's priority. Stream priorities have\n no effect on host-to-device and device-to-host memory operations.\n\n \\sa ::cudaStreamCreate,\n ::cudaStreamCreateWithFlags,\n ::cudaDeviceGetStreamPriorityRange,\n ::cudaStreamGetPriority,\n ::cudaStreamQuery,\n ::cudaStreamWaitEvent,\n ::cudaStreamAddCallback,\n ::cudaStreamSynchronize,\n ::cudaStreamDestroy,\n ::cuStreamCreateWithPriority"]
    pub fn cudaStreamCreateWithPriority(
        pStream: *mut cudaStream_t,
        flags: ::std::os::raw::c_uint,
        priority: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Query the priority of a stream\n\n Query the priority of a stream. The priority is returned in in \\p priority.\n Note that if the stream was created with a priority outside the meaningful\n numerical range returned by ::cudaDeviceGetStreamPriorityRange,\n this function returns the clamped priority.\n See ::cudaStreamCreateWithPriority for details about priority clamping.\n\n \\param hStream    - Handle to the stream to be queried\n \\param priority   - Pointer to a signed integer in which the stream's priority is returned\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaStreamCreateWithPriority,\n ::cudaDeviceGetStreamPriorityRange,\n ::cudaStreamGetFlags,\n ::cuStreamGetPriority"]
    pub fn cudaStreamGetPriority(
        hStream: cudaStream_t,
        priority: *mut ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Query the flags of a stream\n\n Query the flags of a stream. The flags are returned in \\p flags.\n See ::cudaStreamCreateWithFlags for a list of valid flags.\n\n \\param hStream - Handle to the stream to be queried\n \\param flags   - Pointer to an unsigned integer in which the stream's flags are returned\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaStreamCreateWithPriority,\n ::cudaStreamCreateWithFlags,\n ::cudaStreamGetPriority,\n ::cuStreamGetFlags"]
    pub fn cudaStreamGetFlags(
        hStream: cudaStream_t,
        flags: *mut ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Resets all persisting lines in cache to normal status.\n\n Resets all persisting lines in cache to normal status.\n Takes effect on function return.\n\n \\return\n ::cudaSuccess,\n \\notefnerr\n\n \\sa\n ::cudaAccessPolicyWindow"]
    pub fn cudaCtxResetPersistingL2Cache() -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies attributes from source stream to destination stream.\n\n Copies attributes from source stream \\p src to destination stream \\p dst.\n Both streams must have the same context.\n\n \\param[out] dst Destination stream\n \\param[in] src Source stream\n For attributes see ::cudaStreamAttrID\n\n \\return\n ::cudaSuccess,\n ::cudaErrorNotSupported\n \\notefnerr\n\n \\sa\n ::cudaAccessPolicyWindow"]
    pub fn cudaStreamCopyAttributes(dst: cudaStream_t, src: cudaStream_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Queries stream attribute.\n\n Queries attribute \\p attr from \\p hStream and stores it in corresponding\n member of \\p value_out.\n\n \\param[in] hStream\n \\param[in] attr\n \\param[out] value_out\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n\n \\sa\n ::cudaAccessPolicyWindow"]
    pub fn cudaStreamGetAttribute(
        hStream: cudaStream_t,
        attr: cudaLaunchAttributeID,
        value_out: *mut cudaLaunchAttributeValue,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets stream attribute.\n\n Sets attribute \\p attr on \\p hStream from corresponding attribute of\n \\p value. The updated attribute will be applied to subsequent work\n submitted to the stream. It will not affect previously submitted work.\n\n \\param[out] hStream\n \\param[in] attr\n \\param[in] value\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n\n \\sa\n ::cudaAccessPolicyWindow"]
    pub fn cudaStreamSetAttribute(
        hStream: cudaStream_t,
        attr: cudaLaunchAttributeID,
        value: *const cudaLaunchAttributeValue,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Destroys and cleans up an asynchronous stream\n\n Destroys and cleans up the asynchronous stream specified by \\p stream.\n\n In case the device is still doing work in the stream \\p stream\n when ::cudaStreamDestroy() is called, the function will return immediately\n and the resources associated with \\p stream will be released automatically\n once the device has completed all work in \\p stream.\n\n \\param stream - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n \\note_destroy_ub\n\n \\sa ::cudaStreamCreate,\n ::cudaStreamCreateWithFlags,\n ::cudaStreamQuery,\n ::cudaStreamWaitEvent,\n ::cudaStreamSynchronize,\n ::cudaStreamAddCallback,\n ::cuStreamDestroy"]
    pub fn cudaStreamDestroy(stream: cudaStream_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Make a compute stream wait on an event\n\n Makes all future work submitted to \\p stream wait for all work captured in\n \\p event.  See ::cudaEventRecord() for details on what is captured by an event.\n The synchronization will be performed efficiently on the device when applicable.\n \\p event may be from a different device than \\p stream.\n\n flags include:\n - ::cudaEventWaitDefault: Default event creation flag.\n - ::cudaEventWaitExternal: Event is captured in the graph as an external\n   event node when performing stream capture.\n\n \\param stream - Stream to wait\n \\param event  - Event to wait on\n \\param flags  - Parameters for the operation(See above)\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaStreamCreate, ::cudaStreamCreateWithFlags, ::cudaStreamQuery, ::cudaStreamSynchronize, ::cudaStreamAddCallback, ::cudaStreamDestroy,\n ::cuStreamWaitEvent"]
    pub fn cudaStreamWaitEvent(
        stream: cudaStream_t,
        event: cudaEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
#[doc = " Type of stream callback functions.\n \\param stream The stream as passed to ::cudaStreamAddCallback, may be NULL.\n \\param status ::cudaSuccess or any persistent error on the stream.\n \\param userData User parameter provided at registration."]
pub type cudaStreamCallback_t = ::std::option::Option<
    unsafe extern "C" fn(
        stream: cudaStream_t,
        status: cudaError_t,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " \\brief Add a callback to a compute stream\n\n \\note This function is slated for eventual deprecation and removal. If\n you do not require the callback to execute in case of a device error,\n consider using ::cudaLaunchHostFunc. Additionally, this function is not\n supported with ::cudaStreamBeginCapture and ::cudaStreamEndCapture, unlike\n ::cudaLaunchHostFunc.\n\n Adds a callback to be called on the host after all currently enqueued\n items in the stream have completed.  For each\n cudaStreamAddCallback call, a callback will be executed exactly once.\n The callback will block later work in the stream until it is finished.\n\n The callback may be passed ::cudaSuccess or an error code.  In the event\n of a device error, all subsequently executed callbacks will receive an\n appropriate ::cudaError_t.\n\n Callbacks must not make any CUDA API calls.  Attempting to use CUDA APIs\n may result in ::cudaErrorNotPermitted.  Callbacks must not perform any\n synchronization that may depend on outstanding device work or other callbacks\n that are not mandated to run earlier.  Callbacks without a mandated order\n (in independent streams) execute in undefined order and may be serialized.\n\n For the purposes of Unified Memory, callback execution makes a number of\n guarantees:\n <ul>\n   <li>The callback stream is considered idle for the duration of the\n   callback.  Thus, for example, a callback may always use memory attached\n   to the callback stream.</li>\n   <li>The start of execution of a callback has the same effect as\n   synchronizing an event recorded in the same stream immediately prior to\n   the callback.  It thus synchronizes streams which have been \"joined\"\n   prior to the callback.</li>\n   <li>Adding device work to any stream does not have the effect of making\n   the stream active until all preceding callbacks have executed.  Thus, for\n   example, a callback might use global attached memory even if work has\n   been added to another stream, if it has been properly ordered with an\n   event.</li>\n   <li>Completion of a callback does not cause a stream to become\n   active except as described above.  The callback stream will remain idle\n   if no device work follows the callback, and will remain idle across\n   consecutive callbacks without device work in between.  Thus, for example,\n   stream synchronization can be done by signaling from a callback at the\n   end of the stream.</li>\n </ul>\n\n \\param stream   - Stream to add callback to\n \\param callback - The function to call once preceding stream operations are complete\n \\param userData - User specified data to be passed to the callback function\n \\param flags    - Reserved for future use, must be 0\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorInvalidValue,\n ::cudaErrorNotSupported\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaStreamCreate, ::cudaStreamCreateWithFlags, ::cudaStreamQuery, ::cudaStreamSynchronize, ::cudaStreamWaitEvent, ::cudaStreamDestroy, ::cudaMallocManaged, ::cudaStreamAttachMemAsync,\n ::cudaLaunchHostFunc, ::cuStreamAddCallback"]
    pub fn cudaStreamAddCallback(
        stream: cudaStream_t,
        callback: cudaStreamCallback_t,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Waits for stream tasks to complete\n\n Blocks until \\p stream has completed all operations. If the\n ::cudaDeviceScheduleBlockingSync flag was set for this device,\n the host thread will block until the stream is finished with\n all of its tasks.\n\n \\param stream - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidResourceHandle\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaStreamCreate, ::cudaStreamCreateWithFlags, ::cudaStreamQuery, ::cudaStreamWaitEvent, ::cudaStreamAddCallback, ::cudaStreamDestroy,\n ::cuStreamSynchronize"]
    pub fn cudaStreamSynchronize(stream: cudaStream_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Queries an asynchronous stream for completion status\n\n Returns ::cudaSuccess if all operations in \\p stream have\n completed, or ::cudaErrorNotReady if not.\n\n For the purposes of Unified Memory, a return value of ::cudaSuccess\n is equivalent to having called ::cudaStreamSynchronize().\n\n \\param stream - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorNotReady,\n ::cudaErrorInvalidResourceHandle\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaStreamCreate, ::cudaStreamCreateWithFlags, ::cudaStreamWaitEvent, ::cudaStreamSynchronize, ::cudaStreamAddCallback, ::cudaStreamDestroy,\n ::cuStreamQuery"]
    pub fn cudaStreamQuery(stream: cudaStream_t) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaStreamAttachMemAsync(
        stream: cudaStream_t,
        devPtr: *mut ::std::os::raw::c_void,
        length: usize,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Begins graph capture on a stream\n\n Begin graph capture on \\p stream. When a stream is in capture mode, all operations\n pushed into the stream will not be executed, but will instead be captured into\n a graph, which will be returned via ::cudaStreamEndCapture. Capture may not be initiated\n if \\p stream is ::cudaStreamLegacy. Capture must be ended on the same stream in which\n it was initiated, and it may only be initiated if the stream is not already in capture\n mode. The capture mode may be queried via ::cudaStreamIsCapturing. A unique id\n representing the capture sequence may be queried via ::cudaStreamGetCaptureInfo.\n\n If \\p mode is not ::cudaStreamCaptureModeRelaxed, ::cudaStreamEndCapture must be\n called on this stream from the same thread.\n\n \\note Kernels captured using this API must not use texture and surface references.\n       Reading or writing through any texture or surface reference is undefined\n       behavior. This restriction does not apply to texture and surface objects.\n\n \\param stream - Stream in which to initiate capture\n \\param mode    - Controls the interaction of this capture sequence with other API\n                  calls that are potentially unsafe. For more details see\n                  ::cudaThreadExchangeStreamCaptureMode.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n\n \\sa\n ::cudaStreamCreate,\n ::cudaStreamIsCapturing,\n ::cudaStreamEndCapture,\n ::cudaThreadExchangeStreamCaptureMode"]
    pub fn cudaStreamBeginCapture(stream: cudaStream_t, mode: cudaStreamCaptureMode)
                                  -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Swaps the stream capture interaction mode for a thread\n\n Sets the calling thread's stream capture interaction mode to the value contained\n in \\p *mode, and overwrites \\p *mode with the previous mode for the thread. To\n facilitate deterministic behavior across function or module boundaries, callers\n are encouraged to use this API in a push-pop fashion: \\code\ncudaStreamCaptureMode mode = desiredMode;\ncudaThreadExchangeStreamCaptureMode(&mode);\n...\ncudaThreadExchangeStreamCaptureMode(&mode); // restore previous mode\n \\endcode\n\n During stream capture (see ::cudaStreamBeginCapture), some actions, such as a call\n to ::cudaMalloc, may be unsafe. In the case of ::cudaMalloc, the operation is\n not enqueued asynchronously to a stream, and is not observed by stream capture.\n Therefore, if the sequence of operations captured via ::cudaStreamBeginCapture\n depended on the allocation being replayed whenever the graph is launched, the\n captured graph would be invalid.\n\n Therefore, stream capture places restrictions on API calls that can be made within\n or concurrently to a ::cudaStreamBeginCapture-::cudaStreamEndCapture sequence. This\n behavior can be controlled via this API and flags to ::cudaStreamBeginCapture.\n\n A thread's mode is one of the following:\n - \\p cudaStreamCaptureModeGlobal: This is the default mode. If the local thread has\n   an ongoing capture sequence that was not initiated with\n   \\p cudaStreamCaptureModeRelaxed at \\p cuStreamBeginCapture, or if any other thread\n   has a concurrent capture sequence initiated with \\p cudaStreamCaptureModeGlobal,\n   this thread is prohibited from potentially unsafe API calls.\n - \\p cudaStreamCaptureModeThreadLocal: If the local thread has an ongoing capture\n   sequence not initiated with \\p cudaStreamCaptureModeRelaxed, it is prohibited\n   from potentially unsafe API calls. Concurrent capture sequences in other threads\n   are ignored.\n - \\p cudaStreamCaptureModeRelaxed: The local thread is not prohibited from potentially\n   unsafe API calls. Note that the thread is still prohibited from API calls which\n   necessarily conflict with stream capture, for example, attempting ::cudaEventQuery\n   on an event that was last recorded inside a capture sequence.\n\n \\param mode - Pointer to mode value to swap with the current mode\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n\n \\sa\n ::cudaStreamBeginCapture"]
    pub fn cudaThreadExchangeStreamCaptureMode(mode: *mut cudaStreamCaptureMode) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Ends capture on a stream, returning the captured graph\n\n End capture on \\p stream, returning the captured graph via \\p pGraph.\n Capture must have been initiated on \\p stream via a call to ::cudaStreamBeginCapture.\n If capture was invalidated, due to a violation of the rules of stream capture, then\n a NULL graph will be returned.\n\n If the \\p mode argument to ::cudaStreamBeginCapture was not\n ::cudaStreamCaptureModeRelaxed, this call must be from the same thread as\n ::cudaStreamBeginCapture.\n\n \\param stream - Stream to query\n \\param pGraph - The captured graph\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorStreamCaptureWrongThread\n \\notefnerr\n\n \\sa\n ::cudaStreamCreate,\n ::cudaStreamBeginCapture,\n ::cudaStreamIsCapturing"]
    pub fn cudaStreamEndCapture(stream: cudaStream_t, pGraph: *mut cudaGraph_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a stream's capture status\n\n Return the capture status of \\p stream via \\p pCaptureStatus. After a successful\n call, \\p *pCaptureStatus will contain one of the following:\n - ::cudaStreamCaptureStatusNone: The stream is not capturing.\n - ::cudaStreamCaptureStatusActive: The stream is capturing.\n - ::cudaStreamCaptureStatusInvalidated: The stream was capturing but an error\n   has invalidated the capture sequence. The capture sequence must be terminated\n   with ::cudaStreamEndCapture on the stream where it was initiated in order to\n   continue using \\p stream.\n\n Note that, if this is called on ::cudaStreamLegacy (the \"null stream\") while\n a blocking stream on the same device is capturing, it will return\n ::cudaErrorStreamCaptureImplicit and \\p *pCaptureStatus is unspecified\n after the call. The blocking stream capture is not invalidated.\n\n When a blocking stream is capturing, the legacy stream is in an\n unusable state until the blocking stream capture is terminated. The legacy\n stream is not supported for stream capture, but attempted use would have an\n implicit dependency on the capturing stream(s).\n\n \\param stream         - Stream to query\n \\param pCaptureStatus - Returns the stream's capture status\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorStreamCaptureImplicit\n \\notefnerr\n\n \\sa\n ::cudaStreamCreate,\n ::cudaStreamBeginCapture,\n ::cudaStreamEndCapture"]
    pub fn cudaStreamIsCapturing(
        stream: cudaStream_t,
        pCaptureStatus: *mut cudaStreamCaptureStatus,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Query capture status of a stream\n\n Note there is a later version of this API, ::cudaStreamGetCaptureInfo_v2. It will\n supplant this version in 12.0, which is retained for minor version compatibility.\n\n Query the capture status of a stream and get a unique id representing\n the capture sequence over the lifetime of the process.\n\n If called on ::cudaStreamLegacy (the \"null stream\") while a stream not created\n with ::cudaStreamNonBlocking is capturing, returns ::cudaErrorStreamCaptureImplicit.\n\n A valid id is returned only if both of the following are true:\n - the call returns ::cudaSuccess\n - captureStatus is set to ::cudaStreamCaptureStatusActive\n\n \\param stream         - Stream to query\n \\param pCaptureStatus - Returns the stream's capture status\n \\param pId            - Returns the unique id of the capture sequence\n\n \\return\n ::cudaSuccess,\n ::cudaErrorStreamCaptureImplicit\n \\notefnerr\n\n \\sa\n ::cudaStreamGetCaptureInfo_v2,\n ::cudaStreamBeginCapture,\n ::cudaStreamIsCapturing"]
    pub fn cudaStreamGetCaptureInfo(
        stream: cudaStream_t,
        pCaptureStatus: *mut cudaStreamCaptureStatus,
        pId: *mut ::std::os::raw::c_ulonglong,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Query a stream's capture state (11.3+)\n\n Query stream state related to stream capture.\n\n If called on ::cudaStreamLegacy (the \"null stream\") while a stream not created\n with ::cudaStreamNonBlocking is capturing, returns ::cudaErrorStreamCaptureImplicit.\n\n Valid data (other than capture status) is returned only if both of the following are true:\n - the call returns cudaSuccess\n - the returned capture status is ::cudaStreamCaptureStatusActive\n\n This version of cudaStreamGetCaptureInfo is introduced in CUDA 11.3 and will supplant the\n previous version ::cudaStreamGetCaptureInfo in 12.0. Developers requiring compatibility\n across minor versions to CUDA 11.0 (driver version 445) can do one of the following:\n - Use the older version of the API, ::cudaStreamGetCaptureInfo\n - Pass null for all of \\p graph_out, \\p dependencies_out, and \\p numDependencies_out.\n\n \\param stream - The stream to query\n \\param captureStatus_out - Location to return the capture status of the stream; required\n \\param id_out - Optional location to return an id for the capture sequence, which is\n           unique over the lifetime of the process\n \\param graph_out - Optional location to return the graph being captured into. All\n           operations other than destroy and node removal are permitted on the graph\n           while the capture sequence is in progress. This API does not transfer\n           ownership of the graph, which is transferred or destroyed at\n           ::cudaStreamEndCapture. Note that the graph handle may be invalidated before\n           end of capture for certain errors. Nodes that are or become\n           unreachable from the original stream at ::cudaStreamEndCapture due to direct\n           actions on the graph do not trigger ::cudaErrorStreamCaptureUnjoined.\n \\param dependencies_out - Optional location to store a pointer to an array of nodes.\n           The next node to be captured in the stream will depend on this set of nodes,\n           absent operations such as event wait which modify this set. The array pointer\n           is valid until the next API call which operates on the stream or until end of\n           capture. The node handles may be copied out and are valid until they or the\n           graph is destroyed. The driver-owned array may also be passed directly to\n           APIs that operate on the graph (not the stream) without copying.\n \\param numDependencies_out - Optional location to store the size of the array\n           returned in dependencies_out.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorStreamCaptureImplicit\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cudaStreamGetCaptureInfo,\n ::cudaStreamBeginCapture,\n ::cudaStreamIsCapturing,\n ::cudaStreamUpdateCaptureDependencies"]
    pub fn cudaStreamGetCaptureInfo_v2(
        stream: cudaStream_t,
        captureStatus_out: *mut cudaStreamCaptureStatus,
        id_out: *mut ::std::os::raw::c_ulonglong,
        graph_out: *mut cudaGraph_t,
        dependencies_out: *mut *const cudaGraphNode_t,
        numDependencies_out: *mut usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Update the set of dependencies in a capturing stream (11.3+)\n\n Modifies the dependency set of a capturing stream. The dependency set is the set\n of nodes that the next captured node in the stream will depend on.\n\n Valid flags are ::cudaStreamAddCaptureDependencies and\n ::cudaStreamSetCaptureDependencies. These control whether the set passed to\n the API is added to the existing set or replaces it. A flags value of 0 defaults\n to ::cudaStreamAddCaptureDependencies.\n\n Nodes that are removed from the dependency set via this API do not result in\n ::cudaErrorStreamCaptureUnjoined if they are unreachable from the stream at\n ::cudaStreamEndCapture.\n\n Returns ::cudaErrorIllegalState if the stream is not capturing.\n\n This API is new in CUDA 11.3. Developers requiring compatibility across minor\n versions of the CUDA driver to 11.0 should not use this API or provide a fallback.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorIllegalState\n \\notefnerr\n\n \\sa\n ::cudaStreamBeginCapture,\n ::cudaStreamGetCaptureInfo,\n ::cudaStreamGetCaptureInfo_v2"]
    pub fn cudaStreamUpdateCaptureDependencies(
        stream: cudaStream_t,
        dependencies: *mut cudaGraphNode_t,
        numDependencies: usize,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates an event object\n\n Creates an event object for the current device using ::cudaEventDefault.\n\n \\param event - Newly created event\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorLaunchFailure,\n ::cudaErrorMemoryAllocation\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaEventCreate(cudaEvent_t*, unsigned int) \"cudaEventCreate (C++ API)\",\n ::cudaEventCreateWithFlags, ::cudaEventRecord, ::cudaEventQuery,\n ::cudaEventSynchronize, ::cudaEventDestroy, ::cudaEventElapsedTime,\n ::cudaStreamWaitEvent,\n ::cuEventCreate"]
    pub fn cudaEventCreate(event: *mut cudaEvent_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates an event object with the specified flags\n\n Creates an event object for the current device with the specified flags. Valid\n flags include:\n - ::cudaEventDefault: Default event creation flag.\n - ::cudaEventBlockingSync: Specifies that event should use blocking\n   synchronization. A host thread that uses ::cudaEventSynchronize() to wait\n   on an event created with this flag will block until the event actually\n   completes.\n - ::cudaEventDisableTiming: Specifies that the created event does not need\n   to record timing data.  Events created with this flag specified and\n   the ::cudaEventBlockingSync flag not specified will provide the best\n   performance when used with ::cudaStreamWaitEvent() and ::cudaEventQuery().\n - ::cudaEventInterprocess: Specifies that the created event may be used as an\n   interprocess event by ::cudaIpcGetEventHandle(). ::cudaEventInterprocess must\n   be specified along with ::cudaEventDisableTiming.\n\n \\param event - Newly created event\n \\param flags - Flags for new event\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorLaunchFailure,\n ::cudaErrorMemoryAllocation\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaEventCreate(cudaEvent_t*) \"cudaEventCreate (C API)\",\n ::cudaEventSynchronize, ::cudaEventDestroy, ::cudaEventElapsedTime,\n ::cudaStreamWaitEvent,\n ::cuEventCreate"]
    pub fn cudaEventCreateWithFlags(
        event: *mut cudaEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Records an event\n\n Captures in \\p event the contents of \\p stream at the time of this call.\n \\p event and \\p stream must be on the same CUDA context.\n Calls such as ::cudaEventQuery() or ::cudaStreamWaitEvent() will then\n examine or wait for completion of the work that was captured. Uses of\n \\p stream after this call do not modify \\p event. See note on default\n stream behavior for what is captured in the default case.\n\n ::cudaEventRecord() can be called multiple times on the same event and\n will overwrite the previously captured state. Other APIs such as\n ::cudaStreamWaitEvent() use the most recently captured state at the time\n of the API call, and are not affected by later calls to\n ::cudaEventRecord(). Before the first call to ::cudaEventRecord(), an\n event represents an empty set of work, so for example ::cudaEventQuery()\n would return ::cudaSuccess.\n\n \\param event  - Event to record\n \\param stream - Stream in which to record event\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorLaunchFailure\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaEventCreate(cudaEvent_t*) \"cudaEventCreate (C API)\",\n ::cudaEventCreateWithFlags, ::cudaEventQuery,\n ::cudaEventSynchronize, ::cudaEventDestroy, ::cudaEventElapsedTime,\n ::cudaStreamWaitEvent,\n ::cudaEventRecordWithFlags,\n ::cuEventRecord"]
    pub fn cudaEventRecord(event: cudaEvent_t, stream: cudaStream_t) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaEventRecordWithFlags(
        event: cudaEvent_t,
        stream: cudaStream_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Queries an event's status\n\n Queries the status of all work currently captured by \\p event. See\n ::cudaEventRecord() for details on what is captured by an event.\n\n Returns ::cudaSuccess if all captured work has been completed, or\n ::cudaErrorNotReady if any captured work is incomplete.\n\n For the purposes of Unified Memory, a return value of ::cudaSuccess\n is equivalent to having called ::cudaEventSynchronize().\n\n \\param event - Event to query\n\n \\return\n ::cudaSuccess,\n ::cudaErrorNotReady,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorLaunchFailure\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaEventCreate(cudaEvent_t*) \"cudaEventCreate (C API)\",\n ::cudaEventCreateWithFlags, ::cudaEventRecord,\n ::cudaEventSynchronize, ::cudaEventDestroy, ::cudaEventElapsedTime,\n ::cuEventQuery"]
    pub fn cudaEventQuery(event: cudaEvent_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Waits for an event to complete\n\n Waits until the completion of all work currently captured in \\p event.\n See ::cudaEventRecord() for details on what is captured by an event.\n\n Waiting for an event that was created with the ::cudaEventBlockingSync\n flag will cause the calling CPU thread to block until the event has\n been completed by the device.  If the ::cudaEventBlockingSync flag has\n not been set, then the CPU thread will busy-wait until the event has\n been completed by the device.\n\n \\param event - Event to wait for\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorLaunchFailure\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaEventCreate(cudaEvent_t*) \"cudaEventCreate (C API)\",\n ::cudaEventCreateWithFlags, ::cudaEventRecord,\n ::cudaEventQuery, ::cudaEventDestroy, ::cudaEventElapsedTime,\n ::cuEventSynchronize"]
    pub fn cudaEventSynchronize(event: cudaEvent_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Destroys an event object\n\n Destroys the event specified by \\p event.\n\n An event may be destroyed before it is complete (i.e., while\n ::cudaEventQuery() would return ::cudaErrorNotReady). In this case, the\n call does not block on completion of the event, and any associated\n resources will automatically be released asynchronously at completion.\n\n \\param event - Event to destroy\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorLaunchFailure\n \\notefnerr\n \\note_init_rt\n \\note_callback\n \\note_destroy_ub\n\n \\sa \\ref ::cudaEventCreate(cudaEvent_t*) \"cudaEventCreate (C API)\",\n ::cudaEventCreateWithFlags, ::cudaEventQuery,\n ::cudaEventSynchronize, ::cudaEventRecord, ::cudaEventElapsedTime,\n ::cuEventDestroy"]
    pub fn cudaEventDestroy(event: cudaEvent_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Computes the elapsed time between events\n\n Computes the elapsed time between two events (in milliseconds with a\n resolution of around 0.5 microseconds).\n\n If either event was last recorded in a non-NULL stream, the resulting time\n may be greater than expected (even if both used the same stream handle). This\n happens because the ::cudaEventRecord() operation takes place asynchronously\n and there is no guarantee that the measured latency is actually just between\n the two events. Any number of other different stream operations could execute\n in between the two measured events, thus altering the timing in a significant\n way.\n\n If ::cudaEventRecord() has not been called on either event, then\n ::cudaErrorInvalidResourceHandle is returned. If ::cudaEventRecord() has been\n called on both events but one or both of them has not yet been completed\n (that is, ::cudaEventQuery() would return ::cudaErrorNotReady on at least one\n of the events), ::cudaErrorNotReady is returned. If either event was created\n with the ::cudaEventDisableTiming flag, then this function will return\n ::cudaErrorInvalidResourceHandle.\n\n \\param ms    - Time between \\p start and \\p end in ms\n \\param start - Starting event\n \\param end   - Ending event\n\n \\return\n ::cudaSuccess,\n ::cudaErrorNotReady,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorLaunchFailure,\n ::cudaErrorUnknown\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaEventCreate(cudaEvent_t*) \"cudaEventCreate (C API)\",\n ::cudaEventCreateWithFlags, ::cudaEventQuery,\n ::cudaEventSynchronize, ::cudaEventDestroy, ::cudaEventRecord,\n ::cuEventElapsedTime"]
    pub fn cudaEventElapsedTime(ms: *mut f32, start: cudaEvent_t, end: cudaEvent_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Imports an external memory object\n\n Imports an externally allocated memory object and returns\n a handle to that in \\p extMem_out.\n\n The properties of the handle being imported must be described in\n \\p memHandleDesc. The ::cudaExternalMemoryHandleDesc structure\n is defined as follows:\n\n \\code\ntypedef struct cudaExternalMemoryHandleDesc_st {\ncudaExternalMemoryHandleType type;\nunion {\nint fd;\nstruct {\nvoid *handle;\nconst void *name;\n} win32;\nconst void *nvSciBufObject;\n} handle;\nunsigned long long size;\nunsigned int flags;\n} cudaExternalMemoryHandleDesc;\n \\endcode\n\n where ::cudaExternalMemoryHandleDesc::type specifies the type\n of handle being imported. ::cudaExternalMemoryHandleType is\n defined as:\n\n \\code\ntypedef enum cudaExternalMemoryHandleType_enum {\ncudaExternalMemoryHandleTypeOpaqueFd         = 1,\ncudaExternalMemoryHandleTypeOpaqueWin32      = 2,\ncudaExternalMemoryHandleTypeOpaqueWin32Kmt   = 3,\ncudaExternalMemoryHandleTypeD3D12Heap        = 4,\ncudaExternalMemoryHandleTypeD3D12Resource    = 5,\ncudaExternalMemoryHandleTypeD3D11Resource    = 6,\ncudaExternalMemoryHandleTypeD3D11ResourceKmt = 7,\ncudaExternalMemoryHandleTypeNvSciBuf         = 8\n} cudaExternalMemoryHandleType;\n \\endcode\n\n If ::cudaExternalMemoryHandleDesc::type is\n ::cudaExternalMemoryHandleTypeOpaqueFd, then\n ::cudaExternalMemoryHandleDesc::handle::fd must be a valid\n file descriptor referencing a memory object. Ownership of\n the file descriptor is transferred to the CUDA driver when the\n handle is imported successfully. Performing any operations on the\n file descriptor after it is imported results in undefined behavior.\n\n If ::cudaExternalMemoryHandleDesc::type is\n ::cudaExternalMemoryHandleTypeOpaqueWin32, then exactly one\n of ::cudaExternalMemoryHandleDesc::handle::win32::handle and\n ::cudaExternalMemoryHandleDesc::handle::win32::name must not be\n NULL. If ::cudaExternalMemoryHandleDesc::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n references a memory object. Ownership of this handle is\n not transferred to CUDA after the import operation, so the\n application must release the handle using the appropriate system\n call. If ::cudaExternalMemoryHandleDesc::handle::win32::name\n is not NULL, then it must point to a NULL-terminated array of\n UTF-16 characters that refers to a memory object.\n\n If ::cudaExternalMemoryHandleDesc::type is\n ::cudaExternalMemoryHandleTypeOpaqueWin32Kmt, then\n ::cudaExternalMemoryHandleDesc::handle::win32::handle must\n be non-NULL and\n ::cudaExternalMemoryHandleDesc::handle::win32::name\n must be NULL. The handle specified must be a globally shared KMT\n handle. This handle does not hold a reference to the underlying\n object, and thus will be invalid when all references to the\n memory object are destroyed.\n\n If ::cudaExternalMemoryHandleDesc::type is\n ::cudaExternalMemoryHandleTypeD3D12Heap, then exactly one\n of ::cudaExternalMemoryHandleDesc::handle::win32::handle and\n ::cudaExternalMemoryHandleDesc::handle::win32::name must not be\n NULL. If ::cudaExternalMemoryHandleDesc::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n is returned by ID3D12Device::CreateSharedHandle when referring to a\n ID3D12Heap object. This handle holds a reference to the underlying\n object. If ::cudaExternalMemoryHandleDesc::handle::win32::name\n is not NULL, then it must point to a NULL-terminated array of\n UTF-16 characters that refers to a ID3D12Heap object.\n\n If ::cudaExternalMemoryHandleDesc::type is\n ::cudaExternalMemoryHandleTypeD3D12Resource, then exactly one\n of ::cudaExternalMemoryHandleDesc::handle::win32::handle and\n ::cudaExternalMemoryHandleDesc::handle::win32::name must not be\n NULL. If ::cudaExternalMemoryHandleDesc::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n is returned by ID3D12Device::CreateSharedHandle when referring to a\n ID3D12Resource object. This handle holds a reference to the\n underlying object. If\n ::cudaExternalMemoryHandleDesc::handle::win32::name\n is not NULL, then it must point to a NULL-terminated array of\n UTF-16 characters that refers to a ID3D12Resource object.\n\n If ::cudaExternalMemoryHandleDesc::type is\n ::cudaExternalMemoryHandleTypeD3D11Resource,then exactly one\n of ::cudaExternalMemoryHandleDesc::handle::win32::handle and\n ::cudaExternalMemoryHandleDesc::handle::win32::name must not be\n NULL. If ::cudaExternalMemoryHandleDesc::handle::win32::handle is\n not NULL, then it must represent a valid shared NT handle that is\n returned by  IDXGIResource1::CreateSharedHandle when referring to a\n ID3D11Resource object. If\n ::cudaExternalMemoryHandleDesc::handle::win32::name\n is not NULL, then it must point to a NULL-terminated array of\n UTF-16 characters that refers to a ID3D11Resource object.\n\n If ::cudaExternalMemoryHandleDesc::type is\n ::cudaExternalMemoryHandleTypeD3D11ResourceKmt, then\n ::cudaExternalMemoryHandleDesc::handle::win32::handle must\n be non-NULL and ::cudaExternalMemoryHandleDesc::handle::win32::name\n must be NULL. The handle specified must be a valid shared KMT\n handle that is returned by IDXGIResource::GetSharedHandle when\n referring to a ID3D11Resource object.\n\n If ::cudaExternalMemoryHandleDesc::type is\n ::cudaExternalMemoryHandleTypeNvSciBuf, then\n ::cudaExternalMemoryHandleDesc::handle::nvSciBufObject must be NON-NULL\n and reference a valid NvSciBuf object.\n If the NvSciBuf object imported into CUDA is also mapped by other drivers, then the\n application must use ::cudaWaitExternalSemaphoresAsync or ::cudaSignalExternalSemaphoresAsync\n as approprriate barriers to maintain coherence between CUDA and the other drivers.\n See ::cudaExternalSemaphoreWaitSkipNvSciBufMemSync and ::cudaExternalSemaphoreSignalSkipNvSciBufMemSync\n for memory synchronization.\n\n The size of the memory object must be specified in\n ::cudaExternalMemoryHandleDesc::size.\n\n Specifying the flag ::cudaExternalMemoryDedicated in\n ::cudaExternalMemoryHandleDesc::flags indicates that the\n resource is a dedicated resource. The definition of what a\n dedicated resource is outside the scope of this extension.\n This flag must be set if ::cudaExternalMemoryHandleDesc::type\n is one of the following:\n ::cudaExternalMemoryHandleTypeD3D12Resource\n ::cudaExternalMemoryHandleTypeD3D11Resource\n ::cudaExternalMemoryHandleTypeD3D11ResourceKmt\n\n \\param extMem_out    - Returned handle to an external memory object\n \\param memHandleDesc - Memory import handle descriptor\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\note If the Vulkan memory imported into CUDA is mapped on the CPU then the\n application must use vkInvalidateMappedMemoryRanges/vkFlushMappedMemoryRanges\n as well as appropriate Vulkan pipeline barriers to maintain coherence between\n CPU and GPU. For more information on these APIs, please refer to \"Synchronization\n and Cache Control\" chapter from Vulkan specification.\n\n\n \\sa ::cudaDestroyExternalMemory,\n ::cudaExternalMemoryGetMappedBuffer,\n ::cudaExternalMemoryGetMappedMipmappedArray"]
    pub fn cudaImportExternalMemory(
        extMem_out: *mut cudaExternalMemory_t,
        memHandleDesc: *const cudaExternalMemoryHandleDesc,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Maps a buffer onto an imported memory object\n\n Maps a buffer onto an imported memory object and returns a device\n pointer in \\p devPtr.\n\n The properties of the buffer being mapped must be described in\n \\p bufferDesc. The ::cudaExternalMemoryBufferDesc structure is\n defined as follows:\n\n \\code\ntypedef struct cudaExternalMemoryBufferDesc_st {\nunsigned long long offset;\nunsigned long long size;\nunsigned int flags;\n} cudaExternalMemoryBufferDesc;\n \\endcode\n\n where ::cudaExternalMemoryBufferDesc::offset is the offset in\n the memory object where the buffer's base address is.\n ::cudaExternalMemoryBufferDesc::size is the size of the buffer.\n ::cudaExternalMemoryBufferDesc::flags must be zero.\n\n The offset and size have to be suitably aligned to match the\n requirements of the external API. Mapping two buffers whose ranges\n overlap may or may not result in the same virtual address being\n returned for the overlapped portion. In such cases, the application\n must ensure that all accesses to that region from the GPU are\n volatile. Otherwise writes made via one address are not guaranteed\n to be visible via the other address, even if they're issued by the\n same thread. It is recommended that applications map the combined\n range instead of mapping separate buffers and then apply the\n appropriate offsets to the returned pointer to derive the\n individual buffers.\n\n The returned pointer \\p devPtr must be freed using ::cudaFree.\n\n \\param devPtr     - Returned device pointer to buffer\n \\param extMem     - Handle to external memory object\n \\param bufferDesc - Buffer descriptor\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaImportExternalMemory,\n ::cudaDestroyExternalMemory,\n ::cudaExternalMemoryGetMappedMipmappedArray"]
    pub fn cudaExternalMemoryGetMappedBuffer(
        devPtr: *mut *mut ::std::os::raw::c_void,
        extMem: cudaExternalMemory_t,
        bufferDesc: *const cudaExternalMemoryBufferDesc,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Maps a CUDA mipmapped array onto an external memory object\n\n Maps a CUDA mipmapped array onto an external object and returns a\n handle to it in \\p mipmap.\n\n The properties of the CUDA mipmapped array being mapped must be\n described in \\p mipmapDesc. The structure\n ::cudaExternalMemoryMipmappedArrayDesc is defined as follows:\n\n \\code\ntypedef struct cudaExternalMemoryMipmappedArrayDesc_st {\nunsigned long long offset;\ncudaChannelFormatDesc formatDesc;\ncudaExtent extent;\nunsigned int flags;\nunsigned int numLevels;\n} cudaExternalMemoryMipmappedArrayDesc;\n \\endcode\n\n where ::cudaExternalMemoryMipmappedArrayDesc::offset is the\n offset in the memory object where the base level of the mipmap\n chain is.\n ::cudaExternalMemoryMipmappedArrayDesc::formatDesc describes the\n format of the data.\n ::cudaExternalMemoryMipmappedArrayDesc::extent specifies the\n dimensions of the base level of the mipmap chain.\n ::cudaExternalMemoryMipmappedArrayDesc::flags are flags associated\n with CUDA mipmapped arrays. For further details, please refer to\n the documentation for ::cudaMalloc3DArray. Note that if the mipmapped\n array is bound as a color target in the graphics API, then the flag\n ::cudaArrayColorAttachment must be specified in\n ::cudaExternalMemoryMipmappedArrayDesc::flags.\n ::cudaExternalMemoryMipmappedArrayDesc::numLevels specifies\n the total number of levels in the mipmap chain.\n\n The returned CUDA mipmapped array must be freed using ::cudaFreeMipmappedArray.\n\n \\param mipmap     - Returned CUDA mipmapped array\n \\param extMem     - Handle to external memory object\n \\param mipmapDesc - CUDA array descriptor\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n \\note_init_rt\n \\note_callback\n \\note On Tegra devices, this API will always attempt to do a compressed mapping when the ::cudaExternalMemoryHandleDesc::type is\n ::cudaExternalMemoryHandleTypeOpaqueFd\n\n \\sa ::cudaImportExternalMemory,\n ::cudaDestroyExternalMemory,\n ::cudaExternalMemoryGetMappedBuffer\n\n \\note If ::cudaExternalMemoryHandleDesc::type is\n ::cudaExternalMemoryHandleTypeNvSciBuf, then\n ::cudaExternalMemoryMipmappedArrayDesc::numLevels must not be greater than 1."]
    pub fn cudaExternalMemoryGetMappedMipmappedArray(
        mipmap: *mut cudaMipmappedArray_t,
        extMem: cudaExternalMemory_t,
        mipmapDesc: *const cudaExternalMemoryMipmappedArrayDesc,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Destroys an external memory object.\n\n Destroys the specified external memory object. Any existing buffers\n and CUDA mipmapped arrays mapped onto this object must no longer be\n used and must be explicitly freed using ::cudaFree and\n ::cudaFreeMipmappedArray respectively.\n\n \\param extMem - External memory object to be destroyed\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n \\note_init_rt\n \\note_callback\n \\note_destroy_ub\n\n \\sa ::cudaImportExternalMemory,\n ::cudaExternalMemoryGetMappedBuffer,\n ::cudaExternalMemoryGetMappedMipmappedArray"]
    pub fn cudaDestroyExternalMemory(extMem: cudaExternalMemory_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Imports an external semaphore\n\n Imports an externally allocated synchronization object and returns\n a handle to that in \\p extSem_out.\n\n The properties of the handle being imported must be described in\n \\p semHandleDesc. The ::cudaExternalSemaphoreHandleDesc is defined\n as follows:\n\n \\code\ntypedef struct cudaExternalSemaphoreHandleDesc_st {\ncudaExternalSemaphoreHandleType type;\nunion {\nint fd;\nstruct {\nvoid *handle;\nconst void *name;\n} win32;\nconst void* NvSciSyncObj;\n} handle;\nunsigned int flags;\n} cudaExternalSemaphoreHandleDesc;\n \\endcode\n\n where ::cudaExternalSemaphoreHandleDesc::type specifies the type of\n handle being imported. ::cudaExternalSemaphoreHandleType is defined\n as:\n\n \\code\ntypedef enum cudaExternalSemaphoreHandleType_enum {\ncudaExternalSemaphoreHandleTypeOpaqueFd                = 1,\ncudaExternalSemaphoreHandleTypeOpaqueWin32             = 2,\ncudaExternalSemaphoreHandleTypeOpaqueWin32Kmt          = 3,\ncudaExternalSemaphoreHandleTypeD3D12Fence              = 4,\ncudaExternalSemaphoreHandleTypeD3D11Fence              = 5,\ncudaExternalSemaphoreHandleTypeNvSciSync               = 6,\ncudaExternalSemaphoreHandleTypeKeyedMutex              = 7,\ncudaExternalSemaphoreHandleTypeKeyedMutexKmt           = 8,\ncudaExternalSemaphoreHandleTypeTimelineSemaphoreFd     = 9,\ncudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32  = 10\n} cudaExternalSemaphoreHandleType;\n \\endcode\n\n If ::cudaExternalSemaphoreHandleDesc::type is\n ::cudaExternalSemaphoreHandleTypeOpaqueFd, then\n ::cudaExternalSemaphoreHandleDesc::handle::fd must be a valid file\n descriptor referencing a synchronization object. Ownership of the\n file descriptor is transferred to the CUDA driver when the handle\n is imported successfully. Performing any operations on the file\n descriptor after it is imported results in undefined behavior.\n\n If ::cudaExternalSemaphoreHandleDesc::type is\n ::cudaExternalSemaphoreHandleTypeOpaqueWin32, then exactly one of\n ::cudaExternalSemaphoreHandleDesc::handle::win32::handle and\n ::cudaExternalSemaphoreHandleDesc::handle::win32::name must not be\n NULL. If ::cudaExternalSemaphoreHandleDesc::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n references a synchronization object. Ownership of this handle is\n not transferred to CUDA after the import operation, so the\n application must release the handle using the appropriate system\n call. If ::cudaExternalSemaphoreHandleDesc::handle::win32::name is\n not NULL, then it must name a valid synchronization object.\n\n If ::cudaExternalSemaphoreHandleDesc::type is\n ::cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt, then\n ::cudaExternalSemaphoreHandleDesc::handle::win32::handle must be\n non-NULL and ::cudaExternalSemaphoreHandleDesc::handle::win32::name\n must be NULL. The handle specified must be a globally shared KMT\n handle. This handle does not hold a reference to the underlying\n object, and thus will be invalid when all references to the\n synchronization object are destroyed.\n\n If ::cudaExternalSemaphoreHandleDesc::type is\n ::cudaExternalSemaphoreHandleTypeD3D12Fence, then exactly one of\n ::cudaExternalSemaphoreHandleDesc::handle::win32::handle and\n ::cudaExternalSemaphoreHandleDesc::handle::win32::name must not be\n NULL. If ::cudaExternalSemaphoreHandleDesc::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n is returned by ID3D12Device::CreateSharedHandle when referring to a\n ID3D12Fence object. This handle holds a reference to the underlying\n object. If ::cudaExternalSemaphoreHandleDesc::handle::win32::name\n is not NULL, then it must name a valid synchronization object that\n refers to a valid ID3D12Fence object.\n\n If ::cudaExternalSemaphoreHandleDesc::type is\n ::cudaExternalSemaphoreHandleTypeD3D11Fence, then exactly one of\n ::cudaExternalSemaphoreHandleDesc::handle::win32::handle and\n ::cudaExternalSemaphoreHandleDesc::handle::win32::name must not be\n NULL. If ::cudaExternalSemaphoreHandleDesc::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n is returned by ID3D11Fence::CreateSharedHandle. If\n ::cudaExternalSemaphoreHandleDesc::handle::win32::name\n is not NULL, then it must name a valid synchronization object that\n refers to a valid ID3D11Fence object.\n\n If ::cudaExternalSemaphoreHandleDesc::type is\n ::cudaExternalSemaphoreHandleTypeNvSciSync, then\n ::cudaExternalSemaphoreHandleDesc::handle::nvSciSyncObj\n represents a valid NvSciSyncObj.\n\n ::cudaExternalSemaphoreHandleTypeKeyedMutex, then exactly one of\n ::cudaExternalSemaphoreHandleDesc::handle::win32::handle and\n ::cudaExternalSemaphoreHandleDesc::handle::win32::name must not be\n NULL. If ::cudaExternalSemaphoreHandleDesc::handle::win32::handle\n is not NULL, then it represent a valid shared NT handle that\n is returned by IDXGIResource1::CreateSharedHandle when referring to\n a IDXGIKeyedMutex object.\n\n If ::cudaExternalSemaphoreHandleDesc::type is\n ::cudaExternalSemaphoreHandleTypeKeyedMutexKmt, then\n ::cudaExternalSemaphoreHandleDesc::handle::win32::handle must be\n non-NULL and ::cudaExternalSemaphoreHandleDesc::handle::win32::name\n must be NULL. The handle specified must represent a valid KMT\n handle that is returned by IDXGIResource::GetSharedHandle when\n referring to a IDXGIKeyedMutex object.\n\n If ::cudaExternalSemaphoreHandleDesc::type is\n ::cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd, then\n ::cudaExternalSemaphoreHandleDesc::handle::fd must be a valid file\n descriptor referencing a synchronization object. Ownership of the\n file descriptor is transferred to the CUDA driver when the handle\n is imported successfully. Performing any operations on the file\n descriptor after it is imported results in undefined behavior.\n\n If ::cudaExternalSemaphoreHandleDesc::type is\n ::cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32, then exactly one of\n ::cudaExternalSemaphoreHandleDesc::handle::win32::handle and\n ::cudaExternalSemaphoreHandleDesc::handle::win32::name must not be\n NULL. If ::cudaExternalSemaphoreHandleDesc::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n references a synchronization object. Ownership of this handle is\n not transferred to CUDA after the import operation, so the\n application must release the handle using the appropriate system\n call. If ::cudaExternalSemaphoreHandleDesc::handle::win32::name is\n not NULL, then it must name a valid synchronization object.\n\n \\param extSem_out    - Returned handle to an external semaphore\n \\param semHandleDesc - Semaphore import handle descriptor\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDestroyExternalSemaphore,\n ::cudaSignalExternalSemaphoresAsync,\n ::cudaWaitExternalSemaphoresAsync"]
    pub fn cudaImportExternalSemaphore(
        extSem_out: *mut cudaExternalSemaphore_t,
        semHandleDesc: *const cudaExternalSemaphoreHandleDesc,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Signals a set of external semaphore objects\n\n Enqueues a signal operation on a set of externally allocated\n semaphore object in the specified stream. The operations will be\n executed when all prior operations in the stream complete.\n\n The exact semantics of signaling a semaphore depends on the type of\n the object.\n\n If the semaphore object is any one of the following types:\n ::cudaExternalSemaphoreHandleTypeOpaqueFd,\n ::cudaExternalSemaphoreHandleTypeOpaqueWin32,\n ::cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt\n then signaling the semaphore will set it to the signaled state.\n\n If the semaphore object is any one of the following types:\n ::cudaExternalSemaphoreHandleTypeD3D12Fence,\n ::cudaExternalSemaphoreHandleTypeD3D11Fence,\n ::cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd,\n ::cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32\n then the semaphore will be set to the value specified in\n ::cudaExternalSemaphoreSignalParams::params::fence::value.\n\n If the semaphore object is of the type ::cudaExternalSemaphoreHandleTypeNvSciSync\n this API sets ::cudaExternalSemaphoreSignalParams::params::nvSciSync::fence to a\n value that can be used by subsequent waiters of the same NvSciSync object to\n order operations with those currently submitted in \\p stream. Such an update\n will overwrite previous contents of\n ::cudaExternalSemaphoreSignalParams::params::nvSciSync::fence. By deefault,\n signaling such an external semaphore object causes appropriate memory synchronization\n operations to be performed over all the external memory objects that are imported as\n ::cudaExternalMemoryHandleTypeNvSciBuf. This ensures that any subsequent accesses\n made by other importers of the same set of NvSciBuf memory object(s) are coherent.\n These operations can be skipped by specifying the flag\n ::cudaExternalSemaphoreSignalSkipNvSciBufMemSync, which can be used as a\n performance optimization when data coherency is not required. But specifying this\n flag in scenarios where data coherency is required results in undefined behavior.\n Also, for semaphore object of the type ::cudaExternalSemaphoreHandleTypeNvSciSync,\n if the NvSciSyncAttrList used to create the NvSciSyncObj had not set the flags in\n ::cudaDeviceGetNvSciSyncAttributes to cudaNvSciSyncAttrSignal, this API will return\n cudaErrorNotSupported.\n\n If the semaphore object is any one of the following types:\n ::cudaExternalSemaphoreHandleTypeKeyedMutex,\n ::cudaExternalSemaphoreHandleTypeKeyedMutexKmt,\n then the keyed mutex will be released with the key specified in\n ::cudaExternalSemaphoreSignalParams::params::keyedmutex::key.\n\n \\param extSemArray - Set of external semaphores to be signaled\n \\param paramsArray - Array of semaphore parameters\n \\param numExtSems  - Number of semaphores to signal\n \\param stream     - Stream to enqueue the signal operations in\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaImportExternalSemaphore,\n ::cudaDestroyExternalSemaphore,\n ::cudaWaitExternalSemaphoresAsync"]
    pub fn cudaSignalExternalSemaphoresAsync_v2(
        extSemArray: *const cudaExternalSemaphore_t,
        paramsArray: *const cudaExternalSemaphoreSignalParams,
        numExtSems: ::std::os::raw::c_uint,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Waits on a set of external semaphore objects\n\n Enqueues a wait operation on a set of externally allocated\n semaphore object in the specified stream. The operations will be\n executed when all prior operations in the stream complete.\n\n The exact semantics of waiting on a semaphore depends on the type\n of the object.\n\n If the semaphore object is any one of the following types:\n ::cudaExternalSemaphoreHandleTypeOpaqueFd,\n ::cudaExternalSemaphoreHandleTypeOpaqueWin32,\n ::cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt\n then waiting on the semaphore will wait until the semaphore reaches\n the signaled state. The semaphore will then be reset to the\n unsignaled state. Therefore for every signal operation, there can\n only be one wait operation.\n\n If the semaphore object is any one of the following types:\n ::cudaExternalSemaphoreHandleTypeD3D12Fence,\n ::cudaExternalSemaphoreHandleTypeD3D11Fence,\n ::cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd,\n ::cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32\n then waiting on the semaphore will wait until the value of the\n semaphore is greater than or equal to\n ::cudaExternalSemaphoreWaitParams::params::fence::value.\n\n If the semaphore object is of the type ::cudaExternalSemaphoreHandleTypeNvSciSync\n then, waiting on the semaphore will wait until the\n ::cudaExternalSemaphoreSignalParams::params::nvSciSync::fence is signaled by the\n signaler of the NvSciSyncObj that was associated with this semaphore object.\n By default, waiting on such an external semaphore object causes appropriate\n memory synchronization operations to be performed over all external memory objects\n that are imported as ::cudaExternalMemoryHandleTypeNvSciBuf. This ensures that\n any subsequent accesses made by other importers of the same set of NvSciBuf memory\n object(s) are coherent. These operations can be skipped by specifying the flag\n ::cudaExternalSemaphoreWaitSkipNvSciBufMemSync, which can be used as a\n performance optimization when data coherency is not required. But specifying this\n flag in scenarios where data coherency is required results in undefined behavior.\n Also, for semaphore object of the type ::cudaExternalSemaphoreHandleTypeNvSciSync,\n if the NvSciSyncAttrList used to create the NvSciSyncObj had not set the flags in\n ::cudaDeviceGetNvSciSyncAttributes to cudaNvSciSyncAttrWait, this API will return\n cudaErrorNotSupported.\n\n If the semaphore object is any one of the following types:\n ::cudaExternalSemaphoreHandleTypeKeyedMutex,\n ::cudaExternalSemaphoreHandleTypeKeyedMutexKmt,\n then the keyed mutex will be acquired when it is released with the key specified\n in ::cudaExternalSemaphoreSignalParams::params::keyedmutex::key or\n until the timeout specified by\n ::cudaExternalSemaphoreSignalParams::params::keyedmutex::timeoutMs\n has lapsed. The timeout interval can either be a finite value\n specified in milliseconds or an infinite value. In case an infinite\n value is specified the timeout never elapses. The windows INFINITE\n macro must be used to specify infinite timeout\n\n \\param extSemArray - External semaphores to be waited on\n \\param paramsArray - Array of semaphore parameters\n \\param numExtSems  - Number of semaphores to wait on\n \\param stream      - Stream to enqueue the wait operations in\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidResourceHandle\n ::cudaErrorTimeout\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaImportExternalSemaphore,\n ::cudaDestroyExternalSemaphore,\n ::cudaSignalExternalSemaphoresAsync"]
    pub fn cudaWaitExternalSemaphoresAsync_v2(
        extSemArray: *const cudaExternalSemaphore_t,
        paramsArray: *const cudaExternalSemaphoreWaitParams,
        numExtSems: ::std::os::raw::c_uint,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Destroys an external semaphore\n\n Destroys an external semaphore object and releases any references\n to the underlying resource. Any outstanding signals or waits must\n have completed before the semaphore is destroyed.\n\n \\param extSem - External semaphore to be destroyed\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n \\note_init_rt\n \\note_callback\n \\note_destroy_ub\n\n \\sa ::cudaImportExternalSemaphore,\n ::cudaSignalExternalSemaphoresAsync,\n ::cudaWaitExternalSemaphoresAsync"]
    pub fn cudaDestroyExternalSemaphore(extSem: cudaExternalSemaphore_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Launches a device function\n\n The function invokes kernel \\p func on \\p gridDim (\\p gridDim.x &times; \\p gridDim.y\n &times; \\p gridDim.z) grid of blocks. Each block contains \\p blockDim (\\p blockDim.x &times;\n \\p blockDim.y &times; \\p blockDim.z) threads.\n\n If the kernel has N parameters the \\p args should point to array of N pointers.\n Each pointer, from <tt>args[0]</tt> to <tt>args[N - 1]</tt>, point to the region\n of memory from which the actual parameter will be copied.\n\n For templated functions, pass the function symbol as follows:\n func_name<template_arg_0,...,template_arg_N>\n\n \\p sharedMem sets the amount of dynamic shared memory that will be available to\n each thread block.\n\n \\p stream specifies a stream the invocation is associated to.\n\n \\param func        - Device function symbol\n \\param gridDim     - Grid dimentions\n \\param blockDim    - Block dimentions\n \\param args        - Arguments\n \\param sharedMem   - Shared memory\n \\param stream      - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidConfiguration,\n ::cudaErrorLaunchFailure,\n ::cudaErrorLaunchTimeout,\n ::cudaErrorLaunchOutOfResources,\n ::cudaErrorSharedObjectInitFailed,\n ::cudaErrorInvalidPtx,\n ::cudaErrorUnsupportedPtxVersion,\n ::cudaErrorNoKernelImageForDevice,\n ::cudaErrorJitCompilerNotFound,\n ::cudaErrorJitCompilationDisabled\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n \\ref ::cudaLaunchKernel(const T *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream) \"cudaLaunchKernel (C++ API)\",\n ::cuLaunchKernel"]
    pub fn cudaLaunchKernel(
        func: *const ::std::os::raw::c_void,
        gridDim: dim3,
        blockDim: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMem: usize,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Launches a CUDA function with launch-time configuration\n\n Note that the functionally equivalent variadic template ::cudaLaunchKernelEx\n is available for C++11 and newer.\n\n Invokes the kernel \\p func on \\p config->gridDim (\\p config->gridDim.x\n &times; \\p config->gridDim.y &times; \\p config->gridDim.z) grid of blocks.\n Each block contains \\p config->blockDim (\\p config->blockDim.x &times;\n \\p config->blockDim.y &times; \\p config->blockDim.z) threads.\n\n \\p config->dynamicSmemBytes sets the amount of dynamic shared memory that\n will be available to each thread block.\n\n \\p config->stream specifies a stream the invocation is associated to.\n\n Configuration beyond grid and block dimensions, dynamic shared memory size,\n and stream can be provided with the following two fields of \\p config:\n\n \\p config->attrs is an array of \\p config->numAttrs contiguous\n ::cudaLaunchAttribute elements. The value of this pointer is not considered\n if \\p config->numAttrs is zero. However, in that case, it is recommended to\n set the pointer to NULL.\n \\p config->numAttrs is the number of attributes populating the first\n \\p config->numAttrs positions of the \\p config->attrs array.\n\n If the kernel has N parameters the \\p args should point to array of N\n pointers. Each pointer, from <tt>args[0]</tt> to <tt>args[N - 1]</tt>, point\n to the region of memory from which the actual parameter will be copied.\n\n N.B. This function is so named to avoid unintentionally invoking the\n      templated version, \\p cudaLaunchKernelEx, for kernels taking a single\n      void** or void* parameter.\n\n \\param config - Launch configuration\n \\param func   - Kernel to launch\n \\param args   - Array of pointers to kernel parameters\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidConfiguration,\n ::cudaErrorLaunchFailure,\n ::cudaErrorLaunchTimeout,\n ::cudaErrorLaunchOutOfResources,\n ::cudaErrorSharedObjectInitFailed,\n ::cudaErrorInvalidPtx,\n ::cudaErrorUnsupportedPtxVersion,\n ::cudaErrorNoKernelImageForDevice,\n ::cudaErrorJitCompilerNotFound,\n ::cudaErrorJitCompilationDisabled\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n \\ref ::cudaLaunchKernelEx(const cudaLaunchConfig_t *config, void (*kernel)(ExpTypes...), ActTypes &&... args) \"cudaLaunchKernelEx (C++ API)\",\n ::cuLaunchKernelEx"]
    pub fn cudaLaunchKernelExC(
        config: *const cudaLaunchConfig_t,
        func: *const ::std::os::raw::c_void,
        args: *mut *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Launches a device function where thread blocks can cooperate and synchronize as they execute\n\n The function invokes kernel \\p func on \\p gridDim (\\p gridDim.x &times; \\p gridDim.y\n &times; \\p gridDim.z) grid of blocks. Each block contains \\p blockDim (\\p blockDim.x &times;\n \\p blockDim.y &times; \\p blockDim.z) threads.\n\n The device on which this kernel is invoked must have a non-zero value for\n the device attribute ::cudaDevAttrCooperativeLaunch.\n\n The total number of blocks launched cannot exceed the maximum number of blocks per\n multiprocessor as returned by ::cudaOccupancyMaxActiveBlocksPerMultiprocessor (or\n ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags) times the number of multiprocessors\n as specified by the device attribute ::cudaDevAttrMultiProcessorCount.\n\n The kernel cannot make use of CUDA dynamic parallelism.\n\n If the kernel has N parameters the \\p args should point to array of N pointers.\n Each pointer, from <tt>args[0]</tt> to <tt>args[N - 1]</tt>, point to the region\n of memory from which the actual parameter will be copied.\n\n For templated functions, pass the function symbol as follows:\n func_name<template_arg_0,...,template_arg_N>\n\n \\p sharedMem sets the amount of dynamic shared memory that will be available to\n each thread block.\n\n \\p stream specifies a stream the invocation is associated to.\n\n \\param func        - Device function symbol\n \\param gridDim     - Grid dimentions\n \\param blockDim    - Block dimentions\n \\param args        - Arguments\n \\param sharedMem   - Shared memory\n \\param stream      - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidConfiguration,\n ::cudaErrorLaunchFailure,\n ::cudaErrorLaunchTimeout,\n ::cudaErrorLaunchOutOfResources,\n ::cudaErrorCooperativeLaunchTooLarge,\n ::cudaErrorSharedObjectInitFailed\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n \\ref ::cudaLaunchCooperativeKernel(const T *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream) \"cudaLaunchCooperativeKernel (C++ API)\",\n ::cudaLaunchCooperativeKernelMultiDevice,\n ::cuLaunchCooperativeKernel"]
    pub fn cudaLaunchCooperativeKernel(
        func: *const ::std::os::raw::c_void,
        gridDim: dim3,
        blockDim: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMem: usize,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Launches device functions on multiple devices where thread blocks can cooperate and synchronize as they execute\n\n \\deprecated This function is deprecated as of CUDA 11.3.\n\n Invokes kernels as specified in the \\p launchParamsList array where each element\n of the array specifies all the parameters required to perform a single kernel launch.\n These kernels can cooperate and synchronize as they execute. The size of the array is\n specified by \\p numDevices.\n\n No two kernels can be launched on the same device. All the devices targeted by this\n multi-device launch must be identical. All devices must have a non-zero value for the\n device attribute ::cudaDevAttrCooperativeMultiDeviceLaunch.\n\n The same kernel must be launched on all devices. Note that any __device__ or __constant__\n variables are independently instantiated on every device. It is the application's\n responsiblity to ensure these variables are initialized and used appropriately.\n\n The size of the grids as specified in blocks, the size of the blocks themselves and the\n amount of shared memory used by each thread block must also match across all launched kernels.\n\n The streams used to launch these kernels must have been created via either ::cudaStreamCreate\n or ::cudaStreamCreateWithPriority or ::cudaStreamCreateWithPriority. The NULL stream or\n ::cudaStreamLegacy or ::cudaStreamPerThread cannot be used.\n\n The total number of blocks launched per kernel cannot exceed the maximum number of blocks\n per multiprocessor as returned by ::cudaOccupancyMaxActiveBlocksPerMultiprocessor (or\n ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags) times the number of multiprocessors\n as specified by the device attribute ::cudaDevAttrMultiProcessorCount. Since the\n total number of blocks launched per device has to match across all devices, the maximum\n number of blocks that can be launched per device will be limited by the device with the\n least number of multiprocessors.\n\n The kernel cannot make use of CUDA dynamic parallelism.\n\n The ::cudaLaunchParams structure is defined as:\n \\code\nstruct cudaLaunchParams\n{\nvoid *func;\ndim3 gridDim;\ndim3 blockDim;\nvoid **args;\nsize_t sharedMem;\ncudaStream_t stream;\n};\n \\endcode\n where:\n - ::cudaLaunchParams::func specifies the kernel to be launched. This same functions must\n   be launched on all devices. For templated functions, pass the function symbol as follows:\n   func_name<template_arg_0,...,template_arg_N>\n - ::cudaLaunchParams::gridDim specifies the width, height and depth of the grid in blocks.\n   This must match across all kernels launched.\n - ::cudaLaunchParams::blockDim is the width, height and depth of each thread block. This\n   must match across all kernels launched.\n - ::cudaLaunchParams::args specifies the arguments to the kernel. If the kernel has\n   N parameters then ::cudaLaunchParams::args should point to array of N pointers. Each\n   pointer, from <tt>::cudaLaunchParams::args[0]</tt> to <tt>::cudaLaunchParams::args[N - 1]</tt>,\n   point to the region of memory from which the actual parameter will be copied.\n - ::cudaLaunchParams::sharedMem is the dynamic shared-memory size per thread block in bytes.\n   This must match across all kernels launched.\n - ::cudaLaunchParams::stream is the handle to the stream to perform the launch in. This cannot\n   be the NULL stream or ::cudaStreamLegacy or ::cudaStreamPerThread.\n\n By default, the kernel won't begin execution on any GPU until all prior work in all the specified\n streams has completed. This behavior can be overridden by specifying the flag\n ::cudaCooperativeLaunchMultiDeviceNoPreSync. When this flag is specified, each kernel\n will only wait for prior work in the stream corresponding to that GPU to complete before it begins\n execution.\n\n Similarly, by default, any subsequent work pushed in any of the specified streams will not begin\n execution until the kernels on all GPUs have completed. This behavior can be overridden by specifying\n the flag ::cudaCooperativeLaunchMultiDeviceNoPostSync. When this flag is specified,\n any subsequent work pushed in any of the specified streams will only wait for the kernel launched\n on the GPU corresponding to that stream to complete before it begins execution.\n\n \\param launchParamsList - List of launch parameters, one per device\n \\param numDevices       - Size of the \\p launchParamsList array\n \\param flags            - Flags to control launch behavior\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidConfiguration,\n ::cudaErrorLaunchFailure,\n ::cudaErrorLaunchTimeout,\n ::cudaErrorLaunchOutOfResources,\n ::cudaErrorCooperativeLaunchTooLarge,\n ::cudaErrorSharedObjectInitFailed\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n \\ref ::cudaLaunchCooperativeKernel(const T *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream) \"cudaLaunchCooperativeKernel (C++ API)\",\n ::cudaLaunchCooperativeKernel,\n ::cuLaunchCooperativeKernelMultiDevice"]
    pub fn cudaLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut cudaLaunchParams,
        numDevices: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the preferred cache configuration for a device function\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this sets through \\p cacheConfig the preferred cache configuration\n for the function specified via \\p func. This is only a preference. The\n runtime will use the requested configuration if possible, but it is free to\n choose a different configuration if required to execute \\p func.\n\n \\p func is a device function symbol and must be declared as a\n \\c __global__ function. If the specified function does not exist,\n then ::cudaErrorInvalidDeviceFunction is returned. For templated functions,\n pass the function symbol as follows: func_name<template_arg_0,...,template_arg_N>\n\n This setting does nothing on devices where the size of the L1 cache and\n shared memory are fixed.\n\n Launching a kernel with a different preference than the most recent\n preference setting may insert a device-side synchronization point.\n\n The supported cache configurations are:\n - ::cudaFuncCachePreferNone: no preference for shared memory or L1 (default)\n - ::cudaFuncCachePreferShared: prefer larger shared memory and smaller L1 cache\n - ::cudaFuncCachePreferL1: prefer larger L1 cache and smaller shared memory\n - ::cudaFuncCachePreferEqual: prefer equal size L1 cache and shared memory\n\n \\param func        - Device function symbol\n \\param cacheConfig - Requested cache configuration\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDeviceFunction\n \\notefnerr\n \\note_string_api_deprecation2\n \\note_init_rt\n \\note_callback\n\n \\sa\n \\ref ::cudaFuncSetCacheConfig(T*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C++ API)\",\n \\ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, const void*) \"cudaFuncGetAttributes (C API)\",\n \\ref ::cudaLaunchKernel(const void *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream) \"cudaLaunchKernel (C API)\",\n ::cudaThreadGetCacheConfig,\n ::cudaThreadSetCacheConfig,\n ::cuFuncSetCacheConfig"]
    pub fn cudaFuncSetCacheConfig(
        func: *const ::std::os::raw::c_void,
        cacheConfig: cudaFuncCache,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the shared memory configuration for a device function\n\n On devices with configurable shared memory banks, this function will\n force all subsequent launches of the specified device function to have\n the given shared memory bank size configuration. On any given launch of the\n function, the shared memory configuration of the device will be temporarily\n changed if needed to suit the function's preferred configuration. Changes in\n shared memory configuration between subsequent launches of functions,\n may introduce a device side synchronization point.\n\n Any per-function setting of shared memory bank size set via\n ::cudaFuncSetSharedMemConfig will override the device wide setting set by\n ::cudaDeviceSetSharedMemConfig.\n\n Changing the shared memory bank size will not increase shared memory usage\n or affect occupancy of kernels, but may have major effects on performance.\n Larger bank sizes will allow for greater potential bandwidth to shared memory,\n but will change what kinds of accesses to shared memory will result in bank\n conflicts.\n\n This function will do nothing on devices with fixed shared memory bank size.\n\n For templated functions, pass the function symbol as follows:\n func_name<template_arg_0,...,template_arg_N>\n\n The supported bank configurations are:\n - ::cudaSharedMemBankSizeDefault: use the device's shared memory configuration\n   when launching this function.\n - ::cudaSharedMemBankSizeFourByte: set shared memory bank width to be\n   four bytes natively when launching this function.\n - ::cudaSharedMemBankSizeEightByte: set shared memory bank width to be eight\n   bytes natively when launching this function.\n\n \\param func   - Device function symbol\n \\param config - Requested shared memory configuration\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidValue,\n \\notefnerr\n \\note_string_api_deprecation2\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceSetSharedMemConfig,\n ::cudaDeviceGetSharedMemConfig,\n ::cudaDeviceSetCacheConfig,\n ::cudaDeviceGetCacheConfig,\n ::cudaFuncSetCacheConfig,\n ::cuFuncSetSharedMemConfig"]
    pub fn cudaFuncSetSharedMemConfig(
        func: *const ::std::os::raw::c_void,
        config: cudaSharedMemConfig,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Find out attributes for a given function\n\n This function obtains the attributes of a function specified via \\p func.\n \\p func is a device function symbol and must be declared as a\n \\c __global__ function. The fetched attributes are placed in \\p attr.\n If the specified function does not exist, then\n ::cudaErrorInvalidDeviceFunction is returned. For templated functions, pass\n the function symbol as follows: func_name<template_arg_0,...,template_arg_N>\n\n Note that some function attributes such as\n \\ref ::cudaFuncAttributes::maxThreadsPerBlock \"maxThreadsPerBlock\"\n may vary based on the device that is currently being used.\n\n \\param attr - Return pointer to function's attributes\n \\param func - Device function symbol\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDeviceFunction\n \\notefnerr\n \\note_string_api_deprecation2\n \\note_init_rt\n \\note_callback\n\n \\sa\n \\ref ::cudaFuncSetCacheConfig(const void*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C API)\",\n \\ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, T*) \"cudaFuncGetAttributes (C++ API)\",\n \\ref ::cudaLaunchKernel(const void *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream) \"cudaLaunchKernel (C API)\",\n ::cuFuncGetAttribute"]
    pub fn cudaFuncGetAttributes(
        attr: *mut cudaFuncAttributes,
        func: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Set attributes for a given function\n\n This function sets the attributes of a function specified via \\p func.\n The parameter \\p func must be a pointer to a function that executes\n on the device. The parameter specified by \\p func must be declared as a \\p __global__\n function. The enumeration defined by \\p attr is set to the value defined by \\p value.\n If the specified function does not exist, then ::cudaErrorInvalidDeviceFunction is returned.\n If the specified attribute cannot be written, or if the value is incorrect,\n then ::cudaErrorInvalidValue is returned.\n\n Valid values for \\p attr are:\n - ::cudaFuncAttributeMaxDynamicSharedMemorySize - The requested maximum size in bytes of dynamically-allocated shared memory. The sum of this value and the function attribute ::sharedSizeBytes\n   cannot exceed the device attribute ::cudaDevAttrMaxSharedMemoryPerBlockOptin. The maximal size of requestable dynamic shared memory may differ by GPU architecture.\n - ::cudaFuncAttributePreferredSharedMemoryCarveout - On devices where the L1 cache and shared memory use the same hardware resources,\n   this sets the shared memory carveout preference, in percent of the total shared memory. See ::cudaDevAttrMaxSharedMemoryPerMultiprocessor.\n   This is only a hint, and the driver can choose a different ratio if required to execute the function.\n\n \\param func  - Function to get attributes of\n \\param attr  - Attribute to set\n \\param value - Value to set\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\ref ::cudaLaunchKernel(const T *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream) \"cudaLaunchKernel (C++ API)\",\n \\ref ::cudaFuncSetCacheConfig(T*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C++ API)\",\n \\ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, const void*) \"cudaFuncGetAttributes (C API)\","]
    pub fn cudaFuncSetAttribute(
        func: *const ::std::os::raw::c_void,
        attr: cudaFuncAttribute,
        value: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Converts a double argument to be executed on a device\n\n \\param d - Double to convert\n\n \\deprecated This function is deprecated as of CUDA 7.5\n\n Converts the double value of \\p d to an internal float representation if\n the device does not support double arithmetic. If the device does natively\n support doubles, then this function does nothing.\n\n \\return\n ::cudaSuccess\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n \\ref ::cudaFuncSetCacheConfig(const void*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C API)\",\n \\ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, const void*) \"cudaFuncGetAttributes (C API)\",\n ::cudaSetDoubleForHost"]
    pub fn cudaSetDoubleForDevice(d: *mut f64) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Converts a double argument after execution on a device\n\n \\deprecated This function is deprecated as of CUDA 7.5\n\n Converts the double value of \\p d from a potentially internal float\n representation if the device does not support double arithmetic. If the\n device does natively support doubles, then this function does nothing.\n\n \\param d - Double to convert\n\n \\return\n ::cudaSuccess\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n \\ref ::cudaFuncSetCacheConfig(const void*, enum cudaFuncCache) \"cudaFuncSetCacheConfig (C API)\",\n \\ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, const void*) \"cudaFuncGetAttributes (C API)\",\n ::cudaSetDoubleForDevice"]
    pub fn cudaSetDoubleForHost(d: *mut f64) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Enqueues a host function call in a stream\n\n Enqueues a host function to run in a stream.  The function will be called\n after currently enqueued work and will block work added after it.\n\n The host function must not make any CUDA API calls.  Attempting to use a\n CUDA API may result in ::cudaErrorNotPermitted, but this is not required.\n The host function must not perform any synchronization that may depend on\n outstanding CUDA work not mandated to run earlier.  Host functions without a\n mandated order (such as in independent streams) execute in undefined order\n and may be serialized.\n\n For the purposes of Unified Memory, execution makes a number of guarantees:\n <ul>\n   <li>The stream is considered idle for the duration of the function's\n   execution.  Thus, for example, the function may always use memory attached\n   to the stream it was enqueued in.</li>\n   <li>The start of execution of the function has the same effect as\n   synchronizing an event recorded in the same stream immediately prior to\n   the function.  It thus synchronizes streams which have been \"joined\"\n   prior to the function.</li>\n   <li>Adding device work to any stream does not have the effect of making\n   the stream active until all preceding host functions and stream callbacks\n   have executed.  Thus, for\n   example, a function might use global attached memory even if work has\n   been added to another stream, if the work has been ordered behind the\n   function call with an event.</li>\n   <li>Completion of the function does not cause a stream to become\n   active except as described above.  The stream will remain idle\n   if no device work follows the function, and will remain idle across\n   consecutive host functions or stream callbacks without device work in\n   between.  Thus, for example,\n   stream synchronization can be done by signaling from a host function at the\n   end of the stream.</li>\n </ul>\n\n Note that, in constrast to ::cuStreamAddCallback, the function will not be\n called in the event of an error in the CUDA context.\n\n \\param hStream  - Stream to enqueue function call in\n \\param fn       - The function to call once preceding stream operations are complete\n \\param userData - User-specified data to be passed to the function\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorInvalidValue,\n ::cudaErrorNotSupported\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaStreamCreate,\n ::cudaStreamQuery,\n ::cudaStreamSynchronize,\n ::cudaStreamWaitEvent,\n ::cudaStreamDestroy,\n ::cudaMallocManaged,\n ::cudaStreamAttachMemAsync,\n ::cudaStreamAddCallback,\n ::cuLaunchHostFunc"]
    pub fn cudaLaunchHostFunc(
        stream: cudaStream_t,
        fn_: cudaHostFn_t,
        userData: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns occupancy for a device function\n\n Returns in \\p *numBlocks the maximum number of active blocks per\n streaming multiprocessor for the device function.\n\n \\param numBlocks       - Returned occupancy\n \\param func            - Kernel function for which occupancy is calculated\n \\param blockSize       - Block size the kernel is intended to be launched with\n \\param dynamicSMemSize - Per-block dynamic shared memory usage intended, in bytes\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDevice,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidValue,\n ::cudaErrorUnknown,\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags,\n \\ref ::cudaOccupancyMaxPotentialBlockSize(int*, int*, T, size_t, int) \"cudaOccupancyMaxPotentialBlockSize (C++ API)\",\n \\ref ::cudaOccupancyMaxPotentialBlockSizeWithFlags(int*, int*, T, size_t, int, unsigned int) \"cudaOccupancyMaxPotentialBlockSizeWithFlags (C++ API)\",\n \\ref ::cudaOccupancyMaxPotentialBlockSizeVariableSMem(int*, int*, T, UnaryFunction, int) \"cudaOccupancyMaxPotentialBlockSizeVariableSMem (C++ API)\",\n \\ref ::cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int*, int*, T, UnaryFunction, int, unsigned int) \"cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags (C++ API)\",\n \\ref ::cudaOccupancyAvailableDynamicSMemPerBlock(size_t*, T, int, int) \"cudaOccupancyAvailableDynamicSMemPerBlock (C++ API)\",\n ::cuOccupancyMaxActiveBlocksPerMultiprocessor"]
    pub fn cudaOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_void,
        blockSize: ::std::os::raw::c_int,
        dynamicSMemSize: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns dynamic shared memory available per block when launching \\p numBlocks blocks on SM.\n\n Returns in \\p *dynamicSmemSize the maximum size of dynamic shared memory to allow \\p numBlocks blocks per SM.\n\n \\param dynamicSmemSize - Returned maximum dynamic shared memory\n \\param func            - Kernel function for which occupancy is calculated\n \\param numBlocks       - Number of blocks to fit on SM\n \\param blockSize       - Size of the block\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDevice,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidValue,\n ::cudaErrorUnknown,\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags,\n \\ref ::cudaOccupancyMaxPotentialBlockSize(int*, int*, T, size_t, int) \"cudaOccupancyMaxPotentialBlockSize (C++ API)\",\n \\ref ::cudaOccupancyMaxPotentialBlockSizeWithFlags(int*, int*, T, size_t, int, unsigned int) \"cudaOccupancyMaxPotentialBlockSizeWithFlags (C++ API)\",\n \\ref ::cudaOccupancyMaxPotentialBlockSizeVariableSMem(int*, int*, T, UnaryFunction, int) \"cudaOccupancyMaxPotentialBlockSizeVariableSMem (C++ API)\",\n \\ref ::cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int*, int*, T, UnaryFunction, int, unsigned int) \"cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags (C++ API)\",\n ::cudaOccupancyAvailableDynamicSMemPerBlock"]
    pub fn cudaOccupancyAvailableDynamicSMemPerBlock(
        dynamicSmemSize: *mut usize,
        func: *const ::std::os::raw::c_void,
        numBlocks: ::std::os::raw::c_int,
        blockSize: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns occupancy for a device function with the specified flags\n\n Returns in \\p *numBlocks the maximum number of active blocks per\n streaming multiprocessor for the device function.\n\n The \\p flags parameter controls how special cases are handled. Valid flags include:\n\n - ::cudaOccupancyDefault: keeps the default behavior as\n   ::cudaOccupancyMaxActiveBlocksPerMultiprocessor\n\n - ::cudaOccupancyDisableCachingOverride: This flag suppresses the default behavior\n   on platform where global caching affects occupancy. On such platforms, if caching\n   is enabled, but per-block SM resource usage would result in zero occupancy, the\n   occupancy calculator will calculate the occupancy as if caching is disabled.\n   Setting this flag makes the occupancy calculator to return 0 in such cases.\n   More information can be found about this feature in the \"Unified L1/Texture Cache\"\n   section of the Maxwell tuning guide.\n\n \\param numBlocks       - Returned occupancy\n \\param func            - Kernel function for which occupancy is calculated\n \\param blockSize       - Block size the kernel is intended to be launched with\n \\param dynamicSMemSize - Per-block dynamic shared memory usage intended, in bytes\n \\param flags           - Requested behavior for the occupancy calculator\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDevice,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidValue,\n ::cudaErrorUnknown,\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaOccupancyMaxActiveBlocksPerMultiprocessor,\n \\ref ::cudaOccupancyMaxPotentialBlockSize(int*, int*, T, size_t, int) \"cudaOccupancyMaxPotentialBlockSize (C++ API)\",\n \\ref ::cudaOccupancyMaxPotentialBlockSizeWithFlags(int*, int*, T, size_t, int, unsigned int) \"cudaOccupancyMaxPotentialBlockSizeWithFlags (C++ API)\",\n \\ref ::cudaOccupancyMaxPotentialBlockSizeVariableSMem(int*, int*, T, UnaryFunction, int) \"cudaOccupancyMaxPotentialBlockSizeVariableSMem (C++ API)\",\n \\ref ::cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int*, int*, T, UnaryFunction, int, unsigned int) \"cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags (C++ API)\",\n \\ref ::cudaOccupancyAvailableDynamicSMemPerBlock(size_t*, T, int, int) \"cudaOccupancyAvailableDynamicSMemPerBlock (C++ API)\",\n ::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags"]
    pub fn cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_void,
        blockSize: ::std::os::raw::c_int,
        dynamicSMemSize: usize,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Given the kernel function (\\p func) and launch configuration\n (\\p config), return the maximum cluster size in \\p *clusterSize.\n\n The cluster dimensions in \\p config are ignored. If func has a required\n cluster size set (see ::cudaFuncGetAttributes),\\p *clusterSize will reflect\n the required cluster size.\n\n By default this function will always return a value that's portable on\n future hardware. A higher value may be returned if the kernel function\n allows non-portable cluster sizes.\n\n This function will respect the compile time launch bounds.\n\n \\param clusterSize - Returned maximum cluster size that can be launched\n                      for the given kernel function and launch configuration\n \\param func        - Kernel function for which maximum cluster\n                      size is calculated\n \\param config      - Launch configuration for the given kernel function\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidValue,\n ::cudaErrorUnknown,\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaFuncGetAttributes\n \\ref ::cudaOccupancyMaxPotentialClusterSize(int*, T, const cudaLaunchConfig_t*) \"cudaOccupancyMaxPotentialClusterSize (C++ API)\",\n ::cuOccupancyMaxPotentialClusterSize"]
    pub fn cudaOccupancyMaxPotentialClusterSize(
        clusterSize: *mut ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_void,
        launchConfig: *const cudaLaunchConfig_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Given the kernel function (\\p func) and launch configuration\n (\\p config), return the maximum number of clusters that could co-exist\n on the target device in \\p *numClusters.\n\n If the function has required cluster size already set (see\n ::cudaFuncGetAttributes), the cluster size from config must either be\n unspecified or match the required size.\n Without required sizes, the cluster size must be specified in config,\n else the function will return an error.\n\n Note that various attributes of the kernel function may affect occupancy\n calculation. Runtime environment may affect how the hardware schedules\n the clusters, so the calculated occupancy is not guaranteed to be achievable.\n\n \\param numClusters - Returned maximum number of clusters that\n                      could co-exist on the target device\n \\param func        - Kernel function for which maximum number\n                      of clusters are calculated\n \\param config      - Launch configuration for the given kernel function\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDeviceFunction,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidClusterSize,\n ::cudaErrorUnknown,\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaFuncGetAttributes\n \\ref ::cudaOccupancyMaxActiveClusters(int*, T, const cudaLaunchConfig_t*) \"cudaOccupancyMaxActiveClusters (C++ API)\",\n ::cuOccupancyMaxActiveClusters"]
    pub fn cudaOccupancyMaxActiveClusters(
        numClusters: *mut ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_void,
        launchConfig: *const cudaLaunchConfig_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaMallocManaged(
        devPtr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Allocate memory on the device\n\n Allocates \\p size bytes of linear memory on the device and returns in\n \\p *devPtr a pointer to the allocated memory. The allocated memory is\n suitably aligned for any kind of variable. The memory is not cleared.\n ::cudaMalloc() returns ::cudaErrorMemoryAllocation in case of failure.\n\n The device version of ::cudaFree cannot be used with a \\p *devPtr\n allocated using the host API, and vice versa.\n\n \\param devPtr - Pointer to allocated device memory\n \\param size   - Requested allocation size in bytes\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMallocPitch, ::cudaFree, ::cudaMallocArray, ::cudaFreeArray,\n ::cudaMalloc3D, ::cudaMalloc3DArray,\n \\ref ::cudaMallocHost(void**, size_t) \"cudaMallocHost (C API)\",\n ::cudaFreeHost, ::cudaHostAlloc,\n ::cuMemAlloc"]
    pub fn cudaMalloc(devPtr: *mut *mut ::std::os::raw::c_void, size: usize) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Allocates page-locked memory on the host\n\n Allocates \\p size bytes of host memory that is page-locked and accessible\n to the device. The driver tracks the virtual memory ranges allocated with\n this function and automatically accelerates calls to functions such as\n ::cudaMemcpy*(). Since the memory can be accessed directly by the device,\n it can be read or written with much higher bandwidth than pageable memory\n obtained with functions such as ::malloc(). Allocating excessive amounts of\n memory with ::cudaMallocHost() may degrade system performance, since it\n reduces the amount of memory available to the system for paging. As a\n result, this function is best used sparingly to allocate staging areas for\n data exchange between host and device.\n\n \\param ptr  - Pointer to allocated host memory\n \\param size - Requested allocation size in bytes\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMalloc, ::cudaMallocPitch, ::cudaMallocArray, ::cudaMalloc3D,\n ::cudaMalloc3DArray, ::cudaHostAlloc, ::cudaFree, ::cudaFreeArray,\n \\ref ::cudaMallocHost(void**, size_t, unsigned int) \"cudaMallocHost (C++ API)\",\n ::cudaFreeHost, ::cudaHostAlloc,\n ::cuMemAllocHost"]
    pub fn cudaMallocHost(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Allocates pitched memory on the device\n\n Allocates at least \\p width (in bytes) * \\p height bytes of linear memory\n on the device and returns in \\p *devPtr a pointer to the allocated memory.\n The function may pad the allocation to ensure that corresponding pointers\n in any given row will continue to meet the alignment requirements for\n coalescing as the address is updated from row to row. The pitch returned in\n \\p *pitch by ::cudaMallocPitch() is the width in bytes of the allocation.\n The intended usage of \\p pitch is as a separate parameter of the allocation,\n used to compute addresses within the 2D array. Given the row and column of\n an array element of type \\p T, the address is computed as:\n \\code\nT* pElement = (T*)((char*)BaseAddress + Row * pitch) + Column;\n\\endcode\n\n For allocations of 2D arrays, it is recommended that programmers consider\n performing pitch allocations using ::cudaMallocPitch(). Due to pitch\n alignment restrictions in the hardware, this is especially true if the\n application will be performing 2D memory copies between different regions\n of device memory (whether linear memory or CUDA arrays).\n\n \\param devPtr - Pointer to allocated pitched device memory\n \\param pitch  - Pitch for allocation\n \\param width  - Requested pitched allocation width (in bytes)\n \\param height - Requested pitched allocation height\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMalloc, ::cudaFree, ::cudaMallocArray, ::cudaFreeArray,\n \\ref ::cudaMallocHost(void**, size_t) \"cudaMallocHost (C API)\",\n ::cudaFreeHost, ::cudaMalloc3D, ::cudaMalloc3DArray,\n ::cudaHostAlloc,\n ::cuMemAllocPitch"]
    pub fn cudaMallocPitch(
        devPtr: *mut *mut ::std::os::raw::c_void,
        pitch: *mut usize,
        width: usize,
        height: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Allocate an array on the device\n\n Allocates a CUDA array according to the ::cudaChannelFormatDesc structure\n \\p desc and returns a handle to the new CUDA array in \\p *array.\n\n The ::cudaChannelFormatDesc is defined as:\n \\code\nstruct cudaChannelFormatDesc {\nint x, y, z, w;\nenum cudaChannelFormatKind f;\n};\n\\endcode\n where ::cudaChannelFormatKind is one of ::cudaChannelFormatKindSigned,\n ::cudaChannelFormatKindUnsigned, or ::cudaChannelFormatKindFloat.\n\n The \\p flags parameter enables different options to be specified that affect\n the allocation, as follows.\n - ::cudaArrayDefault: This flag's value is defined to be 0 and provides default array allocation\n - ::cudaArraySurfaceLoadStore: Allocates an array that can be read from or written to using a surface reference\n - ::cudaArrayTextureGather: This flag indicates that texture gather operations will be performed on the array.\n - ::cudaArraySparse: Allocates a CUDA array without physical backing memory. The subregions within this sparse array\n   can later be mapped onto a physical memory allocation by calling ::cuMemMapArrayAsync.\n   The physical backing memory must be allocated via ::cuMemCreate.\n - ::cudaArrayDeferredMapping: Allocates a CUDA array without physical backing memory. The entire array can\n   later be mapped onto a physical memory allocation by calling ::cuMemMapArrayAsync.\n   The physical backing memory must be allocated via ::cuMemCreate.\n\n \\p width and \\p height must meet certain size requirements. See ::cudaMalloc3DArray() for more details.\n\n \\param array  - Pointer to allocated array in device memory\n \\param desc   - Requested channel format\n \\param width  - Requested array allocation width\n \\param height - Requested array allocation height\n \\param flags  - Requested properties of allocated array\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMalloc, ::cudaMallocPitch, ::cudaFree, ::cudaFreeArray,\n \\ref ::cudaMallocHost(void**, size_t) \"cudaMallocHost (C API)\",\n ::cudaFreeHost, ::cudaMalloc3D, ::cudaMalloc3DArray,\n ::cudaHostAlloc,\n ::cuArrayCreate"]
    pub fn cudaMallocArray(
        array: *mut cudaArray_t,
        desc: *const cudaChannelFormatDesc,
        width: usize,
        height: usize,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Frees memory on the device\n\n Frees the memory space pointed to by \\p devPtr, which must have been\n returned by a previous call to one of the following memory allocation APIs -\n ::cudaMalloc(), ::cudaMallocPitch(), ::cudaMallocManaged(), ::cudaMallocAsync(),\n ::cudaMallocFromPoolAsync().\n\n Note - This API will not perform any implicit synchronization when the pointer was\n allocated with ::cudaMallocAsync or ::cudaMallocFromPoolAsync. Callers must ensure\n that all accesses to the pointer have completed before invoking ::cudaFree. For\n best performance and memory reuse, users should use ::cudaFreeAsync to free memory\n allocated via the stream ordered memory allocator.\n\n If ::cudaFree(\\p devPtr) has already been called before,\n an error is returned. If \\p devPtr is 0, no operation is performed.\n ::cudaFree() returns ::cudaErrorValue in case of failure.\n\n The device version of ::cudaFree cannot be used with a \\p *devPtr\n allocated using the host API, and vice versa.\n\n \\param devPtr - Device pointer to memory to free\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMalloc, ::cudaMallocPitch, ::cudaMallocManaged, ::cudaMallocArray, ::cudaFreeArray, ::cudaMallocAsync, ::cudaMallocFromPoolAsync\n \\ref ::cudaMallocHost(void**, size_t) \"cudaMallocHost (C API)\",\n ::cudaFreeHost, ::cudaMalloc3D, ::cudaMalloc3DArray, ::cudaFreeAsync\n ::cudaHostAlloc,\n ::cuMemFree"]
    pub fn cudaFree(devPtr: *mut ::std::os::raw::c_void) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Frees page-locked memory\n\n Frees the memory space pointed to by \\p hostPtr, which must have been\n returned by a previous call to ::cudaMallocHost() or ::cudaHostAlloc().\n\n \\param ptr - Pointer to memory to free\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMalloc, ::cudaMallocPitch, ::cudaFree, ::cudaMallocArray,\n ::cudaFreeArray,\n \\ref ::cudaMallocHost(void**, size_t) \"cudaMallocHost (C API)\",\n ::cudaMalloc3D, ::cudaMalloc3DArray, ::cudaHostAlloc,\n ::cuMemFreeHost"]
    pub fn cudaFreeHost(ptr: *mut ::std::os::raw::c_void) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Frees an array on the device\n\n Frees the CUDA array \\p array, which must have been returned by a\n previous call to ::cudaMallocArray(). If \\p devPtr is 0,\n no operation is performed.\n\n \\param array - Pointer to array to free\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMalloc, ::cudaMallocPitch, ::cudaFree, ::cudaMallocArray,\n \\ref ::cudaMallocHost(void**, size_t) \"cudaMallocHost (C API)\",\n ::cudaFreeHost, ::cudaHostAlloc,\n ::cuArrayDestroy"]
    pub fn cudaFreeArray(array: cudaArray_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Frees a mipmapped array on the device\n\n Frees the CUDA mipmapped array \\p mipmappedArray, which must have been\n returned by a previous call to ::cudaMallocMipmappedArray(). If \\p devPtr\n is 0, no operation is performed.\n\n \\param mipmappedArray - Pointer to mipmapped array to free\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMalloc, ::cudaMallocPitch, ::cudaFree, ::cudaMallocArray,\n \\ref ::cudaMallocHost(void**, size_t) \"cudaMallocHost (C API)\",\n ::cudaFreeHost, ::cudaHostAlloc,\n ::cuMipmappedArrayDestroy"]
    pub fn cudaFreeMipmappedArray(mipmappedArray: cudaMipmappedArray_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Allocates page-locked memory on the host\n\n Allocates \\p size bytes of host memory that is page-locked and accessible\n to the device. The driver tracks the virtual memory ranges allocated with\n this function and automatically accelerates calls to functions such as\n ::cudaMemcpy(). Since the memory can be accessed directly by the device, it\n can be read or written with much higher bandwidth than pageable memory\n obtained with functions such as ::malloc(). Allocating excessive amounts of\n pinned memory may degrade system performance, since it reduces the amount\n of memory available to the system for paging. As a result, this function is\n best used sparingly to allocate staging areas for data exchange between host\n and device.\n\n The \\p flags parameter enables different options to be specified that affect\n the allocation, as follows.\n - ::cudaHostAllocDefault: This flag's value is defined to be 0 and causes\n ::cudaHostAlloc() to emulate ::cudaMallocHost().\n - ::cudaHostAllocPortable: The memory returned by this call will be\n considered as pinned memory by all CUDA contexts, not just the one that\n performed the allocation.\n - ::cudaHostAllocMapped: Maps the allocation into the CUDA address space.\n The device pointer to the memory may be obtained by calling\n ::cudaHostGetDevicePointer().\n - ::cudaHostAllocWriteCombined: Allocates the memory as write-combined (WC).\n WC memory can be transferred across the PCI Express bus more quickly on some\n system configurations, but cannot be read efficiently by most CPUs.  WC\n memory is a good option for buffers that will be written by the CPU and read\n by the device via mapped pinned memory or host->device transfers.\n\n All of these flags are orthogonal to one another: a developer may allocate\n memory that is portable, mapped and/or write-combined with no restrictions.\n\n In order for the ::cudaHostAllocMapped flag to have any effect, the CUDA context\n must support the ::cudaDeviceMapHost flag, which can be checked via\n ::cudaGetDeviceFlags(). The ::cudaDeviceMapHost flag is implicitly set for\n contexts created via the runtime API.\n\n The ::cudaHostAllocMapped flag may be specified on CUDA contexts for devices\n that do not support mapped pinned memory. The failure is deferred to\n ::cudaHostGetDevicePointer() because the memory may be mapped into other\n CUDA contexts via the ::cudaHostAllocPortable flag.\n\n Memory allocated by this function must be freed with ::cudaFreeHost().\n\n \\param pHost - Device pointer to allocated memory\n \\param size  - Requested allocation size in bytes\n \\param flags - Requested properties of allocated memory\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaSetDeviceFlags,\n \\ref ::cudaMallocHost(void**, size_t) \"cudaMallocHost (C API)\",\n ::cudaFreeHost,\n ::cudaGetDeviceFlags,\n ::cuMemHostAlloc"]
    pub fn cudaHostAlloc(
        pHost: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Registers an existing host memory range for use by CUDA\n\n Page-locks the memory range specified by \\p ptr and \\p size and maps it\n for the device(s) as specified by \\p flags. This memory range also is added\n to the same tracking mechanism as ::cudaHostAlloc() to automatically accelerate\n calls to functions such as ::cudaMemcpy(). Since the memory can be accessed\n directly by the device, it can be read or written with much higher bandwidth\n than pageable memory that has not been registered.  Page-locking excessive\n amounts of memory may degrade system performance, since it reduces the amount\n of memory available to the system for paging. As a result, this function is\n best used sparingly to register staging areas for data exchange between\n host and device.\n\n ::cudaHostRegister is supported only on I/O coherent devices that have a non-zero\n value for the device attribute ::cudaDevAttrHostRegisterSupported.\n\n The \\p flags parameter enables different options to be specified that\n affect the allocation, as follows.\n\n - ::cudaHostRegisterDefault: On a system with unified virtual addressing,\n   the memory will be both mapped and portable.  On a system with no unified\n   virtual addressing, the memory will be neither mapped nor portable.\n\n - ::cudaHostRegisterPortable: The memory returned by this call will be\n   considered as pinned memory by all CUDA contexts, not just the one that\n   performed the allocation.\n\n - ::cudaHostRegisterMapped: Maps the allocation into the CUDA address\n   space. The device pointer to the memory may be obtained by calling\n   ::cudaHostGetDevicePointer().\n\n - ::cudaHostRegisterIoMemory: The passed memory pointer is treated as\n   pointing to some memory-mapped I/O space, e.g. belonging to a\n   third-party PCIe device, and it will marked as non cache-coherent and\n   contiguous.\n\n - ::cudaHostRegisterReadOnly: The passed memory pointer is treated as\n   pointing to memory that is considered read-only by the device.  On\n   platforms without ::cudaDevAttrPageableMemoryAccessUsesHostPageTables, this\n   flag is required in order to register memory mapped to the CPU as\n   read-only.  Support for the use of this flag can be queried from the device\n   attribute cudaDeviceAttrReadOnlyHostRegisterSupported.  Using this flag with\n   a current context associated with a device that does not have this attribute\n   set will cause ::cudaHostRegister to error with cudaErrorNotSupported.\n\n All of these flags are orthogonal to one another: a developer may page-lock\n memory that is portable or mapped with no restrictions.\n\n The CUDA context must have been created with the ::cudaMapHost flag in\n order for the ::cudaHostRegisterMapped flag to have any effect.\n\n The ::cudaHostRegisterMapped flag may be specified on CUDA contexts for\n devices that do not support mapped pinned memory. The failure is deferred\n to ::cudaHostGetDevicePointer() because the memory may be mapped into\n other CUDA contexts via the ::cudaHostRegisterPortable flag.\n\n For devices that have a non-zero value for the device attribute\n ::cudaDevAttrCanUseHostPointerForRegisteredMem, the memory\n can also be accessed from the device using the host pointer \\p ptr.\n The device pointer returned by ::cudaHostGetDevicePointer() may or may not\n match the original host pointer \\p ptr and depends on the devices visible to the\n application. If all devices visible to the application have a non-zero value for the\n device attribute, the device pointer returned by ::cudaHostGetDevicePointer()\n will match the original pointer \\p ptr. If any device visible to the application\n has a zero value for the device attribute, the device pointer returned by\n ::cudaHostGetDevicePointer() will not match the original host pointer \\p ptr,\n but it will be suitable for use on all devices provided Unified Virtual Addressing\n is enabled. In such systems, it is valid to access the memory using either pointer\n on devices that have a non-zero value for the device attribute. Note however that\n such devices should access the memory using only of the two pointers and not both.\n\n The memory page-locked by this function must be unregistered with ::cudaHostUnregister().\n\n \\param ptr   - Host pointer to memory to page-lock\n \\param size  - Size in bytes of the address range to page-lock in bytes\n \\param flags - Flags for allocation request\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation,\n ::cudaErrorHostMemoryAlreadyRegistered,\n ::cudaErrorNotSupported\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaHostUnregister, ::cudaHostGetFlags, ::cudaHostGetDevicePointer,\n ::cuMemHostRegister"]
    pub fn cudaHostRegister(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Unregisters a memory range that was registered with cudaHostRegister\n\n Unmaps the memory range whose base address is specified by \\p ptr, and makes\n it pageable again.\n\n The base address must be the same one specified to ::cudaHostRegister().\n\n \\param ptr - Host pointer to memory to unregister\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorHostMemoryNotRegistered\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaHostUnregister,\n ::cuMemHostUnregister"]
    pub fn cudaHostUnregister(ptr: *mut ::std::os::raw::c_void) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Passes back device pointer of mapped host memory allocated by\n cudaHostAlloc or registered by cudaHostRegister\n\n Passes back the device pointer corresponding to the mapped, pinned host\n buffer allocated by ::cudaHostAlloc() or registered by ::cudaHostRegister().\n\n ::cudaHostGetDevicePointer() will fail if the ::cudaDeviceMapHost flag was\n not specified before deferred context creation occurred, or if called on a\n device that does not support mapped, pinned memory.\n\n For devices that have a non-zero value for the device attribute\n ::cudaDevAttrCanUseHostPointerForRegisteredMem, the memory\n can also be accessed from the device using the host pointer \\p pHost.\n The device pointer returned by ::cudaHostGetDevicePointer() may or may not\n match the original host pointer \\p pHost and depends on the devices visible to the\n application. If all devices visible to the application have a non-zero value for the\n device attribute, the device pointer returned by ::cudaHostGetDevicePointer()\n will match the original pointer \\p pHost. If any device visible to the application\n has a zero value for the device attribute, the device pointer returned by\n ::cudaHostGetDevicePointer() will not match the original host pointer \\p pHost,\n but it will be suitable for use on all devices provided Unified Virtual Addressing\n is enabled. In such systems, it is valid to access the memory using either pointer\n on devices that have a non-zero value for the device attribute. Note however that\n such devices should access the memory using only of the two pointers and not both.\n\n \\p flags provides for future releases.  For now, it must be set to 0.\n\n \\param pDevice - Returned device pointer for mapped memory\n \\param pHost   - Requested host pointer mapping\n \\param flags   - Flags for extensions (must be 0 for now)\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaSetDeviceFlags, ::cudaHostAlloc,\n ::cuMemHostGetDevicePointer"]
    pub fn cudaHostGetDevicePointer(
        pDevice: *mut *mut ::std::os::raw::c_void,
        pHost: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Passes back flags used to allocate pinned host memory allocated by\n cudaHostAlloc\n\n ::cudaHostGetFlags() will fail if the input pointer does not\n reside in an address range allocated by ::cudaHostAlloc().\n\n \\param pFlags - Returned flags word\n \\param pHost - Host pointer\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaHostAlloc,\n ::cuMemHostGetFlags"]
    pub fn cudaHostGetFlags(
        pFlags: *mut ::std::os::raw::c_uint,
        pHost: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Allocates logical 1D, 2D, or 3D memory objects on the device\n\n Allocates at least \\p width * \\p height * \\p depth bytes of linear memory\n on the device and returns a ::cudaPitchedPtr in which \\p ptr is a pointer\n to the allocated memory. The function may pad the allocation to ensure\n hardware alignment requirements are met. The pitch returned in the \\p pitch\n field of \\p pitchedDevPtr is the width in bytes of the allocation.\n\n The returned ::cudaPitchedPtr contains additional fields \\p xsize and\n \\p ysize, the logical width and height of the allocation, which are\n equivalent to the \\p width and \\p height \\p extent parameters provided by\n the programmer during allocation.\n\n For allocations of 2D and 3D objects, it is highly recommended that\n programmers perform allocations using ::cudaMalloc3D() or\n ::cudaMallocPitch(). Due to alignment restrictions in the hardware, this is\n especially true if the application will be performing memory copies\n involving 2D or 3D objects (whether linear memory or CUDA arrays).\n\n \\param pitchedDevPtr  - Pointer to allocated pitched device memory\n \\param extent         - Requested allocation size (\\p width field in bytes)\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMallocPitch, ::cudaFree, ::cudaMemcpy3D, ::cudaMemset3D,\n ::cudaMalloc3DArray, ::cudaMallocArray, ::cudaFreeArray,\n \\ref ::cudaMallocHost(void**, size_t) \"cudaMallocHost (C API)\",\n ::cudaFreeHost, ::cudaHostAlloc, ::make_cudaPitchedPtr, ::make_cudaExtent,\n ::cuMemAllocPitch"]
    pub fn cudaMalloc3D(pitchedDevPtr: *mut cudaPitchedPtr, extent: cudaExtent) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Allocate an array on the device\n\n Allocates a CUDA array according to the ::cudaChannelFormatDesc structure\n \\p desc and returns a handle to the new CUDA array in \\p *array.\n\n The ::cudaChannelFormatDesc is defined as:\n \\code\nstruct cudaChannelFormatDesc {\nint x, y, z, w;\nenum cudaChannelFormatKind f;\n};\n\\endcode\n where ::cudaChannelFormatKind is one of ::cudaChannelFormatKindSigned,\n ::cudaChannelFormatKindUnsigned, or ::cudaChannelFormatKindFloat.\n\n ::cudaMalloc3DArray() can allocate the following:\n\n - A 1D array is allocated if the height and depth extents are both zero.\n - A 2D array is allocated if only the depth extent is zero.\n - A 3D array is allocated if all three extents are non-zero.\n - A 1D layered CUDA array is allocated if only the height extent is zero and\n the cudaArrayLayered flag is set. Each layer is a 1D array. The number of layers is\n determined by the depth extent.\n - A 2D layered CUDA array is allocated if all three extents are non-zero and\n the cudaArrayLayered flag is set. Each layer is a 2D array. The number of layers is\n determined by the depth extent.\n - A cubemap CUDA array is allocated if all three extents are non-zero and the\n cudaArrayCubemap flag is set. Width must be equal to height, and depth must be six. A cubemap is\n a special type of 2D layered CUDA array, where the six layers represent the six faces of a cube.\n The order of the six layers in memory is the same as that listed in ::cudaGraphicsCubeFace.\n - A cubemap layered CUDA array is allocated if all three extents are non-zero, and both,\n cudaArrayCubemap and cudaArrayLayered flags are set. Width must be equal to height, and depth must be\n a multiple of six. A cubemap layered CUDA array is a special type of 2D layered CUDA array that consists\n of a collection of cubemaps. The first six layers represent the first cubemap, the next six layers form\n the second cubemap, and so on.\n\n\n The \\p flags parameter enables different options to be specified that affect\n the allocation, as follows.\n - ::cudaArrayDefault: This flag's value is defined to be 0 and provides default array allocation\n - ::cudaArrayLayered: Allocates a layered CUDA array, with the depth extent indicating the number of layers\n - ::cudaArrayCubemap: Allocates a cubemap CUDA array. Width must be equal to height, and depth must be six.\n   If the cudaArrayLayered flag is also set, depth must be a multiple of six.\n - ::cudaArraySurfaceLoadStore: Allocates a CUDA array that could be read from or written to using a surface\n   reference.\n - ::cudaArrayTextureGather: This flag indicates that texture gather operations will be performed on the CUDA\n   array. Texture gather can only be performed on 2D CUDA arrays.\n - ::cudaArraySparse: Allocates a CUDA array without physical backing memory. The subregions within this sparse array\n   can later be mapped onto a physical memory allocation by calling ::cuMemMapArrayAsync. This flag can only be used for\n   creating 2D, 3D or 2D layered sparse CUDA arrays. The physical backing memory must be allocated via ::cuMemCreate.\n - ::cudaArrayDeferredMapping: Allocates a CUDA array without physical backing memory. The entire array can\n   later be mapped onto a physical memory allocation by calling ::cuMemMapArrayAsync. The physical backing memory must be allocated\n   via ::cuMemCreate.\n\n The width, height and depth extents must meet certain size requirements as listed in the following table.\n All values are specified in elements.\n\n Note that 2D CUDA arrays have different size requirements if the ::cudaArrayTextureGather flag is set. In that\n case, the valid range for (width, height, depth) is ((1,maxTexture2DGather[0]), (1,maxTexture2DGather[1]), 0).\n\n \\xmlonly\n <table outputclass=\"xmlonly\">\n <tgroup cols=\"3\" colsep=\"1\" rowsep=\"1\">\n <colspec colname=\"c1\" colwidth=\"1.0*\"/>\n <colspec colname=\"c2\" colwidth=\"3.0*\"/>\n <colspec colname=\"c3\" colwidth=\"3.0*\"/>\n <thead>\n <row>\n <entry>CUDA array type</entry>\n <entry>Valid extents that must always be met {(width range in elements),\n (height range), (depth range)}</entry>\n <entry>Valid extents with cudaArraySurfaceLoadStore set {(width range in\n elements), (height range), (depth range)}</entry>\n </row>\n </thead>\n <tbody>\n <row>\n <entry>1D</entry>\n <entry>{ (1,maxTexture1D), 0, 0 }</entry>\n <entry>{ (1,maxSurface1D), 0, 0 }</entry>\n </row>\n <row>\n <entry>2D</entry>\n <entry>{ (1,maxTexture2D[0]), (1,maxTexture2D[1]), 0 }</entry>\n <entry>{ (1,maxSurface2D[0]), (1,maxSurface2D[1]), 0 }</entry>\n </row>\n <row>\n <entry>3D</entry>\n <entry>{ (1,maxTexture3D[0]), (1,maxTexture3D[1]), (1,maxTexture3D[2]) }\n OR { (1,maxTexture3DAlt[0]), (1,maxTexture3DAlt[1]),\n (1,maxTexture3DAlt[2]) }</entry>\n <entry>{ (1,maxSurface3D[0]), (1,maxSurface3D[1]), (1,maxSurface3D[2]) }</entry>\n </row>\n <row>\n <entry>1D Layered</entry>\n <entry>{ (1,maxTexture1DLayered[0]), 0, (1,maxTexture1DLayered[1]) }</entry>\n <entry>{ (1,maxSurface1DLayered[0]), 0, (1,maxSurface1DLayered[1]) }</entry>\n </row>\n <row>\n <entry>2D Layered</entry>\n <entry>{ (1,maxTexture2DLayered[0]), (1,maxTexture2DLayered[1]),\n (1,maxTexture2DLayered[2]) }</entry>\n <entry>{ (1,maxSurface2DLayered[0]), (1,maxSurface2DLayered[1]),\n (1,maxSurface2DLayered[2]) }</entry>\n </row>\n <row>\n <entry>Cubemap</entry>\n <entry>{ (1,maxTextureCubemap), (1,maxTextureCubemap), 6 }</entry>\n <entry>{ (1,maxSurfaceCubemap), (1,maxSurfaceCubemap), 6 }</entry>\n </row>\n <row>\n <entry>Cubemap Layered</entry>\n <entry>{ (1,maxTextureCubemapLayered[0]), (1,maxTextureCubemapLayered[0]),\n (1,maxTextureCubemapLayered[1]) }</entry>\n <entry>{ (1,maxSurfaceCubemapLayered[0]), (1,maxSurfaceCubemapLayered[0]),\n (1,maxSurfaceCubemapLayered[1]) }</entry>\n </row>\n </tbody>\n </tgroup>\n </table>\n \\endxmlonly\n\n \\param array  - Pointer to allocated array in device memory\n \\param desc   - Requested channel format\n \\param extent - Requested allocation size (\\p width field in elements)\n \\param flags  - Flags for extensions\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMalloc3D, ::cudaMalloc, ::cudaMallocPitch, ::cudaFree,\n ::cudaFreeArray,\n \\ref ::cudaMallocHost(void**, size_t) \"cudaMallocHost (C API)\",\n ::cudaFreeHost, ::cudaHostAlloc,\n ::make_cudaExtent,\n ::cuArray3DCreate"]
    pub fn cudaMalloc3DArray(
        array: *mut cudaArray_t,
        desc: *const cudaChannelFormatDesc,
        extent: cudaExtent,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Allocate a mipmapped array on the device\n\n Allocates a CUDA mipmapped array according to the ::cudaChannelFormatDesc structure\n \\p desc and returns a handle to the new CUDA mipmapped array in \\p *mipmappedArray.\n \\p numLevels specifies the number of mipmap levels to be allocated. This value is\n clamped to the range [1, 1 + floor(log2(max(width, height, depth)))].\n\n The ::cudaChannelFormatDesc is defined as:\n \\code\nstruct cudaChannelFormatDesc {\nint x, y, z, w;\nenum cudaChannelFormatKind f;\n};\n\\endcode\n where ::cudaChannelFormatKind is one of ::cudaChannelFormatKindSigned,\n ::cudaChannelFormatKindUnsigned, or ::cudaChannelFormatKindFloat.\n\n ::cudaMallocMipmappedArray() can allocate the following:\n\n - A 1D mipmapped array is allocated if the height and depth extents are both zero.\n - A 2D mipmapped array is allocated if only the depth extent is zero.\n - A 3D mipmapped array is allocated if all three extents are non-zero.\n - A 1D layered CUDA mipmapped array is allocated if only the height extent is zero and\n the cudaArrayLayered flag is set. Each layer is a 1D mipmapped array. The number of layers is\n determined by the depth extent.\n - A 2D layered CUDA mipmapped array is allocated if all three extents are non-zero and\n the cudaArrayLayered flag is set. Each layer is a 2D mipmapped array. The number of layers is\n determined by the depth extent.\n - A cubemap CUDA mipmapped array is allocated if all three extents are non-zero and the\n cudaArrayCubemap flag is set. Width must be equal to height, and depth must be six.\n The order of the six layers in memory is the same as that listed in ::cudaGraphicsCubeFace.\n - A cubemap layered CUDA mipmapped array is allocated if all three extents are non-zero, and both,\n cudaArrayCubemap and cudaArrayLayered flags are set. Width must be equal to height, and depth must be\n a multiple of six. A cubemap layered CUDA mipmapped array is a special type of 2D layered CUDA mipmapped\n array that consists of a collection of cubemap mipmapped arrays. The first six layers represent the\n first cubemap mipmapped array, the next six layers form the second cubemap mipmapped array, and so on.\n\n\n The \\p flags parameter enables different options to be specified that affect\n the allocation, as follows.\n - ::cudaArrayDefault: This flag's value is defined to be 0 and provides default mipmapped array allocation\n - ::cudaArrayLayered: Allocates a layered CUDA mipmapped array, with the depth extent indicating the number of layers\n - ::cudaArrayCubemap: Allocates a cubemap CUDA mipmapped array. Width must be equal to height, and depth must be six.\n   If the cudaArrayLayered flag is also set, depth must be a multiple of six.\n - ::cudaArraySurfaceLoadStore: This flag indicates that individual mipmap levels of the CUDA mipmapped array\n   will be read from or written to using a surface reference.\n - ::cudaArrayTextureGather: This flag indicates that texture gather operations will be performed on the CUDA\n   array. Texture gather can only be performed on 2D CUDA mipmapped arrays, and the gather operations are\n   performed only on the most detailed mipmap level.\n - ::cudaArraySparse: Allocates a CUDA mipmapped array without physical backing memory. The subregions within this sparse array\n   can later be mapped onto a physical memory allocation by calling ::cuMemMapArrayAsync. This flag can only be used for creating\n   2D, 3D or 2D layered sparse CUDA mipmapped arrays. The physical backing memory must be allocated via ::cuMemCreate.\n - ::cudaArrayDeferredMapping: Allocates a CUDA mipmapped array without physical backing memory. The entire array can\n   later be mapped onto a physical memory allocation by calling ::cuMemMapArrayAsync. The physical backing memory must be allocated\n   via ::cuMemCreate.\n\n The width, height and depth extents must meet certain size requirements as listed in the following table.\n All values are specified in elements.\n\n \\xmlonly\n <table outputclass=\"xmlonly\">\n <tgroup cols=\"3\" colsep=\"1\" rowsep=\"1\">\n <colspec colname=\"c1\" colwidth=\"1.0*\"/>\n <colspec colname=\"c2\" colwidth=\"3.0*\"/>\n <colspec colname=\"c3\" colwidth=\"3.0*\"/>\n <thead>\n <row>\n <entry>CUDA array type</entry>\n <entry>Valid extents that must always be met {(width range in elements),\n (height range), (depth range)}</entry>\n <entry>Valid extents with cudaArraySurfaceLoadStore set {(width range in\n elements), (height range), (depth range)}</entry>\n </row>\n </thead>\n <tbody>\n <row>\n <entry>1D</entry>\n <entry>{ (1,maxTexture1DMipmap), 0, 0 }</entry>\n <entry>{ (1,maxSurface1D), 0, 0 }</entry>\n </row>\n <row>\n <entry>2D</entry>\n <entry>{ (1,maxTexture2DMipmap[0]), (1,maxTexture2DMipmap[1]), 0 }</entry>\n <entry>{ (1,maxSurface2D[0]), (1,maxSurface2D[1]), 0 }</entry>\n </row>\n <row>\n <entry>3D</entry>\n <entry>{ (1,maxTexture3D[0]), (1,maxTexture3D[1]), (1,maxTexture3D[2]) }\n OR { (1,maxTexture3DAlt[0]), (1,maxTexture3DAlt[1]),\n (1,maxTexture3DAlt[2]) }</entry>\n <entry>{ (1,maxSurface3D[0]), (1,maxSurface3D[1]), (1,maxSurface3D[2]) }</entry>\n </row>\n <row>\n <entry>1D Layered</entry>\n <entry>{ (1,maxTexture1DLayered[0]), 0, (1,maxTexture1DLayered[1]) }</entry>\n <entry>{ (1,maxSurface1DLayered[0]), 0, (1,maxSurface1DLayered[1]) }</entry>\n </row>\n <row>\n <entry>2D Layered</entry>\n <entry>{ (1,maxTexture2DLayered[0]), (1,maxTexture2DLayered[1]),\n (1,maxTexture2DLayered[2]) }</entry>\n <entry>{ (1,maxSurface2DLayered[0]), (1,maxSurface2DLayered[1]),\n (1,maxSurface2DLayered[2]) }</entry>\n </row>\n <row>\n <entry>Cubemap</entry>\n <entry>{ (1,maxTextureCubemap), (1,maxTextureCubemap), 6 }</entry>\n <entry>{ (1,maxSurfaceCubemap), (1,maxSurfaceCubemap), 6 }</entry>\n </row>\n <row>\n <entry>Cubemap Layered</entry>\n <entry>{ (1,maxTextureCubemapLayered[0]), (1,maxTextureCubemapLayered[0]),\n (1,maxTextureCubemapLayered[1]) }</entry>\n <entry>{ (1,maxSurfaceCubemapLayered[0]), (1,maxSurfaceCubemapLayered[0]),\n (1,maxSurfaceCubemapLayered[1]) }</entry>\n </row>\n </tbody>\n </tgroup>\n </table>\n \\endxmlonly\n\n \\param mipmappedArray  - Pointer to allocated mipmapped array in device memory\n \\param desc            - Requested channel format\n \\param extent          - Requested allocation size (\\p width field in elements)\n \\param numLevels       - Number of mipmap levels to allocate\n \\param flags           - Flags for extensions\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMalloc3D, ::cudaMalloc, ::cudaMallocPitch, ::cudaFree,\n ::cudaFreeArray,\n \\ref ::cudaMallocHost(void**, size_t) \"cudaMallocHost (C API)\",\n ::cudaFreeHost, ::cudaHostAlloc,\n ::make_cudaExtent,\n ::cuMipmappedArrayCreate"]
    pub fn cudaMallocMipmappedArray(
        mipmappedArray: *mut cudaMipmappedArray_t,
        desc: *const cudaChannelFormatDesc,
        extent: cudaExtent,
        numLevels: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Gets a mipmap level of a CUDA mipmapped array\n\n Returns in \\p *levelArray a CUDA array that represents a single mipmap level\n of the CUDA mipmapped array \\p mipmappedArray.\n\n If \\p level is greater than the maximum number of levels in this mipmapped array,\n ::cudaErrorInvalidValue is returned.\n\n If \\p mipmappedArray is NULL,\n ::cudaErrorInvalidResourceHandle is returned.\n\n \\param levelArray     - Returned mipmap level CUDA array\n \\param mipmappedArray - CUDA mipmapped array\n \\param level          - Mipmap level\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMalloc3D, ::cudaMalloc, ::cudaMallocPitch, ::cudaFree,\n ::cudaFreeArray,\n \\ref ::cudaMallocHost(void**, size_t) \"cudaMallocHost (C API)\",\n ::cudaFreeHost, ::cudaHostAlloc,\n ::make_cudaExtent,\n ::cuMipmappedArrayGetLevel"]
    pub fn cudaGetMipmappedArrayLevel(
        levelArray: *mut cudaArray_t,
        mipmappedArray: cudaMipmappedArray_const_t,
        level: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between 3D objects\n\n\\code\nstruct cudaExtent {\nsize_t width;\nsize_t height;\nsize_t depth;\n};\nstruct cudaExtent make_cudaExtent(size_t w, size_t h, size_t d);\n\nstruct cudaPos {\nsize_t x;\nsize_t y;\nsize_t z;\n};\nstruct cudaPos make_cudaPos(size_t x, size_t y, size_t z);\n\nstruct cudaMemcpy3DParms {\ncudaArray_t           srcArray;\nstruct cudaPos        srcPos;\nstruct cudaPitchedPtr srcPtr;\ncudaArray_t           dstArray;\nstruct cudaPos        dstPos;\nstruct cudaPitchedPtr dstPtr;\nstruct cudaExtent     extent;\nenum cudaMemcpyKind   kind;\n};\n\\endcode\n\n ::cudaMemcpy3D() copies data betwen two 3D objects. The source and\n destination objects may be in either host memory, device memory, or a CUDA\n array. The source, destination, extent, and kind of copy performed is\n specified by the ::cudaMemcpy3DParms struct which should be initialized to\n zero before use:\n\\code\ncudaMemcpy3DParms myParms = {0};\n\\endcode\n\n The struct passed to ::cudaMemcpy3D() must specify one of \\p srcArray or\n \\p srcPtr and one of \\p dstArray or \\p dstPtr. Passing more than one\n non-zero source or destination will cause ::cudaMemcpy3D() to return an\n error.\n\n The \\p srcPos and \\p dstPos fields are optional offsets into the source and\n destination objects and are defined in units of each object's elements. The\n element for a host or device pointer is assumed to be <b>unsigned char</b>.\n\n The \\p extent field defines the dimensions of the transferred area in\n elements. If a CUDA array is participating in the copy, the extent is\n defined in terms of that array's elements. If no CUDA array is\n participating in the copy then the extents are defined in elements of\n <b>unsigned char</b>.\n\n The \\p kind field defines the direction of the copy. It must be one of\n ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n For ::cudaMemcpyHostToHost or ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost\n passed as kind and cudaArray type passed as source or destination, if the kind\n implies cudaArray type to be present on the host, ::cudaMemcpy3D() will\n disregard that implication and silently correct the kind based on the fact that\n cudaArray type can only be present on the device.\n\n If the source and destination are both arrays, ::cudaMemcpy3D() will return\n an error if they do not have the same element size.\n\n The source and destination object may not overlap. If overlapping source\n and destination objects are specified, undefined behavior will result.\n\n The source object must entirely contain the region defined by \\p srcPos\n and \\p extent. The destination object must entirely contain the region\n defined by \\p dstPos and \\p extent.\n\n ::cudaMemcpy3D() returns an error if the pitch of \\p srcPtr or \\p dstPtr\n exceeds the maximum allowed. The pitch of a ::cudaPitchedPtr allocated\n with ::cudaMalloc3D() will always be valid.\n\n \\param p - 3D memory copy parameters\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidPitchValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_sync\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMalloc3D, ::cudaMalloc3DArray, ::cudaMemset3D, ::cudaMemcpy3DAsync,\n ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::make_cudaExtent, ::make_cudaPos,\n ::cuMemcpy3D"]
    pub fn cudaMemcpy3D(p: *const cudaMemcpy3DParms) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies memory between devices\n\n Perform a 3D memory copy according to the parameters specified in\n \\p p.  See the definition of the ::cudaMemcpy3DPeerParms structure\n for documentation of its parameters.\n\n Note that this function is synchronous with respect to the host only if\n the source or destination of the transfer is host memory.  Note also\n that this copy is serialized with respect to all pending and future\n asynchronous work in to the current device, the copy's source device,\n and the copy's destination device (use ::cudaMemcpy3DPeerAsync to avoid\n this synchronization).\n\n \\param p - Parameters for the memory copy\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_sync\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpyPeer, ::cudaMemcpyAsync, ::cudaMemcpyPeerAsync,\n ::cudaMemcpy3DPeerAsync,\n ::cuMemcpy3DPeer"]
    pub fn cudaMemcpy3DPeer(p: *const cudaMemcpy3DPeerParms) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between 3D objects\n\n\\code\nstruct cudaExtent {\nsize_t width;\nsize_t height;\nsize_t depth;\n};\nstruct cudaExtent make_cudaExtent(size_t w, size_t h, size_t d);\n\nstruct cudaPos {\nsize_t x;\nsize_t y;\nsize_t z;\n};\nstruct cudaPos make_cudaPos(size_t x, size_t y, size_t z);\n\nstruct cudaMemcpy3DParms {\ncudaArray_t           srcArray;\nstruct cudaPos        srcPos;\nstruct cudaPitchedPtr srcPtr;\ncudaArray_t           dstArray;\nstruct cudaPos        dstPos;\nstruct cudaPitchedPtr dstPtr;\nstruct cudaExtent     extent;\nenum cudaMemcpyKind   kind;\n};\n\\endcode\n\n ::cudaMemcpy3DAsync() copies data betwen two 3D objects. The source and\n destination objects may be in either host memory, device memory, or a CUDA\n array. The source, destination, extent, and kind of copy performed is\n specified by the ::cudaMemcpy3DParms struct which should be initialized to\n zero before use:\n\\code\ncudaMemcpy3DParms myParms = {0};\n\\endcode\n\n The struct passed to ::cudaMemcpy3DAsync() must specify one of \\p srcArray\n or \\p srcPtr and one of \\p dstArray or \\p dstPtr. Passing more than one\n non-zero source or destination will cause ::cudaMemcpy3DAsync() to return an\n error.\n\n The \\p srcPos and \\p dstPos fields are optional offsets into the source and\n destination objects and are defined in units of each object's elements. The\n element for a host or device pointer is assumed to be <b>unsigned char</b>.\n For CUDA arrays, positions must be in the range [0, 2048) for any\n dimension.\n\n The \\p extent field defines the dimensions of the transferred area in\n elements. If a CUDA array is participating in the copy, the extent is\n defined in terms of that array's elements. If no CUDA array is\n participating in the copy then the extents are defined in elements of\n <b>unsigned char</b>.\n\n The \\p kind field defines the direction of the copy. It must be one of\n ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n For ::cudaMemcpyHostToHost or ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost\n passed as kind and cudaArray type passed as source or destination, if the kind\n implies cudaArray type to be present on the host, ::cudaMemcpy3DAsync() will\n disregard that implication and silently correct the kind based on the fact that\n cudaArray type can only be present on the device.\n\n If the source and destination are both arrays, ::cudaMemcpy3DAsync() will\n return an error if they do not have the same element size.\n\n The source and destination object may not overlap. If overlapping source\n and destination objects are specified, undefined behavior will result.\n\n The source object must lie entirely within the region defined by \\p srcPos\n and \\p extent. The destination object must lie entirely within the region\n defined by \\p dstPos and \\p extent.\n\n ::cudaMemcpy3DAsync() returns an error if the pitch of \\p srcPtr or\n \\p dstPtr exceeds the maximum allowed. The pitch of a\n ::cudaPitchedPtr allocated with ::cudaMalloc3D() will always be valid.\n\n ::cudaMemcpy3DAsync() is asynchronous with respect to the host, so\n the call may return before the copy is complete. The copy can optionally\n be associated to a stream by passing a non-zero \\p stream argument. If\n \\p kind is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and \\p stream\n is non-zero, the copy may overlap with operations in other streams.\n\n The device version of this function only handles device to device copies and\n cannot be given local or shared pointers.\n\n \\param p      - 3D memory copy parameters\n \\param stream - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidPitchValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMalloc3D, ::cudaMalloc3DArray, ::cudaMemset3D, ::cudaMemcpy3D,\n ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray, :::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::make_cudaExtent, ::make_cudaPos,\n ::cuMemcpy3DAsync"]
    pub fn cudaMemcpy3DAsync(p: *const cudaMemcpy3DParms, stream: cudaStream_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies memory between devices asynchronously.\n\n Perform a 3D memory copy according to the parameters specified in\n \\p p.  See the definition of the ::cudaMemcpy3DPeerParms structure\n for documentation of its parameters.\n\n \\param p      - Parameters for the memory copy\n \\param stream - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpyPeer, ::cudaMemcpyAsync, ::cudaMemcpyPeerAsync,\n ::cudaMemcpy3DPeerAsync,\n ::cuMemcpy3DPeerAsync"]
    pub fn cudaMemcpy3DPeerAsync(
        p: *const cudaMemcpy3DPeerParms,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Gets free and total device memory\n\n Returns in \\p *total the total amount of memory available to the the current context.\n Returns in \\p *free the amount of memory on the device that is free according to the OS.\n CUDA is not guaranteed to be able to allocate all of the memory that the OS reports as free.\n In a multi-tenet situation, free estimate returned is prone to race condition where\n a new allocation/free done by a different process or a different thread in the same\n process between the time when free memory was estimated and reported, will result in\n deviation in free value reported and actual free memory.\n\n The integrated GPU on Tegra shares memory with CPU and other component\n of the SoC. The free and total values returned by the API excludes\n the SWAP memory space maintained by the OS on some platforms.\n The OS may move some of the memory pages into swap area as the GPU or\n CPU allocate or access memory. See Tegra app note on how to calculate\n total and free memory on Tegra.\n\n \\param free  - Returned free memory in bytes\n \\param total - Returned total memory in bytes\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorLaunchFailure\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cuMemGetInfo"]
    pub fn cudaMemGetInfo(free: *mut usize, total: *mut usize) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Gets info about the specified cudaArray\n\n Returns in \\p *desc, \\p *extent and \\p *flags respectively, the type, shape\n and flags of \\p array.\n\n Any of \\p *desc, \\p *extent and \\p *flags may be specified as NULL.\n\n \\param desc   - Returned array type\n \\param extent - Returned array shape. 2D arrays will have depth of zero\n \\param flags  - Returned array flags\n \\param array  - The ::cudaArray to get info for\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cuArrayGetDescriptor,\n ::cuArray3DGetDescriptor"]
    pub fn cudaArrayGetInfo(
        desc: *mut cudaChannelFormatDesc,
        extent: *mut cudaExtent,
        flags: *mut ::std::os::raw::c_uint,
        array: cudaArray_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Gets a CUDA array plane from a CUDA array\n\n Returns in \\p pPlaneArray a CUDA array that represents a single format plane\n of the CUDA array \\p hArray.\n\n If \\p planeIdx is greater than the maximum number of planes in this array or if the array does\n not have a multi-planar format e.g: ::cudaChannelFormatKindNV12, then ::cudaErrorInvalidValue is returned.\n\n Note that if the \\p hArray has format ::cudaChannelFormatKindNV12, then passing in 0 for \\p planeIdx returns\n a CUDA array of the same size as \\p hArray but with one 8-bit channel and ::cudaChannelFormatKindUnsigned as its format kind.\n If 1 is passed for \\p planeIdx, then the returned CUDA array has half the height and width\n of \\p hArray with two 8-bit channels and ::cudaChannelFormatKindUnsigned as its format kind.\n\n \\param pPlaneArray   - Returned CUDA array referenced by the \\p planeIdx\n \\param hArray        - CUDA array\n \\param planeIdx      - Plane index\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n\n \\sa\n ::cuArrayGetPlane"]
    pub fn cudaArrayGetPlane(
        pPlaneArray: *mut cudaArray_t,
        hArray: cudaArray_t,
        planeIdx: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the memory requirements of a CUDA array\n\n Returns the memory requirements of a CUDA array in \\p memoryRequirements\n If the CUDA array is not allocated with flag ::cudaArrayDeferredMapping\n ::cudaErrorInvalidValue will be returned.\n\n The returned value in ::cudaArrayMemoryRequirements::size\n represents the total size of the CUDA array.\n The returned value in ::cudaArrayMemoryRequirements::alignment\n represents the alignment necessary for mapping the CUDA array.\n\n \\return\n ::cudaSuccess\n ::cudaErrorInvalidValue\n\n \\param[out] memoryRequirements - Pointer to ::cudaArrayMemoryRequirements\n \\param[in] array - CUDA array to get the memory requirements of\n \\param[in] device - Device to get the memory requirements for\n \\sa ::cudaMipmappedArrayGetMemoryRequirements"]
    pub fn cudaArrayGetMemoryRequirements(
        memoryRequirements: *mut cudaArrayMemoryRequirements,
        array: cudaArray_t,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the memory requirements of a CUDA mipmapped array\n\n Returns the memory requirements of a CUDA mipmapped array in \\p memoryRequirements\n If the CUDA mipmapped array is not allocated with flag ::cudaArrayDeferredMapping\n ::cudaErrorInvalidValue will be returned.\n\n The returned value in ::cudaArrayMemoryRequirements::size\n represents the total size of the CUDA mipmapped array.\n The returned value in ::cudaArrayMemoryRequirements::alignment\n represents the alignment necessary for mapping the CUDA mipmapped\n array.\n\n \\return\n ::cudaSuccess\n ::cudaErrorInvalidValue\n\n \\param[out] memoryRequirements - Pointer to ::cudaArrayMemoryRequirements\n \\param[in] mipmap - CUDA mipmapped array to get the memory requirements of\n \\param[in] device - Device to get the memory requirements for\n \\sa ::cudaArrayGetMemoryRequirements"]
    pub fn cudaMipmappedArrayGetMemoryRequirements(
        memoryRequirements: *mut cudaArrayMemoryRequirements,
        mipmap: cudaMipmappedArray_t,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaArrayGetSparseProperties(
        sparseProperties: *mut cudaArraySparseProperties,
        array: cudaArray_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaMipmappedArrayGetSparseProperties(
        sparseProperties: *mut cudaArraySparseProperties,
        mipmap: cudaMipmappedArray_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n Copies \\p count bytes from the memory area pointed to by \\p src to the\n memory area pointed to by \\p dst, where \\p kind specifies the direction\n of the copy, and must be one of ::cudaMemcpyHostToHost,\n ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing. Calling\n ::cudaMemcpy() with dst and src pointers that do not match the direction of\n the copy results in an undefined behavior.\n\n \\param dst   - Destination memory address\n \\param src   - Source memory address\n \\param count - Size in bytes to copy\n \\param kind  - Type of transfer\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\note_sync\n \\note_memcpy\n\n \\sa ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpyDtoH,\n ::cuMemcpyHtoD,\n ::cuMemcpyDtoD,\n ::cuMemcpy"]
    pub fn cudaMemcpy(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies memory between two devices\n\n Copies memory from one device to memory on another device.  \\p dst is the\n base device pointer of the destination memory and \\p dstDevice is the\n destination device.  \\p src is the base device pointer of the source memory\n and \\p srcDevice is the source device.  \\p count specifies the number of bytes\n to copy.\n\n Note that this function is asynchronous with respect to the host, but\n serialized with respect all pending and future asynchronous work in to the\n current device, \\p srcDevice, and \\p dstDevice (use ::cudaMemcpyPeerAsync\n to avoid this synchronization).\n\n \\param dst       - Destination device pointer\n \\param dstDevice - Destination device\n \\param src       - Source device pointer\n \\param srcDevice - Source device\n \\param count     - Size of memory copy in bytes\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_sync\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpyAsync, ::cudaMemcpyPeerAsync,\n ::cudaMemcpy3DPeerAsync,\n ::cuMemcpyPeer"]
    pub fn cudaMemcpyPeer(
        dst: *mut ::std::os::raw::c_void,
        dstDevice: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        srcDevice: ::std::os::raw::c_int,
        count: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n Copies a matrix (\\p height rows of \\p width bytes each) from the memory\n area pointed to by \\p src to the memory area pointed to by \\p dst, where\n \\p kind specifies the direction of the copy, and must be one of\n ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing. \\p dpitch and\n \\p spitch are the widths in memory in bytes of the 2D arrays pointed to by\n \\p dst and \\p src, including any padding added to the end of each row. The\n memory areas may not overlap. \\p width must not exceed either \\p dpitch or\n \\p spitch. Calling ::cudaMemcpy2D() with \\p dst and \\p src pointers that do\n not match the direction of the copy results in an undefined behavior.\n ::cudaMemcpy2D() returns an error if \\p dpitch or \\p spitch exceeds\n the maximum allowed.\n\n \\param dst    - Destination memory address\n \\param dpitch - Pitch of destination memory\n \\param src    - Source memory address\n \\param spitch - Pitch of source memory\n \\param width  - Width of matrix transfer (columns in bytes)\n \\param height - Height of matrix transfer (rows)\n \\param kind   - Type of transfer\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidPitchValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_init_rt\n \\note_callback\n \\note_memcpy\n\n \\sa ::cudaMemcpy,\n ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpy2D,\n ::cuMemcpy2DUnaligned"]
    pub fn cudaMemcpy2D(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n Copies a matrix (\\p height rows of \\p width bytes each) from the memory\n area pointed to by \\p src to the CUDA array \\p dst starting at\n \\p hOffset rows and \\p wOffset bytes from the upper left corner,\n where \\p kind specifies the direction of the copy, and must be one\n of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n \\p spitch is the width in memory in bytes of the 2D array pointed to by\n \\p src, including any padding added to the end of each row. \\p wOffset +\n \\p width must not exceed the width of the CUDA array \\p dst. \\p width must\n not exceed \\p spitch. ::cudaMemcpy2DToArray() returns an error if \\p spitch\n exceeds the maximum allowed.\n\n \\param dst     - Destination memory address\n \\param wOffset - Destination starting X offset (columns in bytes)\n \\param hOffset - Destination starting Y offset (rows)\n \\param src     - Source memory address\n \\param spitch  - Pitch of source memory\n \\param width   - Width of matrix transfer (columns in bytes)\n \\param height  - Height of matrix transfer (rows)\n \\param kind    - Type of transfer\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidPitchValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_sync\n \\note_init_rt\n \\note_callback\n \\note_memcpy\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpy2D,\n ::cuMemcpy2DUnaligned"]
    pub fn cudaMemcpy2DToArray(
        dst: cudaArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n Copies a matrix (\\p height rows of \\p width bytes each) from the CUDA\n array \\p src starting at \\p hOffset rows and \\p wOffset bytes from the\n upper left corner to the memory area pointed to by \\p dst, where\n \\p kind specifies the direction of the copy, and must be one of\n ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing. \\p dpitch is the\n width in memory in bytes of the 2D array pointed to by \\p dst, including any\n padding added to the end of each row. \\p wOffset + \\p width must not exceed\n the width of the CUDA array \\p src. \\p width must not exceed \\p dpitch.\n ::cudaMemcpy2DFromArray() returns an error if \\p dpitch exceeds the maximum\n allowed.\n\n \\param dst     - Destination memory address\n \\param dpitch  - Pitch of destination memory\n \\param src     - Source memory address\n \\param wOffset - Source starting X offset (columns in bytes)\n \\param hOffset - Source starting Y offset (rows)\n \\param width   - Width of matrix transfer (columns in bytes)\n \\param height  - Height of matrix transfer (rows)\n \\param kind    - Type of transfer\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidPitchValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_sync\n \\note_init_rt\n \\note_callback\n \\note_memcpy\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpy2D,\n ::cuMemcpy2DUnaligned"]
    pub fn cudaMemcpy2DFromArray(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: cudaArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n Copies a matrix (\\p height rows of \\p width bytes each) from the CUDA\n array \\p src starting at \\p hOffsetSrc rows and \\p wOffsetSrc bytes from the\n upper left corner to the CUDA array \\p dst starting at \\p hOffsetDst rows\n and \\p wOffsetDst bytes from the upper left corner, where \\p kind\n specifies the direction of the copy, and must be one of\n ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n \\p wOffsetDst + \\p width must not exceed the width of the CUDA array \\p dst.\n \\p wOffsetSrc + \\p width must not exceed the width of the CUDA array \\p src.\n\n \\param dst        - Destination memory address\n \\param wOffsetDst - Destination starting X offset (columns in bytes)\n \\param hOffsetDst - Destination starting Y offset (rows)\n \\param src        - Source memory address\n \\param wOffsetSrc - Source starting X offset (columns in bytes)\n \\param hOffsetSrc - Source starting Y offset (rows)\n \\param width      - Width of matrix transfer (columns in bytes)\n \\param height     - Height of matrix transfer (rows)\n \\param kind       - Type of transfer\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_sync\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpy2D,\n ::cuMemcpy2DUnaligned"]
    pub fn cudaMemcpy2DArrayToArray(
        dst: cudaArray_t,
        wOffsetDst: usize,
        hOffsetDst: usize,
        src: cudaArray_const_t,
        wOffsetSrc: usize,
        hOffsetSrc: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data to the given symbol on the device\n\n Copies \\p count bytes from the memory area pointed to by \\p src\n to the memory area pointed to by \\p offset bytes from the start of symbol\n \\p symbol. The memory areas may not overlap. \\p symbol is a variable that\n resides in global or constant memory space. \\p kind can be either\n ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault.\n Passing ::cudaMemcpyDefault is recommended, in which case the type of\n transfer is inferred from the pointer values. However, ::cudaMemcpyDefault\n is only allowed on systems that support unified virtual addressing.\n\n \\param symbol - Device symbol address\n \\param src    - Source memory address\n \\param count  - Size in bytes to copy\n \\param offset - Offset from start of symbol in bytes\n \\param kind   - Type of transfer\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidSymbol,\n ::cudaErrorInvalidMemcpyDirection,\n ::cudaErrorNoKernelImageForDevice\n \\notefnerr\n \\note_sync\n \\note_string_api_deprecation\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray,  ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpy,\n ::cuMemcpyHtoD,\n ::cuMemcpyDtoD"]
    pub fn cudaMemcpyToSymbol(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data from the given symbol on the device\n\n Copies \\p count bytes from the memory area pointed to by \\p offset bytes\n from the start of symbol \\p symbol to the memory area pointed to by \\p dst.\n The memory areas may not overlap. \\p symbol is a variable that\n resides in global or constant memory space. \\p kind can be either\n ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault.\n Passing ::cudaMemcpyDefault is recommended, in which case the type of\n transfer is inferred from the pointer values. However, ::cudaMemcpyDefault\n is only allowed on systems that support unified virtual addressing.\n\n \\param dst    - Destination memory address\n \\param symbol - Device symbol address\n \\param count  - Size in bytes to copy\n \\param offset - Offset from start of symbol in bytes\n \\param kind   - Type of transfer\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidSymbol,\n ::cudaErrorInvalidMemcpyDirection,\n ::cudaErrorNoKernelImageForDevice\n \\notefnerr\n \\note_sync\n \\note_string_api_deprecation\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpy,\n ::cuMemcpyDtoH,\n ::cuMemcpyDtoD"]
    pub fn cudaMemcpyFromSymbol(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n Copies \\p count bytes from the memory area pointed to by \\p src to the\n memory area pointed to by \\p dst, where \\p kind specifies the\n direction of the copy, and must be one of ::cudaMemcpyHostToHost,\n ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n\n The memory areas may not overlap. Calling ::cudaMemcpyAsync() with \\p dst and\n \\p src pointers that do not match the direction of the copy results in an\n undefined behavior.\n\n ::cudaMemcpyAsync() is asynchronous with respect to the host, so the call\n may return before the copy is complete. The copy can optionally be\n associated to a stream by passing a non-zero \\p stream argument. If \\p kind\n is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and the \\p stream is\n non-zero, the copy may overlap with operations in other streams.\n\n The device version of this function only handles device to device copies and\n cannot be given local or shared pointers.\n\n \\param dst    - Destination memory address\n \\param src    - Source memory address\n \\param count  - Size in bytes to copy\n \\param kind   - Type of transfer\n \\param stream - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n \\note_memcpy\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpyAsync,\n ::cuMemcpyDtoHAsync,\n ::cuMemcpyHtoDAsync,\n ::cuMemcpyDtoDAsync"]
    pub fn cudaMemcpyAsync(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies memory between two devices asynchronously.\n\n Copies memory from one device to memory on another device.  \\p dst is the\n base device pointer of the destination memory and \\p dstDevice is the\n destination device.  \\p src is the base device pointer of the source memory\n and \\p srcDevice is the source device.  \\p count specifies the number of bytes\n to copy.\n\n Note that this function is asynchronous with respect to the host and all work\n on other devices.\n\n \\param dst       - Destination device pointer\n \\param dstDevice - Destination device\n \\param src       - Source device pointer\n \\param srcDevice - Source device\n \\param count     - Size of memory copy in bytes\n \\param stream    - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpyPeer, ::cudaMemcpyAsync,\n ::cudaMemcpy3DPeerAsync,\n ::cuMemcpyPeerAsync"]
    pub fn cudaMemcpyPeerAsync(
        dst: *mut ::std::os::raw::c_void,
        dstDevice: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        srcDevice: ::std::os::raw::c_int,
        count: usize,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n Copies a matrix (\\p height rows of \\p width bytes each) from the memory\n area pointed to by \\p src to the memory area pointed to by \\p dst, where\n \\p kind specifies the direction of the copy, and must be one of\n ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n \\p dpitch and \\p spitch are the widths in memory in bytes of the 2D arrays\n pointed to by \\p dst and \\p src, including any padding added to the end of\n each row. The memory areas may not overlap. \\p width must not exceed either\n \\p dpitch or \\p spitch.\n\n Calling ::cudaMemcpy2DAsync() with \\p dst and \\p src pointers that do not\n match the direction of the copy results in an undefined behavior.\n ::cudaMemcpy2DAsync() returns an error if \\p dpitch or \\p spitch is greater\n than the maximum allowed.\n\n ::cudaMemcpy2DAsync() is asynchronous with respect to the host, so\n the call may return before the copy is complete. The copy can optionally\n be associated to a stream by passing a non-zero \\p stream argument. If\n \\p kind is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and\n \\p stream is non-zero, the copy may overlap with operations in other\n streams.\n\n The device version of this function only handles device to device copies and\n cannot be given local or shared pointers.\n\n \\param dst    - Destination memory address\n \\param dpitch - Pitch of destination memory\n \\param src    - Source memory address\n \\param spitch - Pitch of source memory\n \\param width  - Width of matrix transfer (columns in bytes)\n \\param height - Height of matrix transfer (rows)\n \\param kind   - Type of transfer\n \\param stream - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidPitchValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n \\note_memcpy\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpy2DAsync"]
    pub fn cudaMemcpy2DAsync(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n Copies a matrix (\\p height rows of \\p width bytes each) from the memory\n area pointed to by \\p src to the CUDA array \\p dst starting at \\p hOffset\n rows and \\p wOffset bytes from the upper left corner, where \\p kind specifies\n the direction of the copy, and must be one of ::cudaMemcpyHostToHost,\n ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n \\p spitch is the width in memory in bytes of the 2D array pointed to by\n \\p src, including any padding added to the end of each row. \\p wOffset +\n \\p width must not exceed the width of the CUDA array \\p dst. \\p width must\n not exceed \\p spitch. ::cudaMemcpy2DToArrayAsync() returns an error if\n \\p spitch exceeds the maximum allowed.\n\n ::cudaMemcpy2DToArrayAsync() is asynchronous with respect to the host, so\n the call may return before the copy is complete. The copy can optionally\n be associated to a stream by passing a non-zero \\p stream argument. If\n \\p kind is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and\n \\p stream is non-zero, the copy may overlap with operations in other\n streams.\n\n \\param dst     - Destination memory address\n \\param wOffset - Destination starting X offset (columns in bytes)\n \\param hOffset - Destination starting Y offset (rows)\n \\param src     - Source memory address\n \\param spitch  - Pitch of source memory\n \\param width   - Width of matrix transfer (columns in bytes)\n \\param height  - Height of matrix transfer (rows)\n \\param kind    - Type of transfer\n \\param stream  - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidPitchValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n \\note_memcpy\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpy2DAsync"]
    pub fn cudaMemcpy2DToArrayAsync(
        dst: cudaArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n Copies a matrix (\\p height rows of \\p width bytes each) from the CUDA\n array \\p src starting at \\p hOffset rows and \\p wOffset bytes from the\n upper left corner to the memory area pointed to by \\p dst,\n where \\p kind specifies the direction of the copy, and must be one of\n ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n \\p dpitch is the width in memory in bytes of the 2D\n array pointed to by \\p dst, including any padding added to the end of each\n row. \\p wOffset + \\p width must not exceed the width of the CUDA array\n \\p src. \\p width must not exceed \\p dpitch. ::cudaMemcpy2DFromArrayAsync()\n returns an error if \\p dpitch exceeds the maximum allowed.\n\n ::cudaMemcpy2DFromArrayAsync() is asynchronous with respect to the host, so\n the call may return before the copy is complete. The copy can optionally be\n associated to a stream by passing a non-zero \\p stream argument. If \\p kind\n is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and \\p stream is\n non-zero, the copy may overlap with operations in other streams.\n\n \\param dst     - Destination memory address\n \\param dpitch  - Pitch of destination memory\n \\param src     - Source memory address\n \\param wOffset - Source starting X offset (columns in bytes)\n \\param hOffset - Source starting Y offset (rows)\n \\param width   - Width of matrix transfer (columns in bytes)\n \\param height  - Height of matrix transfer (rows)\n \\param kind    - Type of transfer\n \\param stream  - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidPitchValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n \\note_memcpy\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpy2DAsync"]
    pub fn cudaMemcpy2DFromArrayAsync(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: cudaArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data to the given symbol on the device\n\n Copies \\p count bytes from the memory area pointed to by \\p src\n to the memory area pointed to by \\p offset bytes from the start of symbol\n \\p symbol. The memory areas may not overlap. \\p symbol is a variable that\n resides in global or constant memory space. \\p kind can be either\n ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault.\n Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer\n is inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n\n ::cudaMemcpyToSymbolAsync() is asynchronous with respect to the host, so\n the call may return before the copy is complete. The copy can optionally\n be associated to a stream by passing a non-zero \\p stream argument. If\n \\p kind is ::cudaMemcpyHostToDevice and \\p stream is non-zero, the copy\n may overlap with operations in other streams.\n\n \\param symbol - Device symbol address\n \\param src    - Source memory address\n \\param count  - Size in bytes to copy\n \\param offset - Offset from start of symbol in bytes\n \\param kind   - Type of transfer\n \\param stream - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidSymbol,\n ::cudaErrorInvalidMemcpyDirection,\n ::cudaErrorNoKernelImageForDevice\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_string_api_deprecation\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpyAsync,\n ::cuMemcpyHtoDAsync,\n ::cuMemcpyDtoDAsync"]
    pub fn cudaMemcpyToSymbolAsync(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data from the given symbol on the device\n\n Copies \\p count bytes from the memory area pointed to by \\p offset bytes\n from the start of symbol \\p symbol to the memory area pointed to by \\p dst.\n The memory areas may not overlap. \\p symbol is a variable that resides in\n global or constant memory space. \\p kind can be either\n ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault.\n Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer\n is inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n\n ::cudaMemcpyFromSymbolAsync() is asynchronous with respect to the host, so\n the call may return before the copy is complete. The copy can optionally be\n associated to a stream by passing a non-zero \\p stream argument. If \\p kind\n is ::cudaMemcpyDeviceToHost and \\p stream is non-zero, the copy may overlap\n with operations in other streams.\n\n \\param dst    - Destination memory address\n \\param symbol - Device symbol address\n \\param count  - Size in bytes to copy\n \\param offset - Offset from start of symbol in bytes\n \\param kind   - Type of transfer\n \\param stream - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidSymbol,\n ::cudaErrorInvalidMemcpyDirection,\n ::cudaErrorNoKernelImageForDevice\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_string_api_deprecation\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync,\n ::cuMemcpyAsync,\n ::cuMemcpyDtoHAsync,\n ::cuMemcpyDtoDAsync"]
    pub fn cudaMemcpyFromSymbolAsync(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Initializes or sets device memory to a value\n\n Fills the first \\p count bytes of the memory area pointed to by \\p devPtr\n with the constant byte value \\p value.\n\n Note that this function is asynchronous with respect to the host unless\n \\p devPtr refers to pinned host memory.\n\n \\param devPtr - Pointer to device memory\n \\param value  - Value to set for each byte of specified memory\n \\param count  - Size in bytes to set\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n \\notefnerr\n \\note_memset\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cuMemsetD8,\n ::cuMemsetD16,\n ::cuMemsetD32"]
    pub fn cudaMemset(
        devPtr: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        count: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Initializes or sets device memory to a value\n\n Sets to the specified value \\p value a matrix (\\p height rows of \\p width\n bytes each) pointed to by \\p dstPtr. \\p pitch is the width in bytes of the\n 2D array pointed to by \\p dstPtr, including any padding added to the end\n of each row. This function performs fastest when the pitch is one that has\n been passed back by ::cudaMallocPitch().\n\n Note that this function is asynchronous with respect to the host unless\n \\p devPtr refers to pinned host memory.\n\n \\param devPtr - Pointer to 2D device memory\n \\param pitch  - Pitch in bytes of 2D device memory(Unused if \\p height is 1)\n \\param value  - Value to set for each byte of specified memory\n \\param width  - Width of matrix set (columns in bytes)\n \\param height - Height of matrix set (rows)\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n \\notefnerr\n \\note_memset\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemset, ::cudaMemset3D, ::cudaMemsetAsync,\n ::cudaMemset2DAsync, ::cudaMemset3DAsync,\n ::cuMemsetD2D8,\n ::cuMemsetD2D16,\n ::cuMemsetD2D32"]
    pub fn cudaMemset2D(
        devPtr: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Initializes or sets device memory to a value\n\n Initializes each element of a 3D array to the specified value \\p value.\n The object to initialize is defined by \\p pitchedDevPtr. The \\p pitch field\n of \\p pitchedDevPtr is the width in memory in bytes of the 3D array pointed\n to by \\p pitchedDevPtr, including any padding added to the end of each row.\n The \\p xsize field specifies the logical width of each row in bytes, while\n the \\p ysize field specifies the height of each 2D slice in rows.\n The \\p pitch field of \\p pitchedDevPtr is ignored when \\p height and \\p depth\n are both equal to 1.\n\n The extents of the initialized region are specified as a \\p width in bytes,\n a \\p height in rows, and a \\p depth in slices.\n\n Extents with \\p width greater than or equal to the \\p xsize of\n \\p pitchedDevPtr may perform significantly faster than extents narrower\n than the \\p xsize. Secondarily, extents with \\p height equal to the\n \\p ysize of \\p pitchedDevPtr will perform faster than when the \\p height is\n shorter than the \\p ysize.\n\n This function performs fastest when the \\p pitchedDevPtr has been allocated\n by ::cudaMalloc3D().\n\n Note that this function is asynchronous with respect to the host unless\n \\p pitchedDevPtr refers to pinned host memory.\n\n \\param pitchedDevPtr - Pointer to pitched device memory\n \\param value         - Value to set for each byte of specified memory\n \\param extent        - Size parameters for where to set device memory (\\p width field in bytes)\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n \\notefnerr\n \\note_memset\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemset, ::cudaMemset2D,\n ::cudaMemsetAsync, ::cudaMemset2DAsync, ::cudaMemset3DAsync,\n ::cudaMalloc3D, ::make_cudaPitchedPtr,\n ::make_cudaExtent"]
    pub fn cudaMemset3D(
        pitchedDevPtr: cudaPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: cudaExtent,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Initializes or sets device memory to a value\n\n Fills the first \\p count bytes of the memory area pointed to by \\p devPtr\n with the constant byte value \\p value.\n\n ::cudaMemsetAsync() is asynchronous with respect to the host, so\n the call may return before the memset is complete. The operation can optionally\n be associated to a stream by passing a non-zero \\p stream argument.\n If \\p stream is non-zero, the operation may overlap with operations in other streams.\n\n The device version of this function only handles device to device copies and\n cannot be given local or shared pointers.\n\n \\param devPtr - Pointer to device memory\n \\param value  - Value to set for each byte of specified memory\n \\param count  - Size in bytes to set\n \\param stream - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n \\notefnerr\n \\note_memset\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemset, ::cudaMemset2D, ::cudaMemset3D,\n ::cudaMemset2DAsync, ::cudaMemset3DAsync,\n ::cuMemsetD8Async,\n ::cuMemsetD16Async,\n ::cuMemsetD32Async"]
    pub fn cudaMemsetAsync(
        devPtr: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        count: usize,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Initializes or sets device memory to a value\n\n Sets to the specified value \\p value a matrix (\\p height rows of \\p width\n bytes each) pointed to by \\p dstPtr. \\p pitch is the width in bytes of the\n 2D array pointed to by \\p dstPtr, including any padding added to the end\n of each row. This function performs fastest when the pitch is one that has\n been passed back by ::cudaMallocPitch().\n\n ::cudaMemset2DAsync() is asynchronous with respect to the host, so\n the call may return before the memset is complete. The operation can optionally\n be associated to a stream by passing a non-zero \\p stream argument.\n If \\p stream is non-zero, the operation may overlap with operations in other streams.\n\n The device version of this function only handles device to device copies and\n cannot be given local or shared pointers.\n\n \\param devPtr - Pointer to 2D device memory\n \\param pitch  - Pitch in bytes of 2D device memory(Unused if \\p height is 1)\n \\param value  - Value to set for each byte of specified memory\n \\param width  - Width of matrix set (columns in bytes)\n \\param height - Height of matrix set (rows)\n \\param stream - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n \\notefnerr\n \\note_memset\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemset, ::cudaMemset2D, ::cudaMemset3D,\n ::cudaMemsetAsync, ::cudaMemset3DAsync,\n ::cuMemsetD2D8Async,\n ::cuMemsetD2D16Async,\n ::cuMemsetD2D32Async"]
    pub fn cudaMemset2DAsync(
        devPtr: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Initializes or sets device memory to a value\n\n Initializes each element of a 3D array to the specified value \\p value.\n The object to initialize is defined by \\p pitchedDevPtr. The \\p pitch field\n of \\p pitchedDevPtr is the width in memory in bytes of the 3D array pointed\n to by \\p pitchedDevPtr, including any padding added to the end of each row.\n The \\p xsize field specifies the logical width of each row in bytes, while\n the \\p ysize field specifies the height of each 2D slice in rows.\n The \\p pitch field of \\p pitchedDevPtr is ignored when \\p height and \\p depth\n are both equal to 1.\n\n The extents of the initialized region are specified as a \\p width in bytes,\n a \\p height in rows, and a \\p depth in slices.\n\n Extents with \\p width greater than or equal to the \\p xsize of\n \\p pitchedDevPtr may perform significantly faster than extents narrower\n than the \\p xsize. Secondarily, extents with \\p height equal to the\n \\p ysize of \\p pitchedDevPtr will perform faster than when the \\p height is\n shorter than the \\p ysize.\n\n This function performs fastest when the \\p pitchedDevPtr has been allocated\n by ::cudaMalloc3D().\n\n ::cudaMemset3DAsync() is asynchronous with respect to the host, so\n the call may return before the memset is complete. The operation can optionally\n be associated to a stream by passing a non-zero \\p stream argument.\n If \\p stream is non-zero, the operation may overlap with operations in other streams.\n\n The device version of this function only handles device to device copies and\n cannot be given local or shared pointers.\n\n \\param pitchedDevPtr - Pointer to pitched device memory\n \\param value         - Value to set for each byte of specified memory\n \\param extent        - Size parameters for where to set device memory (\\p width field in bytes)\n \\param stream - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n \\notefnerr\n \\note_memset\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemset, ::cudaMemset2D, ::cudaMemset3D,\n ::cudaMemsetAsync, ::cudaMemset2DAsync,\n ::cudaMalloc3D, ::make_cudaPitchedPtr,\n ::make_cudaExtent"]
    pub fn cudaMemset3DAsync(
        pitchedDevPtr: cudaPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: cudaExtent,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Finds the address associated with a CUDA symbol\n\n Returns in \\p *devPtr the address of symbol \\p symbol on the device.\n \\p symbol is a variable that resides in global or constant memory space.\n If \\p symbol cannot be found, or if \\p symbol is not declared in the\n global or constant memory space, \\p *devPtr is unchanged and the error\n ::cudaErrorInvalidSymbol is returned.\n\n \\param devPtr - Return device pointer associated with symbol\n \\param symbol - Device symbol address\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidSymbol,\n ::cudaErrorNoKernelImageForDevice\n \\notefnerr\n \\note_string_api_deprecation\n \\note_init_rt\n \\note_callback\n\n \\sa\n \\ref ::cudaGetSymbolAddress(void**, const T&) \"cudaGetSymbolAddress (C++ API)\",\n \\ref ::cudaGetSymbolSize(size_t*, const void*) \"cudaGetSymbolSize (C API)\",\n ::cuModuleGetGlobal"]
    pub fn cudaGetSymbolAddress(
        devPtr: *mut *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Finds the size of the object associated with a CUDA symbol\n\n Returns in \\p *size the size of symbol \\p symbol. \\p symbol is a variable that\n resides in global or constant memory space. If \\p symbol cannot be found, or\n if \\p symbol is not declared in global or constant memory space, \\p *size is\n unchanged and the error ::cudaErrorInvalidSymbol is returned.\n\n \\param size   - Size of object associated with symbol\n \\param symbol - Device symbol address\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidSymbol,\n ::cudaErrorNoKernelImageForDevice\n \\notefnerr\n \\note_string_api_deprecation\n \\note_init_rt\n \\note_callback\n\n \\sa\n \\ref ::cudaGetSymbolAddress(void**, const void*) \"cudaGetSymbolAddress (C API)\",\n \\ref ::cudaGetSymbolSize(size_t*, const T&) \"cudaGetSymbolSize (C++ API)\",\n ::cuModuleGetGlobal"]
    pub fn cudaGetSymbolSize(
        size: *mut usize,
        symbol: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Prefetches memory to the specified destination device\n\n Prefetches memory to the specified destination device.  \\p devPtr is the\n base device pointer of the memory to be prefetched and \\p dstDevice is the\n destination device. \\p count specifies the number of bytes to copy. \\p stream\n is the stream in which the operation is enqueued. The memory range must refer\n to managed memory allocated via ::cudaMallocManaged or declared via __managed__ variables.\n\n Passing in cudaCpuDeviceId for \\p dstDevice will prefetch the data to host memory. If\n \\p dstDevice is a GPU, then the device attribute ::cudaDevAttrConcurrentManagedAccess\n must be non-zero. Additionally, \\p stream must be associated with a device that has a\n non-zero value for the device attribute ::cudaDevAttrConcurrentManagedAccess.\n\n The start address and end address of the memory range will be rounded down and rounded up\n respectively to be aligned to CPU page size before the prefetch operation is enqueued\n in the stream.\n\n If no physical memory has been allocated for this region, then this memory region\n will be populated and mapped on the destination device. If there's insufficient\n memory to prefetch the desired region, the Unified Memory driver may evict pages from other\n ::cudaMallocManaged allocations to host memory in order to make room. Device memory\n allocated using ::cudaMalloc or ::cudaMallocArray will not be evicted.\n\n By default, any mappings to the previous location of the migrated pages are removed and\n mappings for the new location are only setup on \\p dstDevice. The exact behavior however\n also depends on the settings applied to this memory range via ::cudaMemAdvise as described\n below:\n\n If ::cudaMemAdviseSetReadMostly was set on any subset of this memory range,\n then that subset will create a read-only copy of the pages on \\p dstDevice.\n\n If ::cudaMemAdviseSetPreferredLocation was called on any subset of this memory\n range, then the pages will be migrated to \\p dstDevice even if \\p dstDevice is not the\n preferred location of any pages in the memory range.\n\n If ::cudaMemAdviseSetAccessedBy was called on any subset of this memory range,\n then mappings to those pages from all the appropriate processors are updated to\n refer to the new location if establishing such a mapping is possible. Otherwise,\n those mappings are cleared.\n\n Note that this API is not required for functionality and only serves to improve performance\n by allowing the application to migrate data to a suitable location before it is accessed.\n Memory accesses to this range are always coherent and are allowed even when the data is\n actively being migrated.\n\n Note that this function is asynchronous with respect to the host and all work\n on other devices.\n\n \\param devPtr    - Pointer to be prefetched\n \\param count     - Size in bytes\n \\param dstDevice - Destination device to prefetch to\n \\param stream    - Stream to enqueue prefetch operation\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpyPeer, ::cudaMemcpyAsync,\n ::cudaMemcpy3DPeerAsync, ::cudaMemAdvise,\n ::cuMemPrefetchAsync"]
    pub fn cudaMemPrefetchAsync(
        devPtr: *const ::std::os::raw::c_void,
        count: usize,
        dstDevice: ::std::os::raw::c_int,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Advise about the usage of a given memory range\n\n Advise the Unified Memory subsystem about the usage pattern for the memory range\n starting at \\p devPtr with a size of \\p count bytes. The start address and end address of the memory\n range will be rounded down and rounded up respectively to be aligned to CPU page size before the\n advice is applied. The memory range must refer to managed memory allocated via ::cudaMallocManaged\n or declared via __managed__ variables. The memory range could also refer to system-allocated pageable\n memory provided it represents a valid, host-accessible region of memory and all additional constraints\n imposed by \\p advice as outlined below are also satisfied. Specifying an invalid system-allocated pageable\n memory range results in an error being returned.\n\n The \\p advice parameter can take the following values:\n - ::cudaMemAdviseSetReadMostly: This implies that the data is mostly going to be read\n from and only occasionally written to. Any read accesses from any processor to this region will create a\n read-only copy of at least the accessed pages in that processor's memory. Additionally, if ::cudaMemPrefetchAsync\n is called on this region, it will create a read-only copy of the data on the destination processor.\n If any processor writes to this region, all copies of the corresponding page will be invalidated\n except for the one where the write occurred. The \\p device argument is ignored for this advice.\n Note that for a page to be read-duplicated, the accessing processor must either be the CPU or a GPU\n that has a non-zero value for the device attribute ::cudaDevAttrConcurrentManagedAccess.\n Also, if a context is created on a device that does not have the device attribute\n ::cudaDevAttrConcurrentManagedAccess set, then read-duplication will not occur until\n all such contexts are destroyed.\n If the memory region refers to valid system-allocated pageable memory, then the accessing device must\n have a non-zero value for the device attribute ::cudaDevAttrPageableMemoryAccess for a read-only\n copy to be created on that device. Note however that if the accessing device also has a non-zero value for the\n device attribute ::cudaDevAttrPageableMemoryAccessUsesHostPageTables, then setting this advice\n will not create a read-only copy when that device accesses this memory region.\n\n - ::cudaMemAdviceUnsetReadMostly: Undoes the effect of ::cudaMemAdviceReadMostly and also prevents the\n Unified Memory driver from attempting heuristic read-duplication on the memory range. Any read-duplicated\n copies of the data will be collapsed into a single copy. The location for the collapsed\n copy will be the preferred location if the page has a preferred location and one of the read-duplicated\n copies was resident at that location. Otherwise, the location chosen is arbitrary.\n\n - ::cudaMemAdviseSetPreferredLocation: This advice sets the preferred location for the\n data to be the memory belonging to \\p device. Passing in cudaCpuDeviceId for \\p device sets the\n preferred location as host memory. If \\p device is a GPU, then it must have a non-zero value for the\n device attribute ::cudaDevAttrConcurrentManagedAccess. Setting the preferred location\n does not cause data to migrate to that location immediately. Instead, it guides the migration policy\n when a fault occurs on that memory region. If the data is already in its preferred location and the\n faulting processor can establish a mapping without requiring the data to be migrated, then\n data migration will be avoided. On the other hand, if the data is not in its preferred location\n or if a direct mapping cannot be established, then it will be migrated to the processor accessing\n it. It is important to note that setting the preferred location does not prevent data prefetching\n done using ::cudaMemPrefetchAsync.\n Having a preferred location can override the page thrash detection and resolution logic in the Unified\n Memory driver. Normally, if a page is detected to be constantly thrashing between for example host and device\n memory, the page may eventually be pinned to host memory by the Unified Memory driver. But\n if the preferred location is set as device memory, then the page will continue to thrash indefinitely.\n If ::cudaMemAdviseSetReadMostly is also set on this memory region or any subset of it, then the\n policies associated with that advice will override the policies of this advice, unless read accesses from\n \\p device will not result in a read-only copy being created on that device as outlined in description for\n the advice ::cudaMemAdviseSetReadMostly.\n If the memory region refers to valid system-allocated pageable memory, then \\p device must have a non-zero\n value for the device attribute ::cudaDevAttrPageableMemoryAccess. Additionally, if \\p device has\n a non-zero value for the device attribute ::cudaDevAttrPageableMemoryAccessUsesHostPageTables,\n then this call has no effect. Note however that this behavior may change in the future.\n\n - ::cudaMemAdviseUnsetPreferredLocation: Undoes the effect of ::cudaMemAdviseSetPreferredLocation\n and changes the preferred location to none.\n\n - ::cudaMemAdviseSetAccessedBy: This advice implies that the data will be accessed by \\p device.\n Passing in ::cudaCpuDeviceId for \\p device will set the advice for the CPU. If \\p device is a GPU, then\n the device attribute ::cudaDevAttrConcurrentManagedAccess must be non-zero.\n This advice does not cause data migration and has no impact on the location of the data per se. Instead,\n it causes the data to always be mapped in the specified processor's page tables, as long as the\n location of the data permits a mapping to be established. If the data gets migrated for any reason,\n the mappings are updated accordingly.\n This advice is recommended in scenarios where data locality is not important, but avoiding faults is.\n Consider for example a system containing multiple GPUs with peer-to-peer access enabled, where the\n data located on one GPU is occasionally accessed by peer GPUs. In such scenarios, migrating data\n over to the other GPUs is not as important because the accesses are infrequent and the overhead of\n migration may be too high. But preventing faults can still help improve performance, and so having\n a mapping set up in advance is useful. Note that on CPU access of this data, the data may be migrated\n to host memory because the CPU typically cannot access device memory directly. Any GPU that had the\n ::cudaMemAdviceSetAccessedBy flag set for this data will now have its mapping updated to point to the\n page in host memory.\n If ::cudaMemAdviseSetReadMostly is also set on this memory region or any subset of it, then the\n policies associated with that advice will override the policies of this advice. Additionally, if the\n preferred location of this memory region or any subset of it is also \\p device, then the policies\n associated with ::cudaMemAdviseSetPreferredLocation will override the policies of this advice.\n If the memory region refers to valid system-allocated pageable memory, then \\p device must have a non-zero\n value for the device attribute ::cudaDevAttrPageableMemoryAccess. Additionally, if \\p device has\n a non-zero value for the device attribute ::cudaDevAttrPageableMemoryAccessUsesHostPageTables,\n then this call has no effect.\n\n - ::cudaMemAdviseUnsetAccessedBy: Undoes the effect of ::cudaMemAdviseSetAccessedBy. Any mappings to\n the data from \\p device may be removed at any time causing accesses to result in non-fatal page faults.\n If the memory region refers to valid system-allocated pageable memory, then \\p device must have a non-zero\n value for the device attribute ::cudaDevAttrPageableMemoryAccess. Additionally, if \\p device has\n a non-zero value for the device attribute ::cudaDevAttrPageableMemoryAccessUsesHostPageTables,\n then this call has no effect.\n\n \\param devPtr - Pointer to memory to set the advice for\n \\param count  - Size in bytes of the memory range\n \\param advice - Advice to be applied for the specified memory range\n \\param device - Device to apply the advice for\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpyPeer, ::cudaMemcpyAsync,\n ::cudaMemcpy3DPeerAsync, ::cudaMemPrefetchAsync,\n ::cuMemAdvise"]
    pub fn cudaMemAdvise(
        devPtr: *const ::std::os::raw::c_void,
        count: usize,
        advice: cudaMemoryAdvise,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Query an attribute of a given memory range\n\n Query an attribute about the memory range starting at \\p devPtr with a size of \\p count bytes. The\n memory range must refer to managed memory allocated via ::cudaMallocManaged or declared via\n __managed__ variables.\n\n The \\p attribute parameter can take the following values:\n - ::cudaMemRangeAttributeReadMostly: If this attribute is specified, \\p data will be interpreted\n as a 32-bit integer, and \\p dataSize must be 4. The result returned will be 1 if all pages in the given\n memory range have read-duplication enabled, or 0 otherwise.\n - ::cudaMemRangeAttributePreferredLocation: If this attribute is specified, \\p data will be\n interpreted as a 32-bit integer, and \\p dataSize must be 4. The result returned will be a GPU device\n id if all pages in the memory range have that GPU as their preferred location, or it will be cudaCpuDeviceId\n if all pages in the memory range have the CPU as their preferred location, or it will be cudaInvalidDeviceId\n if either all the pages don't have the same preferred location or some of the pages don't have a\n preferred location at all. Note that the actual location of the pages in the memory range at the time of\n the query may be different from the preferred location.\n - ::cudaMemRangeAttributeAccessedBy: If this attribute is specified, \\p data will be interpreted\n as an array of 32-bit integers, and \\p dataSize must be a non-zero multiple of 4. The result returned\n will be a list of device ids that had ::cudaMemAdviceSetAccessedBy set for that entire memory range.\n If any device does not have that advice set for the entire memory range, that device will not be included.\n If \\p data is larger than the number of devices that have that advice set for that memory range,\n cudaInvalidDeviceId will be returned in all the extra space provided. For ex., if \\p dataSize is 12\n (i.e. \\p data has 3 elements) and only device 0 has the advice set, then the result returned will be\n { 0, cudaInvalidDeviceId, cudaInvalidDeviceId }. If \\p data is smaller than the number of devices that have\n that advice set, then only as many devices will be returned as can fit in the array. There is no\n guarantee on which specific devices will be returned, however.\n - ::cudaMemRangeAttributeLastPrefetchLocation: If this attribute is specified, \\p data will be\n interpreted as a 32-bit integer, and \\p dataSize must be 4. The result returned will be the last location\n to which all pages in the memory range were prefetched explicitly via ::cudaMemPrefetchAsync. This will either be\n a GPU id or cudaCpuDeviceId depending on whether the last location for prefetch was a GPU or the CPU\n respectively. If any page in the memory range was never explicitly prefetched or if all pages were not\n prefetched to the same location, cudaInvalidDeviceId will be returned. Note that this simply returns the\n last location that the applicaton requested to prefetch the memory range to. It gives no indication as to\n whether the prefetch operation to that location has completed or even begun.\n\n \\param data      - A pointers to a memory location where the result\n                    of each attribute query will be written to.\n \\param dataSize  - Array containing the size of data\n \\param attribute - The attribute to query\n \\param devPtr    - Start of the range to query\n \\param count     - Size of the range to query\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemRangeGetAttributes, ::cudaMemPrefetchAsync,\n ::cudaMemAdvise,\n ::cuMemRangeGetAttribute"]
    pub fn cudaMemRangeGetAttribute(
        data: *mut ::std::os::raw::c_void,
        dataSize: usize,
        attribute: cudaMemRangeAttribute,
        devPtr: *const ::std::os::raw::c_void,
        count: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Query attributes of a given memory range.\n\n Query attributes of the memory range starting at \\p devPtr with a size of \\p count bytes. The\n memory range must refer to managed memory allocated via ::cudaMallocManaged or declared via\n __managed__ variables. The \\p attributes array will be interpreted to have \\p numAttributes\n entries. The \\p dataSizes array will also be interpreted to have \\p numAttributes entries.\n The results of the query will be stored in \\p data.\n\n The list of supported attributes are given below. Please refer to ::cudaMemRangeGetAttribute for\n attribute descriptions and restrictions.\n\n - ::cudaMemRangeAttributeReadMostly\n - ::cudaMemRangeAttributePreferredLocation\n - ::cudaMemRangeAttributeAccessedBy\n - ::cudaMemRangeAttributeLastPrefetchLocation\n\n \\param data          - A two-dimensional array containing pointers to memory\n                        locations where the result of each attribute query will be written to.\n \\param dataSizes     - Array containing the sizes of each result\n \\param attributes    - An array of attributes to query\n                        (numAttributes and the number of attributes in this array should match)\n \\param numAttributes - Number of attributes to query\n \\param devPtr        - Start of the range to query\n \\param count         - Size of the range to query\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemRangeGetAttribute, ::cudaMemAdvise,\n ::cudaMemPrefetchAsync,\n ::cuMemRangeGetAttributes"]
    pub fn cudaMemRangeGetAttributes(
        data: *mut *mut ::std::os::raw::c_void,
        dataSizes: *mut usize,
        attributes: *mut cudaMemRangeAttribute,
        numAttributes: usize,
        devPtr: *const ::std::os::raw::c_void,
        count: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n \\deprecated\n\n Copies \\p count bytes from the memory area pointed to by \\p src to the\n CUDA array \\p dst starting at \\p hOffset rows and \\p wOffset bytes from\n the upper left corner, where \\p kind specifies the direction\n of the copy, and must be one of ::cudaMemcpyHostToHost,\n ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n\n \\param dst     - Destination memory address\n \\param wOffset - Destination starting X offset (columns in bytes)\n \\param hOffset - Destination starting Y offset (rows)\n \\param src     - Source memory address\n \\param count   - Size in bytes to copy\n \\param kind    - Type of transfer\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_sync\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D,\n ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpyHtoA,\n ::cuMemcpyDtoA"]
    pub fn cudaMemcpyToArray(
        dst: cudaArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n \\deprecated\n\n Copies \\p count bytes from the CUDA array \\p src starting at \\p hOffset rows\n and \\p wOffset bytes from the upper left corner to the memory area pointed to\n by \\p dst, where \\p kind specifies the direction of the copy, and must be one of\n ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n\n \\param dst     - Destination memory address\n \\param src     - Source memory address\n \\param wOffset - Source starting X offset (columns in bytes)\n \\param hOffset - Source starting Y offset (rows)\n \\param count   - Size in bytes to copy\n \\param kind    - Type of transfer\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_sync\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray,\n ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpyAtoH,\n ::cuMemcpyAtoD"]
    pub fn cudaMemcpyFromArray(
        dst: *mut ::std::os::raw::c_void,
        src: cudaArray_const_t,
        wOffset: usize,
        hOffset: usize,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n \\deprecated\n\n Copies \\p count bytes from the CUDA array \\p src starting at \\p hOffsetSrc\n rows and \\p wOffsetSrc bytes from the upper left corner to the CUDA array\n \\p dst starting at \\p hOffsetDst rows and \\p wOffsetDst bytes from the upper\n left corner, where \\p kind specifies the direction of the copy, and must be one of\n ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n\n \\param dst        - Destination memory address\n \\param wOffsetDst - Destination starting X offset (columns in bytes)\n \\param hOffsetDst - Destination starting Y offset (rows)\n \\param src        - Source memory address\n \\param wOffsetSrc - Source starting X offset (columns in bytes)\n \\param hOffsetSrc - Source starting Y offset (rows)\n \\param count      - Size in bytes to copy\n \\param kind       - Type of transfer\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray,\n ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpyAtoA"]
    pub fn cudaMemcpyArrayToArray(
        dst: cudaArray_t,
        wOffsetDst: usize,
        hOffsetDst: usize,
        src: cudaArray_const_t,
        wOffsetSrc: usize,
        hOffsetSrc: usize,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n \\deprecated\n\n Copies \\p count bytes from the memory area pointed to by \\p src to the\n CUDA array \\p dst starting at \\p hOffset rows and \\p wOffset bytes from\n the upper left corner, where \\p kind specifies the\n direction of the copy, and must be one of ::cudaMemcpyHostToHost,\n ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n\n ::cudaMemcpyToArrayAsync() is asynchronous with respect to the host, so\n the call may return before the copy is complete. The copy can optionally\n be associated to a stream by passing a non-zero \\p stream argument. If \\p\n kind is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and \\p stream\n is non-zero, the copy may overlap with operations in other streams.\n\n \\param dst     - Destination memory address\n \\param wOffset - Destination starting X offset (columns in bytes)\n \\param hOffset - Destination starting Y offset (rows)\n \\param src     - Source memory address\n \\param count   - Size in bytes to copy\n \\param kind    - Type of transfer\n \\param stream  - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray,\n ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpyHtoAAsync,\n ::cuMemcpy2DAsync"]
    pub fn cudaMemcpyToArrayAsync(
        dst: cudaArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies data between host and device\n\n \\deprecated\n\n Copies \\p count bytes from the CUDA array \\p src starting at \\p hOffset rows\n and \\p wOffset bytes from the upper left corner to the memory area pointed to\n by \\p dst, where \\p kind specifies the direction of the copy, and must be one of\n ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost,\n ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing\n ::cudaMemcpyDefault is recommended, in which case the type of transfer is\n inferred from the pointer values. However, ::cudaMemcpyDefault is only\n allowed on systems that support unified virtual addressing.\n\n ::cudaMemcpyFromArrayAsync() is asynchronous with respect to the host, so\n the call may return before the copy is complete. The copy can optionally\n be associated to a stream by passing a non-zero \\p stream argument. If \\p\n kind is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and \\p stream\n is non-zero, the copy may overlap with operations in other streams.\n\n \\param dst     - Destination memory address\n \\param src     - Source memory address\n \\param wOffset - Source starting X offset (columns in bytes)\n \\param hOffset - Source starting Y offset (rows)\n \\param count   - Size in bytes to copy\n \\param kind    - Type of transfer\n \\param stream  - Stream identifier\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidMemcpyDirection\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray,\n ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray,\n ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync,\n ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync,\n ::cudaMemcpy2DFromArrayAsync,\n ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync,\n ::cuMemcpyAtoHAsync,\n ::cuMemcpy2DAsync"]
    pub fn cudaMemcpyFromArrayAsync(
        dst: *mut ::std::os::raw::c_void,
        src: cudaArray_const_t,
        wOffset: usize,
        hOffset: usize,
        count: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Allocates memory with stream ordered semantics\n\n Inserts an allocation operation into \\p hStream.\n A pointer to the allocated memory is returned immediately in *dptr.\n The allocation must not be accessed until the the allocation operation completes.\n The allocation comes from the memory pool associated with the stream's device.\n\n \\note The default memory pool of a device contains device memory from that device.\n \\note Basic stream ordering allows future work submitted into the same stream to use the allocation.\n       Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation\n       operation completes before work submitted in a separate stream runs.\n \\note During stream capture, this function results in the creation of an allocation node.  In this case,\n       the allocation is owned by the graph instead of the memory pool. The memory pool's properties\n       are used to set the node's creation parameters.\n\n \\param[out] devPtr  - Returned device pointer\n \\param[in] size     - Number of bytes to allocate\n \\param[in] hStream  - The stream establishing the stream ordering contract and the memory pool to allocate from\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorNotSupported,\n ::cudaErrorOutOfMemory,\n \\notefnerr\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cuMemAllocAsync,\n \\ref ::cudaMallocAsync(void** ptr, size_t size, cudaMemPool_t memPool, cudaStream_t stream)  \"cudaMallocAsync (C++ API)\",\n ::cudaMallocFromPoolAsync, ::cudaFreeAsync, ::cudaDeviceSetMemPool, ::cudaDeviceGetDefaultMemPool, ::cudaDeviceGetMemPool, ::cudaMemPoolSetAccess, ::cudaMemPoolSetAttribute, ::cudaMemPoolGetAttribute"]
    pub fn cudaMallocAsync(
        devPtr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        hStream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Frees memory with stream ordered semantics\n\n Inserts a free operation into \\p hStream.\n The allocation must not be accessed after stream execution reaches the free.\n After this API returns, accessing the memory from any subsequent work launched on the GPU\n or querying its pointer attributes results in undefined behavior.\n\n \\note During stream capture, this function results in the creation of a free node and\n       must therefore be passed the address of a graph allocation.\n\n \\param dptr - memory to free\n \\param hStream - The stream establishing the stream ordering promise\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorNotSupported\n \\notefnerr\n \\note_null_stream\n \\note_init_rt\n \\note_callback\n\n \\sa ::cuMemFreeAsync, ::cudaMallocAsync"]
    pub fn cudaFreeAsync(devPtr: *mut ::std::os::raw::c_void, hStream: cudaStream_t)
                         -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Tries to release memory back to the OS\n\n Releases memory back to the OS until the pool contains fewer than minBytesToKeep\n reserved bytes, or there is no more memory that the allocator can safely release.\n The allocator cannot release OS allocations that back outstanding asynchronous allocations.\n The OS allocations may happen at different granularity from the user allocations.\n\n \\note: Allocations that have not been freed count as outstanding.\n \\note: Allocations that have been asynchronously freed but whose completion has\n        not been observed on the host (eg. by a synchronize) can count as outstanding.\n\n \\param[in] pool           - The memory pool to trim\n \\param[in] minBytesToKeep - If the pool has less than minBytesToKeep reserved,\n the TrimTo operation is a no-op.  Otherwise the pool will be guaranteed to have\n at least minBytesToKeep bytes reserved after the operation.\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_callback\n\n \\sa ::cuMemPoolTrimTo, ::cudaMallocAsync, ::cudaFreeAsync, ::cudaDeviceGetDefaultMemPool, ::cudaDeviceGetMemPool, ::cudaMemPoolCreate"]
    pub fn cudaMemPoolTrimTo(memPool: cudaMemPool_t, minBytesToKeep: usize) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets attributes of a memory pool\n\n Supported attributes are:\n - ::cudaMemPoolAttrReleaseThreshold: (value type = cuuint64_t)\n                    Amount of reserved memory in bytes to hold onto before trying\n                    to release memory back to the OS. When more than the release\n                    threshold bytes of memory are held by the memory pool, the\n                    allocator will try to release memory back to the OS on the\n                    next call to stream, event or context synchronize. (default 0)\n - ::cudaMemPoolReuseFollowEventDependencies: (value type = int)\n                    Allow ::cudaMallocAsync to use memory asynchronously freed\n                    in another stream as long as a stream ordering dependency\n                    of the allocating stream on the free action exists.\n                    Cuda events and null stream interactions can create the required\n                    stream ordered dependencies. (default enabled)\n - ::cudaMemPoolReuseAllowOpportunistic: (value type = int)\n                    Allow reuse of already completed frees when there is no dependency\n                    between the free and allocation. (default enabled)\n - ::cudaMemPoolReuseAllowInternalDependencies: (value type = int)\n                    Allow ::cudaMallocAsync to insert new stream dependencies\n                    in order to establish the stream ordering required to reuse\n                    a piece of memory released by ::cudaFreeAsync (default enabled).\n - ::cudaMemPoolAttrReservedMemHigh: (value type = cuuint64_t)\n                    Reset the high watermark that tracks the amount of backing memory that was\n                    allocated for the memory pool. It is illegal to set this attribute to a non-zero value.\n - ::cudaMemPoolAttrUsedMemHigh: (value type = cuuint64_t)\n                    Reset the high watermark that tracks the amount of used memory that was\n                    allocated for the memory pool. It is illegal to set this attribute to a non-zero value.\n\n \\param[in] pool  - The memory pool to modify\n \\param[in] attr  - The attribute to modify\n \\param[in] value - Pointer to the value to assign\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_callback\n\n \\sa ::cuMemPoolSetAttribute, ::cudaMallocAsync, ::cudaFreeAsync, ::cudaDeviceGetDefaultMemPool, ::cudaDeviceGetMemPool, ::cudaMemPoolCreate\n"]
    pub fn cudaMemPoolSetAttribute(
        memPool: cudaMemPool_t,
        attr: cudaMemPoolAttr,
        value: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Gets attributes of a memory pool\n\n Supported attributes are:\n - ::cudaMemPoolAttrReleaseThreshold: (value type = cuuint64_t)\n                    Amount of reserved memory in bytes to hold onto before trying\n                    to release memory back to the OS. When more than the release\n                    threshold bytes of memory are held by the memory pool, the\n                    allocator will try to release memory back to the OS on the\n                    next call to stream, event or context synchronize. (default 0)\n - ::cudaMemPoolReuseFollowEventDependencies: (value type = int)\n                    Allow ::cudaMallocAsync to use memory asynchronously freed\n                    in another stream as long as a stream ordering dependency\n                    of the allocating stream on the free action exists.\n                    Cuda events and null stream interactions can create the required\n                    stream ordered dependencies. (default enabled)\n - ::cudaMemPoolReuseAllowOpportunistic: (value type = int)\n                    Allow reuse of already completed frees when there is no dependency\n                    between the free and allocation. (default enabled)\n - ::cudaMemPoolReuseAllowInternalDependencies: (value type = int)\n                    Allow ::cudaMallocAsync to insert new stream dependencies\n                    in order to establish the stream ordering required to reuse\n                    a piece of memory released by ::cudaFreeAsync (default enabled).\n - ::cudaMemPoolAttrReservedMemCurrent: (value type = cuuint64_t)\n                    Amount of backing memory currently allocated for the mempool.\n - ::cudaMemPoolAttrReservedMemHigh: (value type = cuuint64_t)\n                    High watermark of backing memory allocated for the mempool since\n                    the last time it was reset.\n - ::cudaMemPoolAttrUsedMemCurrent: (value type = cuuint64_t)\n                    Amount of memory from the pool that is currently in use by the application.\n - ::cudaMemPoolAttrUsedMemHigh: (value type = cuuint64_t)\n                    High watermark of the amount of memory from the pool that was in use by the\n                    application since the last time it was reset.\n\n \\param[in] pool  - The memory pool to get attributes of\n \\param[in] attr  - The attribute to get\n \\param[in] value - Retrieved value\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_callback\n\n \\sa ::cuMemPoolGetAttribute, ::cudaMallocAsync, ::cudaFreeAsync, ::cudaDeviceGetDefaultMemPool, ::cudaDeviceGetMemPool, ::cudaMemPoolCreate\n"]
    pub fn cudaMemPoolGetAttribute(
        memPool: cudaMemPool_t,
        attr: cudaMemPoolAttr,
        value: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Controls visibility of pools between devices\n\n \\param[in] pool  - The pool being modified\n \\param[in] map   - Array of access descriptors. Each descriptor instructs the access to enable for a single gpu\n \\param[in] count - Number of descriptors in the map array.\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n\n \\sa ::cuMemPoolSetAccess, ::cudaMemPoolGetAccess, ::cudaMallocAsync, cudaFreeAsync"]
    pub fn cudaMemPoolSetAccess(
        memPool: cudaMemPool_t,
        descList: *const cudaMemAccessDesc,
        count: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the accessibility of a pool from a device\n\n Returns the accessibility of the pool's memory from the specified location.\n\n \\param[out] flags   - the accessibility of the pool from the specified location\n \\param[in] memPool  - the pool being queried\n \\param[in] location - the location accessing the pool\n\n \\sa ::cuMemPoolGetAccess, ::cudaMemPoolSetAccess"]
    pub fn cudaMemPoolGetAccess(
        flags: *mut cudaMemAccessFlags,
        memPool: cudaMemPool_t,
        location: *mut cudaMemLocation,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a memory pool\n\n Creates a CUDA memory pool and returns the handle in \\p pool.  The \\p poolProps determines\n the properties of the pool such as the backing device and IPC capabilities.\n\n By default, the pool's memory will be accessible from the device it is allocated on.\n\n \\note Specifying cudaMemHandleTypeNone creates a memory pool that will not support IPC.\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorNotSupported\n\n \\sa ::cuMemPoolCreate, ::cudaDeviceSetMemPool, ::cudaMallocFromPoolAsync, ::cudaMemPoolExportToShareableHandle, ::cudaDeviceGetDefaultMemPool, ::cudaDeviceGetMemPool\n"]
    pub fn cudaMemPoolCreate(
        memPool: *mut cudaMemPool_t,
        poolProps: *const cudaMemPoolProps,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Destroys the specified memory pool\n\n If any pointers obtained from this pool haven't been freed or\n the pool has free operations that haven't completed\n when ::cudaMemPoolDestroy is invoked, the function will return immediately and the\n resources associated with the pool will be released automatically\n once there are no more outstanding allocations.\n\n Destroying the current mempool of a device sets the default mempool of\n that device as the current mempool for that device.\n\n \\note A device's default memory pool cannot be destroyed.\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n\n \\sa cuMemPoolDestroy, ::cudaFreeAsync, ::cudaDeviceSetMemPool, ::cudaDeviceGetDefaultMemPool, ::cudaDeviceGetMemPool, ::cudaMemPoolCreate"]
    pub fn cudaMemPoolDestroy(memPool: cudaMemPool_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Allocates memory from a specified pool with stream ordered semantics.\n\n Inserts an allocation operation into \\p hStream.\n A pointer to the allocated memory is returned immediately in *dptr.\n The allocation must not be accessed until the the allocation operation completes.\n The allocation comes from the specified memory pool.\n\n \\note\n    -  The specified memory pool may be from a device different than that of the specified \\p hStream.\n\n    -  Basic stream ordering allows future work submitted into the same stream to use the allocation.\n       Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation\n       operation completes before work submitted in a separate stream runs.\n\n \\note During stream capture, this function results in the creation of an allocation node.  In this case,\n       the allocation is owned by the graph instead of the memory pool. The memory pool's properties\n       are used to set the node's creation parameters.\n\n \\param[out] ptr     - Returned device pointer\n \\param[in] bytesize - Number of bytes to allocate\n \\param[in] memPool  - The pool to allocate from\n \\param[in] stream   - The stream establishing the stream ordering semantic\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorNotSupported,\n ::cudaErrorOutOfMemory\n\n \\sa ::cuMemAllocFromPoolAsync,\n \\ref ::cudaMallocAsync(void** ptr, size_t size, cudaMemPool_t memPool, cudaStream_t stream)  \"cudaMallocAsync (C++ API)\",\n ::cudaMallocAsync, ::cudaFreeAsync, ::cudaDeviceGetDefaultMemPool, ::cudaMemPoolCreate, ::cudaMemPoolSetAccess, ::cudaMemPoolSetAttribute"]
    pub fn cudaMallocFromPoolAsync(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        memPool: cudaMemPool_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Exports a memory pool to the requested handle type.\n\n Given an IPC capable mempool, create an OS handle to share the pool with another process.\n A recipient process can convert the shareable handle into a mempool with ::cudaMemPoolImportFromShareableHandle.\n Individual pointers can then be shared with the ::cudaMemPoolExportPointer and ::cudaMemPoolImportPointer APIs.\n The implementation of what the shareable handle is and how it can be transferred is defined by the requested\n handle type.\n\n \\note: To create an IPC capable mempool, create a mempool with a CUmemAllocationHandleType other than cudaMemHandleTypeNone.\n\n \\param[out] handle_out  - pointer to the location in which to store the requested handle\n \\param[in] pool         - pool to export\n \\param[in] handleType   - the type of handle to create\n \\param[in] flags        - must be 0\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorOutOfMemory\n\n \\sa ::cuMemPoolExportToShareableHandle, ::cudaMemPoolImportFromShareableHandle, ::cudaMemPoolExportPointer, ::cudaMemPoolImportPointer"]
    pub fn cudaMemPoolExportToShareableHandle(
        shareableHandle: *mut ::std::os::raw::c_void,
        memPool: cudaMemPool_t,
        handleType: cudaMemAllocationHandleType,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief imports a memory pool from a shared handle.\n\n Specific allocations can be imported from the imported pool with ::cudaMemPoolImportPointer.\n\n \\note Imported memory pools do not support creating new allocations.\n       As such imported memory pools may not be used in ::cudaDeviceSetMemPool\n       or ::cudaMallocFromPoolAsync calls.\n\n \\param[out] pool_out    - Returned memory pool\n \\param[in] handle       - OS handle of the pool to open\n \\param[in] handleType   - The type of handle being imported\n \\param[in] flags        - must be 0\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorOutOfMemory\n\n \\sa ::cuMemPoolImportFromShareableHandle, ::cudaMemPoolExportToShareableHandle, ::cudaMemPoolExportPointer, ::cudaMemPoolImportPointer"]
    pub fn cudaMemPoolImportFromShareableHandle(
        memPool: *mut cudaMemPool_t,
        shareableHandle: *mut ::std::os::raw::c_void,
        handleType: cudaMemAllocationHandleType,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Export data to share a memory pool allocation between processes.\n\n Constructs \\p shareData_out for sharing a specific allocation from an already shared memory pool.\n The recipient process can import the allocation with the ::cudaMemPoolImportPointer api.\n The data is not a handle and may be shared through any IPC mechanism.\n\n \\param[out] shareData_out - Returned export data\n \\param[in] ptr            - pointer to memory being exported\n\n \\returns\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorOutOfMemory\n\n \\sa ::cuMemPoolExportPointer, ::cudaMemPoolExportToShareableHandle, ::cudaMemPoolImportFromShareableHandle, ::cudaMemPoolImportPointer"]
    pub fn cudaMemPoolExportPointer(
        exportData: *mut cudaMemPoolPtrExportData,
        ptr: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Import a memory pool allocation from another process.\n\n Returns in \\p ptr_out a pointer to the imported memory.\n The imported memory must not be accessed before the allocation operation completes\n in the exporting process. The imported memory must be freed from all importing processes before\n being freed in the exporting process. The pointer may be freed with cudaFree\n or cudaFreeAsync.  If ::cudaFreeAsync is used, the free must be completed\n on the importing process before the free operation on the exporting process.\n\n \\note The ::cudaFreeAsync api may be used in the exporting process before\n       the ::cudaFreeAsync operation completes in its stream as long as the\n       ::cudaFreeAsync in the exporting process specifies a stream with\n       a stream dependency on the importing process's ::cudaFreeAsync.\n\n \\param[out] ptr_out  - pointer to imported memory\n \\param[in] pool      - pool from which to import\n \\param[in] shareData - data specifying the memory to import\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_OUT_OF_MEMORY\n\n \\sa ::cuMemPoolImportPointer, ::cudaMemPoolExportToShareableHandle, ::cudaMemPoolImportFromShareableHandle, ::cudaMemPoolExportPointer"]
    pub fn cudaMemPoolImportPointer(
        ptr: *mut *mut ::std::os::raw::c_void,
        memPool: cudaMemPool_t,
        exportData: *mut cudaMemPoolPtrExportData,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns attributes about a specified pointer\n\n Returns in \\p *attributes the attributes of the pointer \\p ptr.\n If pointer was not allocated in, mapped by or registered with context\n supporting unified addressing ::cudaErrorInvalidValue is returned.\n\n \\note In CUDA 11.0 forward passing host pointer will return ::cudaMemoryTypeUnregistered\n in ::cudaPointerAttributes::type and call will return ::cudaSuccess.\n\n The ::cudaPointerAttributes structure is defined as:\n \\code\nstruct cudaPointerAttributes {\nenum cudaMemoryType type;\nint device;\nvoid *devicePointer;\nvoid *hostPointer;\n}\n\\endcode\n In this structure, the individual fields mean\n\n - \\ref ::cudaPointerAttributes::type identifies type of memory. It can be\n    ::cudaMemoryTypeUnregistered for unregistered host memory,\n    ::cudaMemoryTypeHost for registered host memory, ::cudaMemoryTypeDevice for device\n    memory or  ::cudaMemoryTypeManaged for managed memory.\n\n - \\ref ::cudaPointerAttributes::device \"device\" is the device against which\n   \\p ptr was allocated.  If \\p ptr has memory type ::cudaMemoryTypeDevice\n   then this identifies the device on which the memory referred to by \\p ptr\n   physically resides.  If \\p ptr has memory type ::cudaMemoryTypeHost then this\n   identifies the device which was current when the allocation was made\n   (and if that device is deinitialized then this allocation will vanish\n   with that device's state).\n\n - \\ref ::cudaPointerAttributes::devicePointer \"devicePointer\" is\n   the device pointer alias through which the memory referred to by \\p ptr\n   may be accessed on the current device.\n   If the memory referred to by \\p ptr cannot be accessed directly by the\n   current device then this is NULL.\n\n - \\ref ::cudaPointerAttributes::hostPointer \"hostPointer\" is\n   the host pointer alias through which the memory referred to by \\p ptr\n   may be accessed on the host.\n   If the memory referred to by \\p ptr cannot be accessed directly by the\n   host then this is NULL.\n\n \\param attributes - Attributes for the specified pointer\n \\param ptr        - Pointer to get attributes for\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDevice,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaGetDeviceCount, ::cudaGetDevice, ::cudaSetDevice,\n ::cudaChooseDevice,\n ::cuPointerGetAttributes"]
    pub fn cudaPointerGetAttributes(
        attributes: *mut cudaPointerAttributes,
        ptr: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Queries if a device may directly access a peer device's memory.\n\n Returns in \\p *canAccessPeer a value of 1 if device \\p device is capable of\n directly accessing memory from \\p peerDevice and 0 otherwise.  If direct\n access of \\p peerDevice from \\p device is possible, then access may be\n enabled by calling ::cudaDeviceEnablePeerAccess().\n\n \\param canAccessPeer - Returned access capability\n \\param device        - Device from which allocations on \\p peerDevice are to\n                        be directly accessed.\n \\param peerDevice    - Device on which the allocations to be directly accessed\n                        by \\p device reside.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceEnablePeerAccess,\n ::cudaDeviceDisablePeerAccess,\n ::cuDeviceCanAccessPeer"]
    pub fn cudaDeviceCanAccessPeer(
        canAccessPeer: *mut ::std::os::raw::c_int,
        device: ::std::os::raw::c_int,
        peerDevice: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Enables direct access to memory allocations on a peer device.\n\n On success, all allocations from \\p peerDevice will immediately be accessible by\n the current device.  They will remain accessible until access is explicitly\n disabled using ::cudaDeviceDisablePeerAccess() or either device is reset using\n ::cudaDeviceReset().\n\n Note that access granted by this call is unidirectional and that in order to access\n memory on the current device from \\p peerDevice, a separate symmetric call\n to ::cudaDeviceEnablePeerAccess() is required.\n\n Note that there are both device-wide and system-wide limitations per system\n configuration, as noted in the CUDA Programming Guide under the section\n \"Peer-to-Peer Memory Access\".\n\n Returns ::cudaErrorInvalidDevice if ::cudaDeviceCanAccessPeer() indicates\n that the current device cannot directly access memory from \\p peerDevice.\n\n Returns ::cudaErrorPeerAccessAlreadyEnabled if direct access of\n \\p peerDevice from the current device has already been enabled.\n\n Returns ::cudaErrorInvalidValue if \\p flags is not 0.\n\n \\param peerDevice  - Peer device to enable direct access to from the current device\n \\param flags       - Reserved for future use and must be set to 0\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidDevice,\n ::cudaErrorPeerAccessAlreadyEnabled,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceCanAccessPeer,\n ::cudaDeviceDisablePeerAccess,\n ::cuCtxEnablePeerAccess"]
    pub fn cudaDeviceEnablePeerAccess(
        peerDevice: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Disables direct access to memory allocations on a peer device.\n\n Returns ::cudaErrorPeerAccessNotEnabled if direct access to memory on\n \\p peerDevice has not yet been enabled from the current device.\n\n \\param peerDevice - Peer device to disable direct access to\n\n \\return\n ::cudaSuccess,\n ::cudaErrorPeerAccessNotEnabled,\n ::cudaErrorInvalidDevice\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa ::cudaDeviceCanAccessPeer,\n ::cudaDeviceEnablePeerAccess,\n ::cuCtxDisablePeerAccess"]
    pub fn cudaDeviceDisablePeerAccess(peerDevice: ::std::os::raw::c_int) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Unregisters a graphics resource for access by CUDA\n\n Unregisters the graphics resource \\p resource so it is not accessible by\n CUDA unless registered again.\n\n If \\p resource is invalid then ::cudaErrorInvalidResourceHandle is\n returned.\n\n \\param resource - Resource to unregister\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorUnknown\n \\notefnerr\n \\note_init_rt\n \\note_callback\n \\note_destroy_ub\n\n \\sa\n ::cudaGraphicsD3D9RegisterResource,\n ::cudaGraphicsD3D10RegisterResource,\n ::cudaGraphicsD3D11RegisterResource,\n ::cudaGraphicsGLRegisterBuffer,\n ::cudaGraphicsGLRegisterImage,\n ::cuGraphicsUnregisterResource"]
    pub fn cudaGraphicsUnregisterResource(resource: cudaGraphicsResource_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Set usage flags for mapping a graphics resource\n\n Set \\p flags for mapping the graphics resource \\p resource.\n\n Changes to \\p flags will take effect the next time \\p resource is mapped.\n The \\p flags argument may be any of the following:\n - ::cudaGraphicsMapFlagsNone: Specifies no hints about how \\p resource will\n     be used. It is therefore assumed that CUDA may read from or write to \\p resource.\n - ::cudaGraphicsMapFlagsReadOnly: Specifies that CUDA will not write to \\p resource.\n - ::cudaGraphicsMapFlagsWriteDiscard: Specifies CUDA will not read from \\p resource and will\n   write over the entire contents of \\p resource, so none of the data\n   previously stored in \\p resource will be preserved.\n\n If \\p resource is presently mapped for access by CUDA then ::cudaErrorUnknown is returned.\n If \\p flags is not one of the above values then ::cudaErrorInvalidValue is returned.\n\n \\param resource - Registered resource to set flags for\n \\param flags    - Parameters for resource mapping\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorUnknown,\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphicsMapResources,\n ::cuGraphicsResourceSetMapFlags"]
    pub fn cudaGraphicsResourceSetMapFlags(
        resource: cudaGraphicsResource_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Map graphics resources for access by CUDA\n\n Maps the \\p count graphics resources in \\p resources for access by CUDA.\n\n The resources in \\p resources may be accessed by CUDA until they\n are unmapped. The graphics API from which \\p resources were registered\n should not access any resources while they are mapped by CUDA. If an\n application does so, the results are undefined.\n\n This function provides the synchronization guarantee that any graphics calls\n issued before ::cudaGraphicsMapResources() will complete before any subsequent CUDA\n work issued in \\p stream begins.\n\n If \\p resources contains any duplicate entries then ::cudaErrorInvalidResourceHandle\n is returned. If any of \\p resources are presently mapped for access by\n CUDA then ::cudaErrorUnknown is returned.\n\n \\param count     - Number of resources to map\n \\param resources - Resources to map for CUDA\n \\param stream    - Stream for synchronization\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorUnknown\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphicsResourceGetMappedPointer,\n ::cudaGraphicsSubResourceGetMappedArray,\n ::cudaGraphicsUnmapResources,\n ::cuGraphicsMapResources"]
    pub fn cudaGraphicsMapResources(
        count: ::std::os::raw::c_int,
        resources: *mut cudaGraphicsResource_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Unmap graphics resources.\n\n Unmaps the \\p count graphics resources in \\p resources.\n\n Once unmapped, the resources in \\p resources may not be accessed by CUDA\n until they are mapped again.\n\n This function provides the synchronization guarantee that any CUDA work issued\n in \\p stream before ::cudaGraphicsUnmapResources() will complete before any\n subsequently issued graphics work begins.\n\n If \\p resources contains any duplicate entries then ::cudaErrorInvalidResourceHandle\n is returned. If any of \\p resources are not presently mapped for access by\n CUDA then ::cudaErrorUnknown is returned.\n\n \\param count     - Number of resources to unmap\n \\param resources - Resources to unmap\n \\param stream    - Stream for synchronization\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorUnknown\n \\note_null_stream\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphicsMapResources,\n ::cuGraphicsUnmapResources"]
    pub fn cudaGraphicsUnmapResources(
        count: ::std::os::raw::c_int,
        resources: *mut cudaGraphicsResource_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Get an device pointer through which to access a mapped graphics resource.\n\n Returns in \\p *devPtr a pointer through which the mapped graphics resource\n \\p resource may be accessed.\n Returns in \\p *size the size of the memory in bytes which may be accessed from that pointer.\n The value set in \\p devPtr may change every time that \\p resource is mapped.\n\n If \\p resource is not a buffer then it cannot be accessed via a pointer and\n ::cudaErrorUnknown is returned.\n If \\p resource is not mapped then ::cudaErrorUnknown is returned.\n *\n \\param devPtr     - Returned pointer through which \\p resource may be accessed\n \\param size       - Returned size of the buffer accessible starting at \\p *devPtr\n \\param resource   - Mapped resource to access\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorUnknown\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphicsMapResources,\n ::cudaGraphicsSubResourceGetMappedArray,\n ::cuGraphicsResourceGetMappedPointer"]
    pub fn cudaGraphicsResourceGetMappedPointer(
        devPtr: *mut *mut ::std::os::raw::c_void,
        size: *mut usize,
        resource: cudaGraphicsResource_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Get an array through which to access a subresource of a mapped graphics resource.\n\n Returns in \\p *array an array through which the subresource of the mapped\n graphics resource \\p resource which corresponds to array index \\p arrayIndex\n and mipmap level \\p mipLevel may be accessed.  The value set in \\p array may\n change every time that \\p resource is mapped.\n\n If \\p resource is not a texture then it cannot be accessed via an array and\n ::cudaErrorUnknown is returned.\n If \\p arrayIndex is not a valid array index for \\p resource then\n ::cudaErrorInvalidValue is returned.\n If \\p mipLevel is not a valid mipmap level for \\p resource then\n ::cudaErrorInvalidValue is returned.\n If \\p resource is not mapped then ::cudaErrorUnknown is returned.\n\n \\param array       - Returned array through which a subresource of \\p resource may be accessed\n \\param resource    - Mapped resource to access\n \\param arrayIndex  - Array index for array textures or cubemap face\n                      index as defined by ::cudaGraphicsCubeFace for\n                      cubemap textures for the subresource to access\n \\param mipLevel    - Mipmap level for the subresource to access\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorUnknown\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphicsResourceGetMappedPointer,\n ::cuGraphicsSubResourceGetMappedArray"]
    pub fn cudaGraphicsSubResourceGetMappedArray(
        array: *mut cudaArray_t,
        resource: cudaGraphicsResource_t,
        arrayIndex: ::std::os::raw::c_uint,
        mipLevel: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Get a mipmapped array through which to access a mapped graphics resource.\n\n Returns in \\p *mipmappedArray a mipmapped array through which the mapped\n graphics resource \\p resource may be accessed. The value set in \\p mipmappedArray may\n change every time that \\p resource is mapped.\n\n If \\p resource is not a texture then it cannot be accessed via an array and\n ::cudaErrorUnknown is returned.\n If \\p resource is not mapped then ::cudaErrorUnknown is returned.\n\n \\param mipmappedArray - Returned mipmapped array through which \\p resource may be accessed\n \\param resource       - Mapped resource to access\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorUnknown\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphicsResourceGetMappedPointer,\n ::cuGraphicsResourceGetMappedMipmappedArray"]
    pub fn cudaGraphicsResourceGetMappedMipmappedArray(
        mipmappedArray: *mut cudaMipmappedArray_t,
        resource: cudaGraphicsResource_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Binds a memory area to a texture\n\n \\deprecated\n\n Binds \\p size bytes of the memory area pointed to by \\p devPtr to the\n texture reference \\p texref. \\p desc describes how the memory is interpreted\n when fetching values from the texture. Any memory previously bound to\n \\p texref is unbound.\n\n Since the hardware enforces an alignment requirement on texture base\n addresses,\n \\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) \"cudaBindTexture()\"\n returns in \\p *offset a byte offset that\n must be applied to texture fetches in order to read from the desired memory.\n This offset must be divided by the texel size and passed to kernels that\n read from the texture so they can be applied to the ::tex1Dfetch() function.\n If the device memory pointer was returned from ::cudaMalloc(), the offset is\n guaranteed to be 0 and NULL may be passed as the \\p offset parameter.\n\n The total number of elements (or texels) in the linear address range\n cannot exceed ::cudaDeviceProp::maxTexture1DLinear[0].\n The number of elements is computed as (\\p size / elementSize),\n where elementSize is determined from \\p desc.\n\n \\param offset - Offset in bytes\n \\param texref - Texture to bind\n \\param devPtr - Memory area on device\n \\param desc   - Channel format\n \\param size   - Size of the memory area pointed to by devPtr\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidTexture\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) \"cudaCreateChannelDesc (C API)\",\n ::cudaGetChannelDesc, ::cudaGetTextureReference,\n \\ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t) \"cudaBindTexture (C++ API)\",\n \\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) \"cudaBindTexture2D (C API)\",\n \\ref ::cudaBindTextureToArray(const struct textureReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) \"cudaBindTextureToArray (C API)\",\n \\ref ::cudaUnbindTexture(const struct textureReference*) \"cudaUnbindTexture (C API)\",\n \\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) \"cudaGetTextureAlignmentOffset (C API)\",\n ::cuTexRefSetAddress,\n ::cuTexRefSetAddressMode,\n ::cuTexRefSetFormat,\n ::cuTexRefSetFlags,\n ::cuTexRefSetBorderColor"]
    pub fn cudaBindTexture(
        offset: *mut usize,
        texref: *const textureReference,
        devPtr: *const ::std::os::raw::c_void,
        desc: *const cudaChannelFormatDesc,
        size: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Binds a 2D memory area to a texture\n\n \\deprecated\n\n Binds the 2D memory area pointed to by \\p devPtr to the\n texture reference \\p texref. The size of the area is constrained by\n \\p width in texel units, \\p height in texel units, and \\p pitch in byte\n units. \\p desc describes how the memory is interpreted when fetching values\n from the texture. Any memory previously bound to \\p texref is unbound.\n\n Since the hardware enforces an alignment requirement on texture base\n addresses, ::cudaBindTexture2D() returns in \\p *offset a byte offset that\n must be applied to texture fetches in order to read from the desired memory.\n This offset must be divided by the texel size and passed to kernels that\n read from the texture so they can be applied to the ::tex2D() function.\n If the device memory pointer was returned from ::cudaMalloc(), the offset is\n guaranteed to be 0 and NULL may be passed as the \\p offset parameter.\n\n \\p width and \\p height, which are specified in elements (or texels), cannot\n exceed ::cudaDeviceProp::maxTexture2DLinear[0] and ::cudaDeviceProp::maxTexture2DLinear[1]\n respectively. \\p pitch, which is specified in bytes, cannot exceed\n ::cudaDeviceProp::maxTexture2DLinear[2].\n\n The driver returns ::cudaErrorInvalidValue if \\p pitch is not a multiple of\n ::cudaDeviceProp::texturePitchAlignment.\n\n \\param offset - Offset in bytes\n \\param texref - Texture reference to bind\n \\param devPtr - 2D memory area on device\n \\param desc   - Channel format\n \\param width  - Width in texel units\n \\param height - Height in texel units\n \\param pitch  - Pitch in bytes\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidTexture\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) \"cudaCreateChannelDesc (C API)\",\n ::cudaGetChannelDesc, ::cudaGetTextureReference,\n \\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) \"cudaBindTexture (C API)\",\n \\ref ::cudaBindTexture2D(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t, size_t, size_t) \"cudaBindTexture2D (C++ API)\",\n \\ref ::cudaBindTexture2D(size_t*, const struct texture<T, dim, readMode>&, const void*, size_t, size_t, size_t) \"cudaBindTexture2D (C++ API, inherited channel descriptor)\",\n \\ref ::cudaBindTextureToArray(const struct textureReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) \"cudaBindTextureToArray (C API)\",\n \\ref ::cudaUnbindTexture(const struct textureReference*) \"cudaBindTextureToArray (C API)\",\n \\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) \"cudaGetTextureAlignmentOffset (C API)\",\n ::cuTexRefSetAddress2D,\n ::cuTexRefSetFormat,\n ::cuTexRefSetFlags,\n ::cuTexRefSetAddressMode,\n ::cuTexRefSetBorderColor"]
    pub fn cudaBindTexture2D(
        offset: *mut usize,
        texref: *const textureReference,
        devPtr: *const ::std::os::raw::c_void,
        desc: *const cudaChannelFormatDesc,
        width: usize,
        height: usize,
        pitch: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Binds an array to a texture\n\n \\deprecated\n\n Binds the CUDA array \\p array to the texture reference \\p texref.\n \\p desc describes how the memory is interpreted when fetching values from\n the texture. Any CUDA array previously bound to \\p texref is unbound.\n\n \\param texref - Texture to bind\n \\param array  - Memory array on device\n \\param desc   - Channel format\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidTexture\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) \"cudaCreateChannelDesc (C API)\",\n ::cudaGetChannelDesc, ::cudaGetTextureReference,\n \\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) \"cudaBindTexture (C API)\",\n \\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) \"cudaBindTexture2D (C API)\",\n \\ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, cudaArray_const_t, const struct cudaChannelFormatDesc&) \"cudaBindTextureToArray (C++ API)\",\n \\ref ::cudaUnbindTexture(const struct textureReference*) \"cudaUnbindTexture (C API)\",\n \\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) \"cudaGetTextureAlignmentOffset (C API)\",\n ::cuTexRefSetArray,\n ::cuTexRefSetFormat,\n ::cuTexRefSetFlags,\n ::cuTexRefSetAddressMode,\n ::cuTexRefSetFilterMode,\n ::cuTexRefSetBorderColor,\n ::cuTexRefSetMaxAnisotropy"]
    pub fn cudaBindTextureToArray(
        texref: *const textureReference,
        array: cudaArray_const_t,
        desc: *const cudaChannelFormatDesc,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Binds a mipmapped array to a texture\n\n \\deprecated\n\n Binds the CUDA mipmapped array \\p mipmappedArray to the texture reference \\p texref.\n \\p desc describes how the memory is interpreted when fetching values from\n the texture. Any CUDA mipmapped array previously bound to \\p texref is unbound.\n\n \\param texref         - Texture to bind\n \\param mipmappedArray - Memory mipmapped array on device\n \\param desc           - Channel format\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidTexture\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) \"cudaCreateChannelDesc (C API)\",\n ::cudaGetChannelDesc, ::cudaGetTextureReference,\n \\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) \"cudaBindTexture (C API)\",\n \\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) \"cudaBindTexture2D (C API)\",\n \\ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, cudaArray_const_t, const struct cudaChannelFormatDesc&) \"cudaBindTextureToArray (C++ API)\",\n \\ref ::cudaUnbindTexture(const struct textureReference*) \"cudaUnbindTexture (C API)\",\n \\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) \"cudaGetTextureAlignmentOffset (C API)\",\n ::cuTexRefSetMipmappedArray,\n ::cuTexRefSetMipmapFilterMode,\n ::cuTexRefSetMipmapLevelClamp,\n ::cuTexRefSetMipmapLevelBias,\n ::cuTexRefSetFormat,\n ::cuTexRefSetFlags,\n ::cuTexRefSetAddressMode,\n ::cuTexRefSetBorderColor,\n ::cuTexRefSetMaxAnisotropy"]
    pub fn cudaBindTextureToMipmappedArray(
        texref: *const textureReference,
        mipmappedArray: cudaMipmappedArray_const_t,
        desc: *const cudaChannelFormatDesc,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Unbinds a texture\n\n \\deprecated\n\n Unbinds the texture bound to \\p texref. If \\p texref is not currently bound, no operation is performed.\n\n \\param texref - Texture to unbind\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidTexture\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) \"cudaCreateChannelDesc (C API)\",\n ::cudaGetChannelDesc, ::cudaGetTextureReference,\n \\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) \"cudaBindTexture (C API)\",\n \\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) \"cudaBindTexture2D (C API)\",\n \\ref ::cudaBindTextureToArray(const struct textureReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) \"cudaBindTextureToArray (C API)\",\n \\ref ::cudaUnbindTexture(const struct texture< T, dim, readMode>&) \"cudaUnbindTexture (C++ API)\",\n \\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) \"cudaGetTextureAlignmentOffset (C API)\""]
    pub fn cudaUnbindTexture(texref: *const textureReference) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Get the alignment offset of a texture\n\n \\deprecated\n\n Returns in \\p *offset the offset that was returned when texture reference\n \\p texref was bound.\n\n \\param offset - Offset of texture reference in bytes\n \\param texref - Texture to get offset of\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidTexture,\n ::cudaErrorInvalidTextureBinding\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) \"cudaCreateChannelDesc (C API)\",\n ::cudaGetChannelDesc, ::cudaGetTextureReference,\n \\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) \"cudaBindTexture (C API)\",\n \\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) \"cudaBindTexture2D (C API)\",\n \\ref ::cudaBindTextureToArray(const struct textureReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) \"cudaBindTextureToArray (C API)\",\n \\ref ::cudaUnbindTexture(const struct textureReference*) \"cudaUnbindTexture (C API)\",\n \\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct texture< T, dim, readMode>&) \"cudaGetTextureAlignmentOffset (C++ API)\""]
    pub fn cudaGetTextureAlignmentOffset(
        offset: *mut usize,
        texref: *const textureReference,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Get the texture reference associated with a symbol\n\n \\deprecated\n\n Returns in \\p *texref the structure associated to the texture reference\n defined by symbol \\p symbol.\n\n \\param texref - Texture reference associated with symbol\n \\param symbol - Texture to get reference for\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidTexture\n \\notefnerr\n \\note_string_api_deprecation_50\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) \"cudaCreateChannelDesc (C API)\",\n ::cudaGetChannelDesc,\n \\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) \"cudaGetTextureAlignmentOffset (C API)\",\n \\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) \"cudaBindTexture (C API)\",\n \\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) \"cudaBindTexture2D (C API)\",\n \\ref ::cudaBindTextureToArray(const struct textureReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) \"cudaBindTextureToArray (C API)\",\n \\ref ::cudaUnbindTexture(const struct textureReference*) \"cudaUnbindTexture (C API)\",\n ::cuModuleGetTexRef"]
    pub fn cudaGetTextureReference(
        texref: *mut *const textureReference,
        symbol: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Binds an array to a surface\n\n \\deprecated\n\n Binds the CUDA array \\p array to the surface reference \\p surfref.\n \\p desc describes how the memory is interpreted when fetching values from\n the surface. Any CUDA array previously bound to \\p surfref is unbound.\n\n \\param surfref - Surface to bind\n \\param array  - Memory array on device\n \\param desc   - Channel format\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidSurface\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaBindSurfaceToArray(const struct surface< T, dim>&, cudaArray_const_t, const struct cudaChannelFormatDesc&) \"cudaBindSurfaceToArray (C++ API)\",\n \\ref ::cudaBindSurfaceToArray(const struct surface< T, dim>&, cudaArray_const_t) \"cudaBindSurfaceToArray (C++ API, inherited channel descriptor)\",\n ::cudaGetSurfaceReference,\n ::cuSurfRefSetArray"]
    pub fn cudaBindSurfaceToArray(
        surfref: *const surfaceReference,
        array: cudaArray_const_t,
        desc: *const cudaChannelFormatDesc,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Get the surface reference associated with a symbol\n\n \\deprecated\n\n Returns in \\p *surfref the structure associated to the surface reference\n defined by symbol \\p symbol.\n\n \\param surfref - Surface reference associated with symbol\n \\param symbol - Surface to get reference for\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidSurface\n \\notefnerr\n \\note_string_api_deprecation_50\n \\note_init_rt\n \\note_callback\n\n \\sa\n \\ref ::cudaBindSurfaceToArray(const struct surfaceReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) \"cudaBindSurfaceToArray (C API)\",\n ::cuModuleGetSurfRef"]
    pub fn cudaGetSurfaceReference(
        surfref: *mut *const surfaceReference,
        symbol: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Get the channel descriptor of an array\n\n Returns in \\p *desc the channel descriptor of the CUDA array \\p array.\n\n \\param desc  - Channel format\n \\param array - Memory array on device\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa \\ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) \"cudaCreateChannelDesc (C API)\",\n ::cudaCreateTextureObject, ::cudaCreateSurfaceObject"]
    pub fn cudaGetChannelDesc(
        desc: *mut cudaChannelFormatDesc,
        array: cudaArray_const_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a channel descriptor using the specified format\n\n Returns a channel descriptor with format \\p f and number of bits of each\n component \\p x, \\p y, \\p z, and \\p w.  The ::cudaChannelFormatDesc is\n defined as:\n \\code\nstruct cudaChannelFormatDesc {\nint x, y, z, w;\nenum cudaChannelFormatKind f;\n};\n \\endcode\n\n where ::cudaChannelFormatKind is one of ::cudaChannelFormatKindSigned,\n ::cudaChannelFormatKindUnsigned, or ::cudaChannelFormatKindFloat.\n\n \\param x - X component\n \\param y - Y component\n \\param z - Z component\n \\param w - W component\n \\param f - Channel format\n\n \\return\n Channel descriptor with format \\p f\n\n \\sa \\ref ::cudaCreateChannelDesc(void) \"cudaCreateChannelDesc (C++ API)\",\n ::cudaGetChannelDesc, ::cudaCreateTextureObject, ::cudaCreateSurfaceObject"]
    pub fn cudaCreateChannelDesc(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        f: cudaChannelFormatKind,
    ) -> cudaChannelFormatDesc;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a texture object\n\n Creates a texture object and returns it in \\p pTexObject. \\p pResDesc describes\n the data to texture from. \\p pTexDesc describes how the data should be sampled.\n \\p pResViewDesc is an optional argument that specifies an alternate format for\n the data described by \\p pResDesc, and also describes the subresource region\n to restrict access to when texturing. \\p pResViewDesc can only be specified if\n the type of resource is a CUDA array or a CUDA mipmapped array.\n\n Texture objects are only supported on devices of compute capability 3.0 or higher.\n Additionally, a texture object is an opaque value, and, as such, should only be\n accessed through CUDA API calls.\n\n The ::cudaResourceDesc structure is defined as:\n \\code\nstruct cudaResourceDesc {\nenum cudaResourceType resType;\n\nunion {\nstruct {\ncudaArray_t array;\n} array;\nstruct {\ncudaMipmappedArray_t mipmap;\n} mipmap;\nstruct {\nvoid *devPtr;\nstruct cudaChannelFormatDesc desc;\nsize_t sizeInBytes;\n} linear;\nstruct {\nvoid *devPtr;\nstruct cudaChannelFormatDesc desc;\nsize_t width;\nsize_t height;\nsize_t pitchInBytes;\n} pitch2D;\n} res;\n};\n \\endcode\n where:\n - ::cudaResourceDesc::resType specifies the type of resource to texture from.\n CUresourceType is defined as:\n \\code\nenum cudaResourceType {\ncudaResourceTypeArray          = 0x00,\ncudaResourceTypeMipmappedArray = 0x01,\ncudaResourceTypeLinear         = 0x02,\ncudaResourceTypePitch2D        = 0x03\n};\n \\endcode\n\n \\par\n If ::cudaResourceDesc::resType is set to ::cudaResourceTypeArray, ::cudaResourceDesc::res::array::array\n must be set to a valid CUDA array handle.\n\n \\par\n If ::cudaResourceDesc::resType is set to ::cudaResourceTypeMipmappedArray, ::cudaResourceDesc::res::mipmap::mipmap\n must be set to a valid CUDA mipmapped array handle and ::cudaTextureDesc::normalizedCoords must be set to true.\n\n \\par\n If ::cudaResourceDesc::resType is set to ::cudaResourceTypeLinear, ::cudaResourceDesc::res::linear::devPtr\n must be set to a valid device pointer, that is aligned to ::cudaDeviceProp::textureAlignment.\n ::cudaResourceDesc::res::linear::desc describes the format and the number of components per array element. ::cudaResourceDesc::res::linear::sizeInBytes\n specifies the size of the array in bytes. The total number of elements in the linear address range cannot exceed\n ::cudaDeviceProp::maxTexture1DLinear. The number of elements is computed as (sizeInBytes / sizeof(desc)).\n\n \\par\n If ::cudaResourceDesc::resType is set to ::cudaResourceTypePitch2D, ::cudaResourceDesc::res::pitch2D::devPtr\n must be set to a valid device pointer, that is aligned to ::cudaDeviceProp::textureAlignment.\n ::cudaResourceDesc::res::pitch2D::desc describes the format and the number of components per array element. ::cudaResourceDesc::res::pitch2D::width\n and ::cudaResourceDesc::res::pitch2D::height specify the width and height of the array in elements, and cannot exceed\n ::cudaDeviceProp::maxTexture2DLinear[0] and ::cudaDeviceProp::maxTexture2DLinear[1] respectively.\n ::cudaResourceDesc::res::pitch2D::pitchInBytes specifies the pitch between two rows in bytes and has to be aligned to\n ::cudaDeviceProp::texturePitchAlignment. Pitch cannot exceed ::cudaDeviceProp::maxTexture2DLinear[2].\n\n\n The ::cudaTextureDesc struct is defined as\n \\code\nstruct cudaTextureDesc {\nenum cudaTextureAddressMode addressMode[3];\nenum cudaTextureFilterMode  filterMode;\nenum cudaTextureReadMode    readMode;\nint                         sRGB;\nfloat                       borderColor[4];\nint                         normalizedCoords;\nunsigned int                maxAnisotropy;\nenum cudaTextureFilterMode  mipmapFilterMode;\nfloat                       mipmapLevelBias;\nfloat                       minMipmapLevelClamp;\nfloat                       maxMipmapLevelClamp;\nint                         disableTrilinearOptimization;\n};\n \\endcode\n where\n - ::cudaTextureDesc::addressMode specifies the addressing mode for each dimension of the texture data. ::cudaTextureAddressMode is defined as:\n   \\code\nenum cudaTextureAddressMode {\ncudaAddressModeWrap   = 0,\ncudaAddressModeClamp  = 1,\ncudaAddressModeMirror = 2,\ncudaAddressModeBorder = 3\n};\n   \\endcode\n   This is ignored if ::cudaResourceDesc::resType is ::cudaResourceTypeLinear. Also, if ::cudaTextureDesc::normalizedCoords\n   is set to zero, ::cudaAddressModeWrap and ::cudaAddressModeMirror won't be supported and will be switched to ::cudaAddressModeClamp.\n\n - ::cudaTextureDesc::filterMode specifies the filtering mode to be used when fetching from the texture. ::cudaTextureFilterMode is defined as:\n   \\code\nenum cudaTextureFilterMode {\ncudaFilterModePoint  = 0,\ncudaFilterModeLinear = 1\n};\n   \\endcode\n   This is ignored if ::cudaResourceDesc::resType is ::cudaResourceTypeLinear.\n\n - ::cudaTextureDesc::readMode specifies whether integer data should be converted to floating point or not. ::cudaTextureReadMode is defined as:\n   \\code\nenum cudaTextureReadMode {\ncudaReadModeElementType     = 0,\ncudaReadModeNormalizedFloat = 1\n};\n   \\endcode\n   Note that this applies only to 8-bit and 16-bit integer formats. 32-bit integer format would not be promoted, regardless of\n   whether or not this ::cudaTextureDesc::readMode is set ::cudaReadModeNormalizedFloat is specified.\n\n - ::cudaTextureDesc::sRGB specifies whether sRGB to linear conversion should be performed during texture fetch.\n\n - ::cudaTextureDesc::borderColor specifies the float values of color. where:\n   ::cudaTextureDesc::borderColor[0] contains value of 'R',\n   ::cudaTextureDesc::borderColor[1] contains value of 'G',\n   ::cudaTextureDesc::borderColor[2] contains value of 'B',\n   ::cudaTextureDesc::borderColor[3] contains value of 'A'\n   Note that application using integer border color values will need to <reinterpret_cast> these values to float.\n   The values are set only when the addressing mode specified by ::cudaTextureDesc::addressMode is cudaAddressModeBorder.\n\n - ::cudaTextureDesc::normalizedCoords specifies whether the texture coordinates will be normalized or not.\n\n - ::cudaTextureDesc::maxAnisotropy specifies the maximum anistropy ratio to be used when doing anisotropic filtering. This value will be\n   clamped to the range [1,16].\n\n - ::cudaTextureDesc::mipmapFilterMode specifies the filter mode when the calculated mipmap level lies between two defined mipmap levels.\n\n - ::cudaTextureDesc::mipmapLevelBias specifies the offset to be applied to the calculated mipmap level.\n\n - ::cudaTextureDesc::minMipmapLevelClamp specifies the lower end of the mipmap level range to clamp access to.\n\n - ::cudaTextureDesc::maxMipmapLevelClamp specifies the upper end of the mipmap level range to clamp access to.\n\n - ::cudaTextureDesc::disableTrilinearOptimization specifies whether the trilinear filtering optimizations will be disabled.\n\n The ::cudaResourceViewDesc struct is defined as\n \\code\nstruct cudaResourceViewDesc {\nenum cudaResourceViewFormat format;\nsize_t                      width;\nsize_t                      height;\nsize_t                      depth;\nunsigned int                firstMipmapLevel;\nunsigned int                lastMipmapLevel;\nunsigned int                firstLayer;\nunsigned int                lastLayer;\n};\n \\endcode\n where:\n - ::cudaResourceViewDesc::format specifies how the data contained in the CUDA array or CUDA mipmapped array should\n   be interpreted. Note that this can incur a change in size of the texture data. If the resource view format is a block\n   compressed format, then the underlying CUDA array or CUDA mipmapped array has to have a 32-bit unsigned integer format\n   with 2 or 4 channels, depending on the block compressed format. For ex., BC1 and BC4 require the underlying CUDA array to have\n   a 32-bit unsigned int with 2 channels. The other BC formats require the underlying resource to have the same 32-bit unsigned int\n   format but with 4 channels.\n\n - ::cudaResourceViewDesc::width specifies the new width of the texture data. If the resource view format is a block\n   compressed format, this value has to be 4 times the original width of the resource. For non block compressed formats,\n   this value has to be equal to that of the original resource.\n\n - ::cudaResourceViewDesc::height specifies the new height of the texture data. If the resource view format is a block\n   compressed format, this value has to be 4 times the original height of the resource. For non block compressed formats,\n   this value has to be equal to that of the original resource.\n\n - ::cudaResourceViewDesc::depth specifies the new depth of the texture data. This value has to be equal to that of the\n   original resource.\n\n - ::cudaResourceViewDesc::firstMipmapLevel specifies the most detailed mipmap level. This will be the new mipmap level zero.\n   For non-mipmapped resources, this value has to be zero.::cudaTextureDesc::minMipmapLevelClamp and ::cudaTextureDesc::maxMipmapLevelClamp\n   will be relative to this value. For ex., if the firstMipmapLevel is set to 2, and a minMipmapLevelClamp of 1.2 is specified,\n   then the actual minimum mipmap level clamp will be 3.2.\n\n - ::cudaResourceViewDesc::lastMipmapLevel specifies the least detailed mipmap level. For non-mipmapped resources, this value\n   has to be zero.\n\n - ::cudaResourceViewDesc::firstLayer specifies the first layer index for layered textures. This will be the new layer zero.\n   For non-layered resources, this value has to be zero.\n\n - ::cudaResourceViewDesc::lastLayer specifies the last layer index for layered textures. For non-layered resources,\n   this value has to be zero.\n\n\n \\param pTexObject   - Texture object to create\n \\param pResDesc     - Resource descriptor\n \\param pTexDesc     - Texture descriptor\n \\param pResViewDesc - Resource view descriptor\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaDestroyTextureObject,\n ::cuTexObjectCreate"]
    pub fn cudaCreateTextureObject(
        pTexObject: *mut cudaTextureObject_t,
        pResDesc: *const cudaResourceDesc,
        pTexDesc: *const cudaTextureDesc,
        pResViewDesc: *const cudaResourceViewDesc,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a texture object\n\n Creates a texture object and returns it in \\p pTexObject. \\p pResDesc describes\n the data to texture from. \\p pTexDesc describes how the data should be sampled.\n \\p pResViewDesc is an optional argument that specifies an alternate format for\n the data described by \\p pResDesc, and also describes the subresource region\n to restrict access to when texturing. \\p pResViewDesc can only be specified if\n the type of resource is a CUDA array or a CUDA mipmapped array.\n\n Texture objects are only supported on devices of compute capability 3.0 or higher.\n Additionally, a texture object is an opaque value, and, as such, should only be\n accessed through CUDA API calls.\n\n The ::cudaResourceDesc structure is defined as:\n \\code\nstruct cudaResourceDesc {\nenum cudaResourceType resType;\n\nunion {\nstruct {\ncudaArray_t array;\n} array;\nstruct {\ncudaMipmappedArray_t mipmap;\n} mipmap;\nstruct {\nvoid *devPtr;\nstruct cudaChannelFormatDesc desc;\nsize_t sizeInBytes;\n} linear;\nstruct {\nvoid *devPtr;\nstruct cudaChannelFormatDesc desc;\nsize_t width;\nsize_t height;\nsize_t pitchInBytes;\n} pitch2D;\n} res;\n};\n \\endcode\n where:\n - ::cudaResourceDesc::resType specifies the type of resource to texture from.\n CUresourceType is defined as:\n \\code\nenum cudaResourceType {\ncudaResourceTypeArray          = 0x00,\ncudaResourceTypeMipmappedArray = 0x01,\ncudaResourceTypeLinear         = 0x02,\ncudaResourceTypePitch2D        = 0x03\n};\n \\endcode\n\n \\par\n If ::cudaResourceDesc::resType is set to ::cudaResourceTypeArray, ::cudaResourceDesc::res::array::array\n must be set to a valid CUDA array handle.\n\n \\par\n If ::cudaResourceDesc::resType is set to ::cudaResourceTypeMipmappedArray, ::cudaResourceDesc::res::mipmap::mipmap\n must be set to a valid CUDA mipmapped array handle and ::cudaTextureDesc_v2::normalizedCoords must be set to true.\n\n \\par\n If ::cudaResourceDesc::resType is set to ::cudaResourceTypeLinear, ::cudaResourceDesc::res::linear::devPtr\n must be set to a valid device pointer, that is aligned to ::cudaDeviceProp::textureAlignment.\n ::cudaResourceDesc::res::linear::desc describes the format and the number of components per array element. ::cudaResourceDesc::res::linear::sizeInBytes\n specifies the size of the array in bytes. The total number of elements in the linear address range cannot exceed\n ::cudaDeviceProp::maxTexture1DLinear. The number of elements is computed as (sizeInBytes / sizeof(desc)).\n\n \\par\n If ::cudaResourceDesc::resType is set to ::cudaResourceTypePitch2D, ::cudaResourceDesc::res::pitch2D::devPtr\n must be set to a valid device pointer, that is aligned to ::cudaDeviceProp::textureAlignment.\n ::cudaResourceDesc::res::pitch2D::desc describes the format and the number of components per array element. ::cudaResourceDesc::res::pitch2D::width\n and ::cudaResourceDesc::res::pitch2D::height specify the width and height of the array in elements, and cannot exceed\n ::cudaDeviceProp::maxTexture2DLinear[0] and ::cudaDeviceProp::maxTexture2DLinear[1] respectively.\n ::cudaResourceDesc::res::pitch2D::pitchInBytes specifies the pitch between two rows in bytes and has to be aligned to\n ::cudaDeviceProp::texturePitchAlignment. Pitch cannot exceed ::cudaDeviceProp::maxTexture2DLinear[2].\n\n\n The ::cudaTextureDesc_v2 struct is defined as\n \\code\nstruct cudaTextureDesc_v2 {\nenum cudaTextureAddressMode addressMode[3];\nenum cudaTextureFilterMode  filterMode;\nenum cudaTextureReadMode    readMode;\nint                         sRGB;\nfloat                       borderColor[4];\nint                         normalizedCoords;\nunsigned int                maxAnisotropy;\nenum cudaTextureFilterMode  mipmapFilterMode;\nfloat                       mipmapLevelBias;\nfloat                       minMipmapLevelClamp;\nfloat                       maxMipmapLevelClamp;\nint                         disableTrilinearOptimization;\nint                         seamlessCubemap;\n};\n \\endcode\n where\n - ::cudaTextureDesc_v2::addressMode specifies the addressing mode for each dimension of the texture data. ::cudaTextureAddressMode is defined as:\n   \\code\nenum cudaTextureAddressMode {\ncudaAddressModeWrap   = 0,\ncudaAddressModeClamp  = 1,\ncudaAddressModeMirror = 2,\ncudaAddressModeBorder = 3\n};\n   \\endcode\n   This is ignored if ::cudaResourceDesc::resType is ::cudaResourceTypeLinear. Also, if ::cudaTextureDesc_v2::normalizedCoords\n   is set to zero, ::cudaAddressModeWrap and ::cudaAddressModeMirror won't be supported and will be switched to ::cudaAddressModeClamp.\n\n - ::cudaTextureDesc_v2::filterMode specifies the filtering mode to be used when fetching from the texture. ::cudaTextureFilterMode is defined as:\n   \\code\nenum cudaTextureFilterMode {\ncudaFilterModePoint  = 0,\ncudaFilterModeLinear = 1\n};\n   \\endcode\n   This is ignored if ::cudaResourceDesc::resType is ::cudaResourceTypeLinear.\n\n - ::cudaTextureDesc_v2::readMode specifies whether integer data should be converted to floating point or not. ::cudaTextureReadMode is defined as:\n   \\code\nenum cudaTextureReadMode {\ncudaReadModeElementType     = 0,\ncudaReadModeNormalizedFloat = 1\n};\n   \\endcode\n   Note that this applies only to 8-bit and 16-bit integer formats. 32-bit integer format would not be promoted, regardless of\n   whether or not this ::cudaTextureDesc_v2::readMode is set ::cudaReadModeNormalizedFloat is specified.\n\n - ::cudaTextureDesc_v2::sRGB specifies whether sRGB to linear conversion should be performed during texture fetch.\n\n - ::cudaTextureDesc_v2::borderColor specifies the float values of color. where:\n   ::cudaTextureDesc_v2::borderColor[0] contains value of 'R',\n   ::cudaTextureDesc_v2::borderColor[1] contains value of 'G',\n   ::cudaTextureDesc_v2::borderColor[2] contains value of 'B',\n   ::cudaTextureDesc_v2::borderColor[3] contains value of 'A'\n   Note that application using integer border color values will need to <reinterpret_cast> these values to float.\n   The values are set only when the addressing mode specified by ::cudaTextureDesc_v2::addressMode is cudaAddressModeBorder.\n\n - ::cudaTextureDesc_v2::normalizedCoords specifies whether the texture coordinates will be normalized or not.\n\n - ::cudaTextureDesc_v2::maxAnisotropy specifies the maximum anistropy ratio to be used when doing anisotropic filtering. This value will be\n   clamped to the range [1,16].\n\n - ::cudaTextureDesc_v2::mipmapFilterMode specifies the filter mode when the calculated mipmap level lies between two defined mipmap levels.\n\n - ::cudaTextureDesc_v2::mipmapLevelBias specifies the offset to be applied to the calculated mipmap level.\n\n - ::cudaTextureDesc_v2::minMipmapLevelClamp specifies the lower end of the mipmap level range to clamp access to.\n\n - ::cudaTextureDesc_v2::maxMipmapLevelClamp specifies the upper end of the mipmap level range to clamp access to.\n\n - ::cudaTextureDesc_v2::disableTrilinearOptimization specifies whether the trilinear filtering optimizations will be disabled.\n\n - ::cudaTextureDesc_v2::seamlessCubemap specifies whether seamless cube map filtering is enabled. This flag can only be specified if the\n   underlying resource is a CUDA array or a CUDA mipmapped array that was created with the flag ::cudaArrayCubemap.\n   When seamless cube map filtering is enabled, texture address modes specified by ::cudaTextureDesc_v2::addressMode are ignored.\n   Instead, if the ::cudaTextureDesc_v2::filterMode is set to ::cudaFilterModePoint the address mode ::cudaAddressModeClamp will be applied for all dimensions.\n   If the ::cudaTextureDesc_v2::filterMode is set to ::cudaFilterModeLinear seamless cube map filtering will be performed when sampling along the cube face borders.\n\n The ::cudaResourceViewDesc struct is defined as\n \\code\nstruct cudaResourceViewDesc {\nenum cudaResourceViewFormat format;\nsize_t                      width;\nsize_t                      height;\nsize_t                      depth;\nunsigned int                firstMipmapLevel;\nunsigned int                lastMipmapLevel;\nunsigned int                firstLayer;\nunsigned int                lastLayer;\n};\n \\endcode\n where:\n - ::cudaResourceViewDesc::format specifies how the data contained in the CUDA array or CUDA mipmapped array should\n   be interpreted. Note that this can incur a change in size of the texture data. If the resource view format is a block\n   compressed format, then the underlying CUDA array or CUDA mipmapped array has to have a 32-bit unsigned integer format\n   with 2 or 4 channels, depending on the block compressed format. For ex., BC1 and BC4 require the underlying CUDA array to have\n   a 32-bit unsigned int with 2 channels. The other BC formats require the underlying resource to have the same 32-bit unsigned int\n   format but with 4 channels.\n\n - ::cudaResourceViewDesc::width specifies the new width of the texture data. If the resource view format is a block\n   compressed format, this value has to be 4 times the original width of the resource. For non block compressed formats,\n   this value has to be equal to that of the original resource.\n\n - ::cudaResourceViewDesc::height specifies the new height of the texture data. If the resource view format is a block\n   compressed format, this value has to be 4 times the original height of the resource. For non block compressed formats,\n   this value has to be equal to that of the original resource.\n\n - ::cudaResourceViewDesc::depth specifies the new depth of the texture data. This value has to be equal to that of the\n   original resource.\n\n - ::cudaResourceViewDesc::firstMipmapLevel specifies the most detailed mipmap level. This will be the new mipmap level zero.\n   For non-mipmapped resources, this value has to be zero.::cudaTextureDesc_v2::minMipmapLevelClamp and ::cudaTextureDesc_v2::maxMipmapLevelClamp\n   will be relative to this value. For ex., if the firstMipmapLevel is set to 2, and a minMipmapLevelClamp of 1.2 is specified,\n   then the actual minimum mipmap level clamp will be 3.2.\n\n - ::cudaResourceViewDesc::lastMipmapLevel specifies the least detailed mipmap level. For non-mipmapped resources, this value\n   has to be zero.\n\n - ::cudaResourceViewDesc::firstLayer specifies the first layer index for layered textures. This will be the new layer zero.\n   For non-layered resources, this value has to be zero.\n\n - ::cudaResourceViewDesc::lastLayer specifies the last layer index for layered textures. For non-layered resources,\n   this value has to be zero.\n\n\n \\param pTexObject   - Texture object to create\n \\param pResDesc     - Resource descriptor\n \\param pTexDesc     - Texture descriptor\n \\param pResViewDesc - Resource view descriptor\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaDestroyTextureObject,\n ::cuTexObjectCreate"]
    pub fn cudaCreateTextureObject_v2(
        pTexObject: *mut cudaTextureObject_t,
        pResDesc: *const cudaResourceDesc,
        pTexDesc: *const cudaTextureDesc_v2,
        pResViewDesc: *const cudaResourceViewDesc,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Destroys a texture object\n\n Destroys the texture object specified by \\p texObject.\n\n \\param texObject - Texture object to destroy\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n \\note_destroy_ub\n\n \\sa\n ::cudaCreateTextureObject,\n ::cuTexObjectDestroy"]
    pub fn cudaDestroyTextureObject(texObject: cudaTextureObject_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a texture object's resource descriptor\n\n Returns the resource descriptor for the texture object specified by \\p texObject.\n\n \\param pResDesc  - Resource descriptor\n \\param texObject - Texture object\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaCreateTextureObject,\n ::cuTexObjectGetResourceDesc"]
    pub fn cudaGetTextureObjectResourceDesc(
        pResDesc: *mut cudaResourceDesc,
        texObject: cudaTextureObject_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a texture object's texture descriptor\n\n Returns the texture descriptor for the texture object specified by \\p texObject.\n\n \\param pTexDesc  - Texture descriptor\n \\param texObject - Texture object\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaCreateTextureObject,\n ::cuTexObjectGetTextureDesc"]
    pub fn cudaGetTextureObjectTextureDesc(
        pTexDesc: *mut cudaTextureDesc,
        texObject: cudaTextureObject_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a texture object's texture descriptor\n\n Returns the texture descriptor for the texture object specified by \\p texObject.\n\n \\param pTexDesc  - Texture descriptor\n \\param texObject - Texture object\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaCreateTextureObject,\n ::cuTexObjectGetTextureDesc"]
    pub fn cudaGetTextureObjectTextureDesc_v2(
        pTexDesc: *mut cudaTextureDesc_v2,
        texObject: cudaTextureObject_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a texture object's resource view descriptor\n\n Returns the resource view descriptor for the texture object specified by \\p texObject.\n If no resource view was specified, ::cudaErrorInvalidValue is returned.\n\n \\param pResViewDesc - Resource view descriptor\n \\param texObject    - Texture object\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaCreateTextureObject,\n ::cuTexObjectGetResourceViewDesc"]
    pub fn cudaGetTextureObjectResourceViewDesc(
        pResViewDesc: *mut cudaResourceViewDesc,
        texObject: cudaTextureObject_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a surface object\n\n Creates a surface object and returns it in \\p pSurfObject. \\p pResDesc describes\n the data to perform surface load/stores on. ::cudaResourceDesc::resType must be\n ::cudaResourceTypeArray and  ::cudaResourceDesc::res::array::array\n must be set to a valid CUDA array handle.\n\n Surface objects are only supported on devices of compute capability 3.0 or higher.\n Additionally, a surface object is an opaque value, and, as such, should only be\n accessed through CUDA API calls.\n\n \\param pSurfObject - Surface object to create\n \\param pResDesc    - Resource descriptor\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidChannelDescriptor,\n ::cudaErrorInvalidResourceHandle\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaDestroySurfaceObject,\n ::cuSurfObjectCreate"]
    pub fn cudaCreateSurfaceObject(
        pSurfObject: *mut cudaSurfaceObject_t,
        pResDesc: *const cudaResourceDesc,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Destroys a surface object\n\n Destroys the surface object specified by \\p surfObject.\n\n \\param surfObject - Surface object to destroy\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n \\note_destroy_ub\n\n \\sa\n ::cudaCreateSurfaceObject,\n ::cuSurfObjectDestroy"]
    pub fn cudaDestroySurfaceObject(surfObject: cudaSurfaceObject_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a surface object's resource descriptor\n Returns the resource descriptor for the surface object specified by \\p surfObject.\n\n \\param pResDesc   - Resource descriptor\n \\param surfObject - Surface object\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaCreateSurfaceObject,\n ::cuSurfObjectGetResourceDesc"]
    pub fn cudaGetSurfaceObjectResourceDesc(
        pResDesc: *mut cudaResourceDesc,
        surfObject: cudaSurfaceObject_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the latest version of CUDA supported by the driver\n\n Returns in \\p *driverVersion the latest version of CUDA supported by\n the driver. The version is returned as (1000 &times; major + 10 &times; minor).\n For example, CUDA 9.2 would be represented by 9020. If no driver is installed,\n then 0 is returned as the driver version.\n\n This function automatically returns ::cudaErrorInvalidValue\n if \\p driverVersion is NULL.\n\n \\param driverVersion - Returns the CUDA driver version.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaRuntimeGetVersion,\n ::cuDriverGetVersion"]
    pub fn cudaDriverGetVersion(driverVersion: *mut ::std::os::raw::c_int) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the CUDA Runtime version\n\n Returns in \\p *runtimeVersion the version number of the current CUDA\n Runtime instance. The version is returned as\n (1000 &times; major + 10 &times; minor). For example,\n CUDA 9.2 would be represented by 9020.\n\n This function automatically returns ::cudaErrorInvalidValue if\n the \\p runtimeVersion argument is NULL.\n\n \\param runtimeVersion - Returns the CUDA Runtime version.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaDriverGetVersion,\n ::cuDriverGetVersion"]
    pub fn cudaRuntimeGetVersion(runtimeVersion: *mut ::std::os::raw::c_int) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a graph\n\n Creates an empty graph, which is returned via \\p pGraph.\n\n \\param pGraph - Returns newly created graph\n \\param flags   - Graph creation flags, must be 0\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphAddChildGraphNode,\n ::cudaGraphAddEmptyNode,\n ::cudaGraphAddKernelNode,\n ::cudaGraphAddHostNode,\n ::cudaGraphAddMemcpyNode,\n ::cudaGraphAddMemsetNode,\n ::cudaGraphInstantiate,\n ::cudaGraphDestroy,\n ::cudaGraphGetNodes,\n ::cudaGraphGetRootNodes,\n ::cudaGraphGetEdges,\n ::cudaGraphClone"]
    pub fn cudaGraphCreate(pGraph: *mut cudaGraph_t, flags: ::std::os::raw::c_uint) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a kernel execution node and adds it to a graph\n\n Creates a new kernel execution node and adds it to \\p graph with \\p numDependencies\n dependencies specified via \\p pDependencies and arguments specified in \\p pNodeParams.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p pDependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p pGraphNode.\n\n The cudaKernelNodeParams structure is defined as:\n\n \\code\n  struct cudaKernelNodeParams\n  {\n      void* func;\n      dim3 gridDim;\n      dim3 blockDim;\n      unsigned int sharedMemBytes;\n      void **kernelParams;\n      void **extra;\n  };\n \\endcode\n\n When the graph is launched, the node will invoke kernel \\p func on a (\\p gridDim.x x\n \\p gridDim.y x \\p gridDim.z) grid of blocks. Each block contains\n (\\p blockDim.x x \\p blockDim.y x \\p blockDim.z) threads.\n\n \\p sharedMem sets the amount of dynamic shared memory that will be\n available to each thread block.\n\n Kernel parameters to \\p func can be specified in one of two ways:\n\n 1) Kernel parameters can be specified via \\p kernelParams. If the kernel has N\n parameters, then \\p kernelParams needs to be an array of N pointers. Each pointer,\n from \\p kernelParams[0] to \\p kernelParams[N-1], points to the region of memory from which the actual\n parameter will be copied. The number of kernel parameters and their offsets and sizes do not need\n to be specified as that information is retrieved directly from the kernel's image.\n\n 2) Kernel parameters can also be packaged by the application into a single buffer that is passed in\n via \\p extra. This places the burden on the application of knowing each kernel\n parameter's size and alignment/padding within the buffer. The \\p extra parameter exists\n to allow this function to take additional less commonly used arguments. \\p extra specifies\n a list of names of extra settings and their corresponding values. Each extra setting name is\n immediately followed by the corresponding value. The list must be terminated with either NULL or\n CU_LAUNCH_PARAM_END.\n\n - ::CU_LAUNCH_PARAM_END, which indicates the end of the \\p extra\n   array;\n - ::CU_LAUNCH_PARAM_BUFFER_POINTER, which specifies that the next\n   value in \\p extra will be a pointer to a buffer\n   containing all the kernel parameters for launching kernel\n   \\p func;\n - ::CU_LAUNCH_PARAM_BUFFER_SIZE, which specifies that the next\n   value in \\p extra will be a pointer to a size_t\n   containing the size of the buffer specified with\n   ::CU_LAUNCH_PARAM_BUFFER_POINTER;\n\n The error ::cudaErrorInvalidValue will be returned if kernel parameters are specified with both\n \\p kernelParams and \\p extra (i.e. both \\p kernelParams and\n \\p extra are non-NULL).\n\n The \\p kernelParams or \\p extra array, as well as the argument values it points to,\n are copied during this call.\n\n \\note Kernels launched using graphs must not use texture and surface references. Reading or\n       writing through any texture or surface reference is undefined behavior.\n       This restriction does not apply to texture and surface objects.\n\n \\param pGraphNode     - Returns newly created node\n \\param graph          - Graph to which to add the node\n \\param pDependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param pNodeParams      - Parameters for the GPU execution node\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidDeviceFunction\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaLaunchKernel,\n ::cudaGraphKernelNodeGetParams,\n ::cudaGraphKernelNodeSetParams,\n ::cudaGraphCreate,\n ::cudaGraphDestroyNode,\n ::cudaGraphAddChildGraphNode,\n ::cudaGraphAddEmptyNode,\n ::cudaGraphAddHostNode,\n ::cudaGraphAddMemcpyNode,\n ::cudaGraphAddMemsetNode"]
    pub fn cudaGraphAddKernelNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        pNodeParams: *const cudaKernelNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a kernel node's parameters\n\n Returns the parameters of kernel node \\p node in \\p pNodeParams.\n The \\p kernelParams or \\p extra array returned in \\p pNodeParams,\n as well as the argument values it points to, are owned by the node.\n This memory remains valid until the node is destroyed or its\n parameters are modified, and should not be modified\n directly. Use ::cudaGraphKernelNodeSetParams to update the\n parameters of this node.\n\n The params will contain either \\p kernelParams or \\p extra,\n according to which of these was most recently set on the node.\n\n \\param node        - Node to get the parameters for\n \\param pNodeParams - Pointer to return the parameters\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidDeviceFunction\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaLaunchKernel,\n ::cudaGraphAddKernelNode,\n ::cudaGraphKernelNodeSetParams"]
    pub fn cudaGraphKernelNodeGetParams(
        node: cudaGraphNode_t,
        pNodeParams: *mut cudaKernelNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets a kernel node's parameters\n\n Sets the parameters of kernel node \\p node to \\p pNodeParams.\n\n \\param node        - Node to set the parameters for\n \\param pNodeParams - Parameters to copy\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle,\n ::cudaErrorMemoryAllocation\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaLaunchKernel,\n ::cudaGraphAddKernelNode,\n ::cudaGraphKernelNodeGetParams"]
    pub fn cudaGraphKernelNodeSetParams(
        node: cudaGraphNode_t,
        pNodeParams: *const cudaKernelNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Copies attributes from source node to destination node.\n\n Copies attributes from source node \\p src to destination node \\p dst.\n Both node must have the same context.\n\n \\param[out] dst Destination node\n \\param[in] src Source node\n For list of attributes see ::cudaKernelNodeAttrID\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidContext\n \\notefnerr\n\n \\sa\n ::cudaAccessPolicyWindow"]
    pub fn cudaGraphKernelNodeCopyAttributes(
        hSrc: cudaGraphNode_t,
        hDst: cudaGraphNode_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Queries node attribute.\n\n Queries attribute \\p attr from node \\p hNode and stores it in corresponding\n member of \\p value_out.\n\n \\param[in] hNode\n \\param[in] attr\n \\param[out] value_out\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n\n \\sa\n ::cudaAccessPolicyWindow"]
    pub fn cudaGraphKernelNodeGetAttribute(
        hNode: cudaGraphNode_t,
        attr: cudaLaunchAttributeID,
        value_out: *mut cudaLaunchAttributeValue,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets node attribute.\n\n Sets attribute \\p attr on node \\p hNode from corresponding attribute of\n \\p value.\n\n \\param[out] hNode\n \\param[in] attr\n \\param[out] value\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidResourceHandle\n \\notefnerr\n\n \\sa\n ::cudaAccessPolicyWindow"]
    pub fn cudaGraphKernelNodeSetAttribute(
        hNode: cudaGraphNode_t,
        attr: cudaLaunchAttributeID,
        value: *const cudaLaunchAttributeValue,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a memcpy node and adds it to a graph\n\n Creates a new memcpy node and adds it to \\p graph with \\p numDependencies\n dependencies specified via \\p pDependencies.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p pDependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p pGraphNode.\n\n When the graph is launched, the node will perform the memcpy described by \\p pCopyParams.\n See ::cudaMemcpy3D() for a description of the structure and its restrictions.\n\n Memcpy nodes have some additional restrictions with regards to managed memory, if the\n system contains at least one device which has a zero value for the device attribute\n ::cudaDevAttrConcurrentManagedAccess.\n\n \\param pGraphNode     - Returns newly created node\n \\param graph          - Graph to which to add the node\n \\param pDependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param pCopyParams      - Parameters for the memory copy\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaMemcpy3D,\n ::cudaGraphAddMemcpyNodeToSymbol,\n ::cudaGraphAddMemcpyNodeFromSymbol,\n ::cudaGraphAddMemcpyNode1D,\n ::cudaGraphMemcpyNodeGetParams,\n ::cudaGraphMemcpyNodeSetParams,\n ::cudaGraphCreate,\n ::cudaGraphDestroyNode,\n ::cudaGraphAddChildGraphNode,\n ::cudaGraphAddEmptyNode,\n ::cudaGraphAddKernelNode,\n ::cudaGraphAddHostNode,\n ::cudaGraphAddMemsetNode"]
    pub fn cudaGraphAddMemcpyNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        pCopyParams: *const cudaMemcpy3DParms,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphAddMemcpyNodeToSymbol(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphAddMemcpyNodeFromSymbol(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphAddMemcpyNode1D(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a memcpy node's parameters\n\n Returns the parameters of memcpy node \\p node in \\p pNodeParams.\n\n \\param node        - Node to get the parameters for\n \\param pNodeParams - Pointer to return the parameters\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaMemcpy3D,\n ::cudaGraphAddMemcpyNode,\n ::cudaGraphMemcpyNodeSetParams"]
    pub fn cudaGraphMemcpyNodeGetParams(
        node: cudaGraphNode_t,
        pNodeParams: *mut cudaMemcpy3DParms,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets a memcpy node's parameters\n\n Sets the parameters of memcpy node \\p node to \\p pNodeParams.\n\n \\param node        - Node to set the parameters for\n \\param pNodeParams - Parameters to copy\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaMemcpy3D,\n ::cudaGraphMemcpyNodeSetParamsToSymbol,\n ::cudaGraphMemcpyNodeSetParamsFromSymbol,\n ::cudaGraphMemcpyNodeSetParams1D,\n ::cudaGraphAddMemcpyNode,\n ::cudaGraphMemcpyNodeGetParams"]
    pub fn cudaGraphMemcpyNodeSetParams(
        node: cudaGraphNode_t,
        pNodeParams: *const cudaMemcpy3DParms,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphMemcpyNodeSetParamsToSymbol(
        node: cudaGraphNode_t,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphMemcpyNodeSetParamsFromSymbol(
        node: cudaGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphMemcpyNodeSetParams1D(
        node: cudaGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a memset node and adds it to a graph\n\n Creates a new memset node and adds it to \\p graph with \\p numDependencies\n dependencies specified via \\p pDependencies.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p pDependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p pGraphNode.\n\n The element size must be 1, 2, or 4 bytes.\n When the graph is launched, the node will perform the memset described by \\p pMemsetParams.\n\n \\param pGraphNode     - Returns newly created node\n \\param graph          - Graph to which to add the node\n \\param pDependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param pMemsetParams    - Parameters for the memory set\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorInvalidDevice\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaMemset2D,\n ::cudaGraphMemsetNodeGetParams,\n ::cudaGraphMemsetNodeSetParams,\n ::cudaGraphCreate,\n ::cudaGraphDestroyNode,\n ::cudaGraphAddChildGraphNode,\n ::cudaGraphAddEmptyNode,\n ::cudaGraphAddKernelNode,\n ::cudaGraphAddHostNode,\n ::cudaGraphAddMemcpyNode"]
    pub fn cudaGraphAddMemsetNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        pMemsetParams: *const cudaMemsetParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a memset node's parameters\n\n Returns the parameters of memset node \\p node in \\p pNodeParams.\n\n \\param node        - Node to get the parameters for\n \\param pNodeParams - Pointer to return the parameters\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaMemset2D,\n ::cudaGraphAddMemsetNode,\n ::cudaGraphMemsetNodeSetParams"]
    pub fn cudaGraphMemsetNodeGetParams(
        node: cudaGraphNode_t,
        pNodeParams: *mut cudaMemsetParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets a memset node's parameters\n\n Sets the parameters of memset node \\p node to \\p pNodeParams.\n\n \\param node        - Node to set the parameters for\n \\param pNodeParams - Parameters to copy\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaMemset2D,\n ::cudaGraphAddMemsetNode,\n ::cudaGraphMemsetNodeGetParams"]
    pub fn cudaGraphMemsetNodeSetParams(
        node: cudaGraphNode_t,
        pNodeParams: *const cudaMemsetParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a host execution node and adds it to a graph\n\n Creates a new CPU execution node and adds it to \\p graph with \\p numDependencies\n dependencies specified via \\p pDependencies and arguments specified in \\p pNodeParams.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p pDependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p pGraphNode.\n\n When the graph is launched, the node will invoke the specified CPU function.\n Host nodes are not supported under MPS with pre-Volta GPUs.\n\n \\param pGraphNode     - Returns newly created node\n \\param graph          - Graph to which to add the node\n \\param pDependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param pNodeParams      - Parameters for the host node\n\n \\return\n ::cudaSuccess,\n ::cudaErrorNotSupported,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaLaunchHostFunc,\n ::cudaGraphHostNodeGetParams,\n ::cudaGraphHostNodeSetParams,\n ::cudaGraphCreate,\n ::cudaGraphDestroyNode,\n ::cudaGraphAddChildGraphNode,\n ::cudaGraphAddEmptyNode,\n ::cudaGraphAddKernelNode,\n ::cudaGraphAddMemcpyNode,\n ::cudaGraphAddMemsetNode"]
    pub fn cudaGraphAddHostNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        pNodeParams: *const cudaHostNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a host node's parameters\n\n Returns the parameters of host node \\p node in \\p pNodeParams.\n\n \\param node        - Node to get the parameters for\n \\param pNodeParams - Pointer to return the parameters\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaLaunchHostFunc,\n ::cudaGraphAddHostNode,\n ::cudaGraphHostNodeSetParams"]
    pub fn cudaGraphHostNodeGetParams(
        node: cudaGraphNode_t,
        pNodeParams: *mut cudaHostNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets a host node's parameters\n\n Sets the parameters of host node \\p node to \\p nodeParams.\n\n \\param node        - Node to set the parameters for\n \\param pNodeParams - Parameters to copy\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaLaunchHostFunc,\n ::cudaGraphAddHostNode,\n ::cudaGraphHostNodeGetParams"]
    pub fn cudaGraphHostNodeSetParams(
        node: cudaGraphNode_t,
        pNodeParams: *const cudaHostNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a child graph node and adds it to a graph\n\n Creates a new node which executes an embedded graph, and adds it to \\p graph with\n \\p numDependencies dependencies specified via \\p pDependencies.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p pDependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p pGraphNode.\n\n If \\p hGraph contains allocation or free nodes, this call will return an error.\n\n The node executes an embedded child graph. The child graph is cloned in this call.\n\n \\param pGraphNode     - Returns newly created node\n \\param graph          - Graph to which to add the node\n \\param pDependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param childGraph      - The graph to clone into this node\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphChildGraphNodeGetGraph,\n ::cudaGraphCreate,\n ::cudaGraphDestroyNode,\n ::cudaGraphAddEmptyNode,\n ::cudaGraphAddKernelNode,\n ::cudaGraphAddHostNode,\n ::cudaGraphAddMemcpyNode,\n ::cudaGraphAddMemsetNode,\n ::cudaGraphClone"]
    pub fn cudaGraphAddChildGraphNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        childGraph: cudaGraph_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Gets a handle to the embedded graph of a child graph node\n\n Gets a handle to the embedded graph in a child graph node. This call\n does not clone the graph. Changes to the graph will be reflected in\n the node, and the node retains ownership of the graph.\n\n Allocation and free nodes cannot be added to the returned graph.\n Attempting to do so will return an error.\n\n \\param node   - Node to get the embedded graph for\n \\param pGraph - Location to store a handle to the graph\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphAddChildGraphNode,\n ::cudaGraphNodeFindInClone"]
    pub fn cudaGraphChildGraphNodeGetGraph(
        node: cudaGraphNode_t,
        pGraph: *mut cudaGraph_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates an empty node and adds it to a graph\n\n Creates a new node which performs no operation, and adds it to \\p graph with\n \\p numDependencies dependencies specified via \\p pDependencies.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p pDependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p pGraphNode.\n\n An empty node performs no operation during execution, but can be used for\n transitive ordering. For example, a phased execution graph with 2 groups of n\n nodes with a barrier between them can be represented using an empty node and\n 2*n dependency edges, rather than no empty node and n^2 dependency edges.\n\n \\param pGraphNode     - Returns newly created node\n \\param graph          - Graph to which to add the node\n \\param pDependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphCreate,\n ::cudaGraphDestroyNode,\n ::cudaGraphAddChildGraphNode,\n ::cudaGraphAddKernelNode,\n ::cudaGraphAddHostNode,\n ::cudaGraphAddMemcpyNode,\n ::cudaGraphAddMemsetNode"]
    pub fn cudaGraphAddEmptyNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphAddEventRecordNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphEventRecordNodeGetEvent(
        node: cudaGraphNode_t,
        event_out: *mut cudaEvent_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphEventRecordNodeSetEvent(
        node: cudaGraphNode_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphAddEventWaitNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphEventWaitNodeGetEvent(
        node: cudaGraphNode_t,
        event_out: *mut cudaEvent_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphEventWaitNodeSetEvent(node: cudaGraphNode_t, event: cudaEvent_t)
                                          -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphAddExternalSemaphoresSignalNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        nodeParams: *const cudaExternalSemaphoreSignalNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphExternalSemaphoresSignalNodeGetParams(
        hNode: cudaGraphNode_t,
        params_out: *mut cudaExternalSemaphoreSignalNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphExternalSemaphoresSignalNodeSetParams(
        hNode: cudaGraphNode_t,
        nodeParams: *const cudaExternalSemaphoreSignalNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphAddExternalSemaphoresWaitNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        nodeParams: *const cudaExternalSemaphoreWaitNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphExternalSemaphoresWaitNodeGetParams(
        hNode: cudaGraphNode_t,
        params_out: *mut cudaExternalSemaphoreWaitNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphExternalSemaphoresWaitNodeSetParams(
        hNode: cudaGraphNode_t,
        nodeParams: *const cudaExternalSemaphoreWaitNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphAddMemAllocNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        nodeParams: *mut cudaMemAllocNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphMemAllocNodeGetParams(
        node: cudaGraphNode_t,
        params_out: *mut cudaMemAllocNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphAddMemFreeNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        dptr: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphMemFreeNodeGetParams(
        node: cudaGraphNode_t,
        dptr_out: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaDeviceGraphMemTrim(device: ::std::os::raw::c_int) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaDeviceGetGraphMemAttribute(
        device: ::std::os::raw::c_int,
        attr: cudaGraphMemAttributeType,
        value: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaDeviceSetGraphMemAttribute(
        device: ::std::os::raw::c_int,
        attr: cudaGraphMemAttributeType,
        value: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Clones a graph\n\n This function creates a copy of \\p originalGraph and returns it in \\p pGraphClone.\n All parameters are copied into the cloned graph. The original graph may be modified\n after this call without affecting the clone.\n\n Child graph nodes in the original graph are recursively copied into the clone.\n\n \\param pGraphClone  - Returns newly created cloned graph\n \\param originalGraph - Graph to clone\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorMemoryAllocation\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphCreate,\n ::cudaGraphNodeFindInClone"]
    pub fn cudaGraphClone(pGraphClone: *mut cudaGraph_t, originalGraph: cudaGraph_t)
                          -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Finds a cloned version of a node\n\n This function returns the node in \\p clonedGraph corresponding to \\p originalNode\n in the original graph.\n\n \\p clonedGraph must have been cloned from \\p originalGraph via ::cudaGraphClone.\n \\p originalNode must have been in \\p originalGraph at the time of the call to\n ::cudaGraphClone, and the corresponding cloned node in \\p clonedGraph must not have\n been removed. The cloned node is then returned via \\p pClonedNode.\n\n \\param pNode  - Returns handle to the cloned node\n \\param originalNode - Handle to the original node\n \\param clonedGraph - Cloned graph to query\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphClone"]
    pub fn cudaGraphNodeFindInClone(
        pNode: *mut cudaGraphNode_t,
        originalNode: cudaGraphNode_t,
        clonedGraph: cudaGraph_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a node's type\n\n Returns the node type of \\p node in \\p pType.\n\n \\param node - Node to query\n \\param pType  - Pointer to return the node type\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphGetNodes,\n ::cudaGraphGetRootNodes,\n ::cudaGraphChildGraphNodeGetGraph,\n ::cudaGraphKernelNodeGetParams,\n ::cudaGraphKernelNodeSetParams,\n ::cudaGraphHostNodeGetParams,\n ::cudaGraphHostNodeSetParams,\n ::cudaGraphMemcpyNodeGetParams,\n ::cudaGraphMemcpyNodeSetParams,\n ::cudaGraphMemsetNodeGetParams,\n ::cudaGraphMemsetNodeSetParams"]
    pub fn cudaGraphNodeGetType(
        node: cudaGraphNode_t,
        pType: *mut cudaGraphNodeType,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a graph's nodes\n\n Returns a list of \\p graph's nodes. \\p nodes may be NULL, in which case this\n function will return the number of nodes in \\p numNodes. Otherwise,\n \\p numNodes entries will be filled in. If \\p numNodes is higher than the actual\n number of nodes, the remaining entries in \\p nodes will be set to NULL, and the\n number of nodes actually obtained will be returned in \\p numNodes.\n\n \\param graph    - Graph to query\n \\param nodes    - Pointer to return the nodes\n \\param numNodes - See description\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphCreate,\n ::cudaGraphGetRootNodes,\n ::cudaGraphGetEdges,\n ::cudaGraphNodeGetType,\n ::cudaGraphNodeGetDependencies,\n ::cudaGraphNodeGetDependentNodes"]
    pub fn cudaGraphGetNodes(
        graph: cudaGraph_t,
        nodes: *mut cudaGraphNode_t,
        numNodes: *mut usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a graph's root nodes\n\n Returns a list of \\p graph's root nodes. \\p pRootNodes may be NULL, in which case this\n function will return the number of root nodes in \\p pNumRootNodes. Otherwise,\n \\p pNumRootNodes entries will be filled in. If \\p pNumRootNodes is higher than the actual\n number of root nodes, the remaining entries in \\p pRootNodes will be set to NULL, and the\n number of nodes actually obtained will be returned in \\p pNumRootNodes.\n\n \\param graph       - Graph to query\n \\param pRootNodes    - Pointer to return the root nodes\n \\param pNumRootNodes - See description\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphCreate,\n ::cudaGraphGetNodes,\n ::cudaGraphGetEdges,\n ::cudaGraphNodeGetType,\n ::cudaGraphNodeGetDependencies,\n ::cudaGraphNodeGetDependentNodes"]
    pub fn cudaGraphGetRootNodes(
        graph: cudaGraph_t,
        pRootNodes: *mut cudaGraphNode_t,
        pNumRootNodes: *mut usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a graph's dependency edges\n\n Returns a list of \\p graph's dependency edges. Edges are returned via corresponding\n indices in \\p from and \\p to; that is, the node in \\p to[i] has a dependency on the\n node in \\p from[i]. \\p from and \\p to may both be NULL, in which\n case this function only returns the number of edges in \\p numEdges. Otherwise,\n \\p numEdges entries will be filled in. If \\p numEdges is higher than the actual\n number of edges, the remaining entries in \\p from and \\p to will be set to NULL, and\n the number of edges actually returned will be written to \\p numEdges.\n\n \\param graph    - Graph to get the edges from\n \\param from     - Location to return edge endpoints\n \\param to       - Location to return edge endpoints\n \\param numEdges - See description\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphGetNodes,\n ::cudaGraphGetRootNodes,\n ::cudaGraphAddDependencies,\n ::cudaGraphRemoveDependencies,\n ::cudaGraphNodeGetDependencies,\n ::cudaGraphNodeGetDependentNodes"]
    pub fn cudaGraphGetEdges(
        graph: cudaGraph_t,
        from: *mut cudaGraphNode_t,
        to: *mut cudaGraphNode_t,
        numEdges: *mut usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a node's dependencies\n\n Returns a list of \\p node's dependencies. \\p pDependencies may be NULL, in which case this\n function will return the number of dependencies in \\p pNumDependencies. Otherwise,\n \\p pNumDependencies entries will be filled in. If \\p pNumDependencies is higher than the actual\n number of dependencies, the remaining entries in \\p pDependencies will be set to NULL, and the\n number of nodes actually obtained will be returned in \\p pNumDependencies.\n\n \\param node           - Node to query\n \\param pDependencies    - Pointer to return the dependencies\n \\param pNumDependencies - See description\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphNodeGetDependentNodes,\n ::cudaGraphGetNodes,\n ::cudaGraphGetRootNodes,\n ::cudaGraphGetEdges,\n ::cudaGraphAddDependencies,\n ::cudaGraphRemoveDependencies"]
    pub fn cudaGraphNodeGetDependencies(
        node: cudaGraphNode_t,
        pDependencies: *mut cudaGraphNode_t,
        pNumDependencies: *mut usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a node's dependent nodes\n\n Returns a list of \\p node's dependent nodes. \\p pDependentNodes may be NULL, in which\n case this function will return the number of dependent nodes in \\p pNumDependentNodes.\n Otherwise, \\p pNumDependentNodes entries will be filled in. If \\p pNumDependentNodes is\n higher than the actual number of dependent nodes, the remaining entries in\n \\p pDependentNodes will be set to NULL, and the number of nodes actually obtained will\n be returned in \\p pNumDependentNodes.\n\n \\param node             - Node to query\n \\param pDependentNodes    - Pointer to return the dependent nodes\n \\param pNumDependentNodes - See description\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphNodeGetDependencies,\n ::cudaGraphGetNodes,\n ::cudaGraphGetRootNodes,\n ::cudaGraphGetEdges,\n ::cudaGraphAddDependencies,\n ::cudaGraphRemoveDependencies"]
    pub fn cudaGraphNodeGetDependentNodes(
        node: cudaGraphNode_t,
        pDependentNodes: *mut cudaGraphNode_t,
        pNumDependentNodes: *mut usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Adds dependency edges to a graph.\n\n The number of dependencies to be added is defined by \\p numDependencies\n Elements in \\p pFrom and \\p pTo at corresponding indices define a dependency.\n Each node in \\p pFrom and \\p pTo must belong to \\p graph.\n\n If \\p numDependencies is 0, elements in \\p pFrom and \\p pTo will be ignored.\n Specifying an existing dependency will return an error.\n\n \\param graph - Graph to which dependencies are added\n \\param from - Array of nodes that provide the dependencies\n \\param to - Array of dependent nodes\n \\param numDependencies - Number of dependencies to be added\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphRemoveDependencies,\n ::cudaGraphGetEdges,\n ::cudaGraphNodeGetDependencies,\n ::cudaGraphNodeGetDependentNodes"]
    pub fn cudaGraphAddDependencies(
        graph: cudaGraph_t,
        from: *const cudaGraphNode_t,
        to: *const cudaGraphNode_t,
        numDependencies: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Removes dependency edges from a graph.\n\n The number of \\p pDependencies to be removed is defined by \\p numDependencies.\n Elements in \\p pFrom and \\p pTo at corresponding indices define a dependency.\n Each node in \\p pFrom and \\p pTo must belong to \\p graph.\n\n If \\p numDependencies is 0, elements in \\p pFrom and \\p pTo will be ignored.\n Specifying a non-existing dependency will return an error.\n\n \\param graph - Graph from which to remove dependencies\n \\param from - Array of nodes that provide the dependencies\n \\param to - Array of dependent nodes\n \\param numDependencies - Number of dependencies to be removed\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphAddDependencies,\n ::cudaGraphGetEdges,\n ::cudaGraphNodeGetDependencies,\n ::cudaGraphNodeGetDependentNodes"]
    pub fn cudaGraphRemoveDependencies(
        graph: cudaGraph_t,
        from: *const cudaGraphNode_t,
        to: *const cudaGraphNode_t,
        numDependencies: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Remove a node from the graph\n\n Removes \\p node from its graph. This operation also severs any dependencies of other nodes\n on \\p node and vice versa.\n\n Dependencies cannot be removed from graphs which contain allocation or free nodes.\n Any attempt to do so will return an error.\n\n \\param node  - Node to remove\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n \\note_destroy_ub\n\n \\sa\n ::cudaGraphAddChildGraphNode,\n ::cudaGraphAddEmptyNode,\n ::cudaGraphAddKernelNode,\n ::cudaGraphAddHostNode,\n ::cudaGraphAddMemcpyNode,\n ::cudaGraphAddMemsetNode"]
    pub fn cudaGraphDestroyNode(node: cudaGraphNode_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Creates an executable graph from a graph\n\n Instantiates \\p graph as an executable graph. The graph is validated for any\n structural constraints or intra-node constraints which were not previously\n validated. If instantiation is successful, a handle to the instantiated graph\n is returned in \\p pGraphExec.\n\n If there are any errors, diagnostic information may be returned in \\p pErrorNode and\n \\p pLogBuffer. This is the primary way to inspect instantiation errors. The output\n will be null terminated unless the diagnostics overflow\n the buffer. In this case, they will be truncated, and the last byte can be\n inspected to determine if truncation occurred.\n\n \\param pGraphExec - Returns instantiated graph\n \\param graph      - Graph to instantiate\n \\param pErrorNode - In case of an instantiation error, this may be modified to\n                      indicate a node contributing to the error\n \\param pLogBuffer   - A character buffer to store diagnostic messages\n \\param bufferSize  - Size of the log buffer in bytes\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphInstantiateWithFlags,\n ::cudaGraphCreate,\n ::cudaGraphUpload,\n ::cudaGraphLaunch,\n ::cudaGraphExecDestroy"]
    pub fn cudaGraphInstantiate(
        pGraphExec: *mut cudaGraphExec_t,
        graph: cudaGraph_t,
        pErrorNode: *mut cudaGraphNode_t,
        pLogBuffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphInstantiateWithFlags(
        pGraphExec: *mut cudaGraphExec_t,
        graph: cudaGraph_t,
        flags: ::std::os::raw::c_ulonglong,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the parameters for a kernel node in the given graphExec\n\n Sets the parameters of a kernel node in an executable graph \\p hGraphExec.\n The node is identified by the corresponding node \\p node in the\n non-executable graph, from which the executable graph was instantiated.\n\n \\p node must not have been removed from the original graph. The \\p func field\n of \\p nodeParams cannot be modified and must match the original value.\n All other values can be modified.\n\n The modifications only affect future launches of \\p hGraphExec. Already\n enqueued or running launches of \\p hGraphExec are not affected by this call.\n \\p node is also not modified by this call.\n\n \\param hGraphExec  - The executable graph in which to set the specified node\n \\param node        - kernel node from the graph from which graphExec was instantiated\n \\param pNodeParams - Updated Parameters to set\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphAddKernelNode,\n ::cudaGraphKernelNodeSetParams,\n ::cudaGraphExecMemcpyNodeSetParams,\n ::cudaGraphExecMemsetNodeSetParams,\n ::cudaGraphExecHostNodeSetParams,\n ::cudaGraphExecChildGraphNodeSetParams,\n ::cudaGraphExecEventRecordNodeSetEvent,\n ::cudaGraphExecEventWaitNodeSetEvent,\n ::cudaGraphExecExternalSemaphoresSignalNodeSetParams,\n ::cudaGraphExecExternalSemaphoresWaitNodeSetParams,\n ::cudaGraphExecUpdate,\n ::cudaGraphInstantiate"]
    pub fn cudaGraphExecKernelNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        pNodeParams: *const cudaKernelNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the parameters for a memcpy node in the given graphExec.\n\n Updates the work represented by \\p node in \\p hGraphExec as though \\p node had\n contained \\p pNodeParams at instantiation.  \\p node must remain in the graph which was\n used to instantiate \\p hGraphExec.  Changed edges to and from \\p node are ignored.\n\n The source and destination memory in \\p pNodeParams must be allocated from the same\n contexts as the original source and destination memory.  Both the instantiation-time\n memory operands and the memory operands in \\p pNodeParams must be 1-dimensional.\n Zero-length operations are not supported.\n\n The modifications only affect future launches of \\p hGraphExec.  Already enqueued\n or running launches of \\p hGraphExec are not affected by this call.  \\p node is also\n not modified by this call.\n\n Returns ::cudaErrorInvalidValue if the memory operands' mappings changed or\n either the original or new memory operands are multidimensional.\n\n \\param hGraphExec  - The executable graph in which to set the specified node\n \\param node        - Memcpy node from the graph which was used to instantiate graphExec\n \\param pNodeParams - Updated Parameters to set\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphAddMemcpyNode,\n ::cudaGraphMemcpyNodeSetParams,\n ::cudaGraphExecMemcpyNodeSetParamsToSymbol,\n ::cudaGraphExecMemcpyNodeSetParamsFromSymbol,\n ::cudaGraphExecMemcpyNodeSetParams1D,\n ::cudaGraphExecKernelNodeSetParams,\n ::cudaGraphExecMemsetNodeSetParams,\n ::cudaGraphExecHostNodeSetParams,\n ::cudaGraphExecChildGraphNodeSetParams,\n ::cudaGraphExecEventRecordNodeSetEvent,\n ::cudaGraphExecEventWaitNodeSetEvent,\n ::cudaGraphExecExternalSemaphoresSignalNodeSetParams,\n ::cudaGraphExecExternalSemaphoresWaitNodeSetParams,\n ::cudaGraphExecUpdate,\n ::cudaGraphInstantiate"]
    pub fn cudaGraphExecMemcpyNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        pNodeParams: *const cudaMemcpy3DParms,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphExecMemcpyNodeSetParamsToSymbol(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphExecMemcpyNodeSetParamsFromSymbol(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphExecMemcpyNodeSetParams1D(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the parameters for a memset node in the given graphExec.\n\n Updates the work represented by \\p node in \\p hGraphExec as though \\p node had\n contained \\p pNodeParams at instantiation.  \\p node must remain in the graph which was\n used to instantiate \\p hGraphExec.  Changed edges to and from \\p node are ignored.\n\n The destination memory in \\p pNodeParams must be allocated from the same\n context as the original destination memory.  Both the instantiation-time\n memory operand and the memory operand in \\p pNodeParams must be 1-dimensional.\n Zero-length operations are not supported.\n\n The modifications only affect future launches of \\p hGraphExec.  Already enqueued\n or running launches of \\p hGraphExec are not affected by this call.  \\p node is also\n not modified by this call.\n\n Returns cudaErrorInvalidValue if the memory operand's mappings changed or\n either the original or new memory operand are multidimensional.\n\n \\param hGraphExec  - The executable graph in which to set the specified node\n \\param node        - Memset node from the graph which was used to instantiate graphExec\n \\param pNodeParams - Updated Parameters to set\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphAddMemsetNode,\n ::cudaGraphMemsetNodeSetParams,\n ::cudaGraphExecKernelNodeSetParams,\n ::cudaGraphExecMemcpyNodeSetParams,\n ::cudaGraphExecHostNodeSetParams,\n ::cudaGraphExecChildGraphNodeSetParams,\n ::cudaGraphExecEventRecordNodeSetEvent,\n ::cudaGraphExecEventWaitNodeSetEvent,\n ::cudaGraphExecExternalSemaphoresSignalNodeSetParams,\n ::cudaGraphExecExternalSemaphoresWaitNodeSetParams,\n ::cudaGraphExecUpdate,\n ::cudaGraphInstantiate"]
    pub fn cudaGraphExecMemsetNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        pNodeParams: *const cudaMemsetParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the parameters for a host node in the given graphExec.\n\n Updates the work represented by \\p node in \\p hGraphExec as though \\p node had\n contained \\p pNodeParams at instantiation.  \\p node must remain in the graph which was\n used to instantiate \\p hGraphExec.  Changed edges to and from \\p node are ignored.\n\n The modifications only affect future launches of \\p hGraphExec.  Already enqueued\n or running launches of \\p hGraphExec are not affected by this call.  \\p node is also\n not modified by this call.\n\n \\param hGraphExec  - The executable graph in which to set the specified node\n \\param node        - Host node from the graph which was used to instantiate graphExec\n \\param pNodeParams - Updated Parameters to set\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphAddHostNode,\n ::cudaGraphHostNodeSetParams,\n ::cudaGraphExecKernelNodeSetParams,\n ::cudaGraphExecMemcpyNodeSetParams,\n ::cudaGraphExecMemsetNodeSetParams,\n ::cudaGraphExecChildGraphNodeSetParams,\n ::cudaGraphExecEventRecordNodeSetEvent,\n ::cudaGraphExecEventWaitNodeSetEvent,\n ::cudaGraphExecExternalSemaphoresSignalNodeSetParams,\n ::cudaGraphExecExternalSemaphoresWaitNodeSetParams,\n ::cudaGraphExecUpdate,\n ::cudaGraphInstantiate"]
    pub fn cudaGraphExecHostNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        pNodeParams: *const cudaHostNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphExecChildGraphNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        childGraph: cudaGraph_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphExecEventRecordNodeSetEvent(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphExecEventWaitNodeSetEvent(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphExecExternalSemaphoresSignalNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        nodeParams: *const cudaExternalSemaphoreSignalNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphExecExternalSemaphoresWaitNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        nodeParams: *const cudaExternalSemaphoreWaitNodeParams,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphNodeSetEnabled(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        isEnabled: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphNodeGetEnabled(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        isEnabled: *mut ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Check whether an executable graph can be updated with a graph and perform the update if possible\n\n Updates the node parameters in the instantiated graph specified by \\p hGraphExec with the\n node parameters in a topologically identical graph specified by \\p hGraph.\n\n Limitations:\n\n - Kernel nodes:\n   - The owning context of the function cannot change.\n   - A node whose function originally did not use CUDA dynamic parallelism cannot be updated\n     to a function which uses CDP.\n   - A cooperative node cannot be updated to a non-cooperative node, and vice-versa.\n   - If the graph was instantiated with cudaGraphInstantiateFlagUseNodePriority, the\n     priority attribute cannot change. Equality is checked on the originally requested\n     priority values, before they are clamped to the device's supported range.\n - Memset and memcpy nodes:\n   - The CUDA device(s) to which the operand(s) was allocated/mapped cannot change.\n   - The source/destination memory must be allocated from the same contexts as the original\n     source/destination memory.\n   - Only 1D memsets can be changed.\n - Additional memcpy node restrictions:\n   - Changing either the source or destination memory type(i.e. CU_MEMORYTYPE_DEVICE,\n     CU_MEMORYTYPE_ARRAY, etc.) is not supported.\n\n Note:  The API may add further restrictions in future releases.  The return code should always be checked.\n\n cudaGraphExecUpdate sets \\p updateResult_out to cudaGraphExecUpdateErrorTopologyChanged under\n the following conditions:\n\n - The count of nodes directly in \\p hGraphExec and \\p hGraph differ, in which case \\p hErrorNode_out\n   is NULL.\n - A node is deleted in \\p hGraph but not not its pair from \\p hGraphExec, in which case \\p hErrorNode_out\n   is NULL.\n - A node is deleted in \\p hGraphExec but not its pair from \\p hGraph, in which case \\p hErrorNode_out is\n   the pairless node from \\p hGraph.\n - The dependent nodes of a pair differ, in which case \\p hErrorNode_out is the node from \\p hGraph.\n\n cudaGraphExecUpdate sets \\p updateResult_out to:\n - cudaGraphExecUpdateError if passed an invalid value.\n - cudaGraphExecUpdateErrorTopologyChanged if the graph topology changed\n - cudaGraphExecUpdateErrorNodeTypeChanged if the type of a node changed, in which case\n   \\p hErrorNode_out is set to the node from \\p hGraph.\n - cudaGraphExecUpdateErrorFunctionChanged if the function of a kernel node changed (CUDA driver < 11.2)\n - cudaGraphExecUpdateErrorUnsupportedFunctionChange if the func field of a kernel changed in an\n   unsupported way(see note above), in which case \\p hErrorNode_out is set to the node from \\p hGraph\n - cudaGraphExecUpdateErrorParametersChanged if any parameters to a node changed in a way\n   that is not supported, in which case \\p hErrorNode_out is set to the node from \\p hGraph\n - cudaGraphExecUpdateErrorAttributesChanged if any attributes of a node changed in a way\n   that is not supported, in which case \\p hErrorNode_out is set to the node from \\p hGraph\n - cudaGraphExecUpdateErrorNotSupported if something about a node is unsupported, like\n   the node's type or configuration, in which case \\p hErrorNode_out is set to the node from \\p hGraph\n\n If \\p updateResult_out isn't set in one of the situations described above, the update check passes\n and cudaGraphExecUpdate updates \\p hGraphExec to match the contents of \\p hGraph.  If an error happens\n during the update, \\p updateResult_out will be set to cudaGraphExecUpdateError; otherwise,\n \\p updateResult_out is set to cudaGraphExecUpdateSuccess.\n\n cudaGraphExecUpdate returns cudaSuccess when the updated was performed successfully.  It returns\n cudaErrorGraphExecUpdateFailure if the graph update was not performed because it included\n changes which violated constraints specific to instantiated graph update.\n\n \\param hGraphExec The instantiated graph to be updated\n \\param hGraph The graph containing the updated parameters\n \\param hErrorNode_out The node which caused the permissibility check to forbid the update, if any\n \\param updateResult_out Whether the graph update was permitted.  If was forbidden, the reason why\n\n \\return\n ::cudaSuccess,\n ::cudaErrorGraphExecUpdateFailure,\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphInstantiate,"]
    pub fn cudaGraphExecUpdate(
        hGraphExec: cudaGraphExec_t,
        hGraph: cudaGraph_t,
        hErrorNode_out: *mut cudaGraphNode_t,
        updateResult_out: *mut cudaGraphExecUpdateResult,
    ) -> cudaError_t;
}
unsafe extern "C" {
    pub fn cudaGraphUpload(graphExec: cudaGraphExec_t, stream: cudaStream_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Launches an executable graph in a stream\n\n Executes \\p graphExec in \\p stream. Only one instance of \\p graphExec may be executing\n at a time. Each launch is ordered behind both any previous work in \\p stream\n and any previous launches of \\p graphExec. To execute a graph concurrently, it must be\n instantiated multiple times into multiple executable graphs.\n\n If any allocations created by \\p graphExec remain unfreed (from a previous launch) and\n \\p graphExec was not instantiated with ::cudaGraphInstantiateFlagAutoFreeOnLaunch,\n the launch will fail with ::cudaErrorInvalidValue.\n\n \\param graphExec - Executable graph to launch\n \\param stream    - Stream in which to launch the graph\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cudaGraphInstantiate,\n ::cudaGraphUpload,\n ::cudaGraphExecDestroy"]
    pub fn cudaGraphLaunch(graphExec: cudaGraphExec_t, stream: cudaStream_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Destroys an executable graph\n\n Destroys the executable graph specified by \\p graphExec.\n\n \\param graphExec - Executable graph to destroy\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n \\note_destroy_ub\n\n \\sa\n ::cudaGraphInstantiate,\n ::cudaGraphUpload,\n ::cudaGraphLaunch"]
    pub fn cudaGraphExecDestroy(graphExec: cudaGraphExec_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Destroys a graph\n\n Destroys the graph specified by \\p graph, as well as all of its nodes.\n\n \\param graph - Graph to destroy\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n \\note_graph_thread_safety\n \\notefnerr\n \\note_init_rt\n \\note_callback\n \\note_destroy_ub\n\n \\sa\n ::cudaGraphCreate"]
    pub fn cudaGraphDestroy(graph: cudaGraph_t) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Write a DOT file describing graph structure\n\n Using the provided \\p graph, write to \\p path a DOT formatted description of the graph.\n By default this includes the graph topology, node types, node id, kernel names and memcpy direction.\n \\p flags can be specified to write more detailed information about each node type such as\n parameter values, kernel attributes, node and function handles.\n\n \\param graph - The graph to create a DOT file from\n \\param path  - The path to write the DOT file to\n \\param flags - Flags from cudaGraphDebugDotFlags for specifying which additional node information to write\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorOperatingSystem"]
    pub fn cudaGraphDebugDotPrint(
        graph: cudaGraph_t,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Create a user object\n\n Create a user object with the specified destructor callback and initial reference count. The\n initial references are owned by the caller.\n\n Destructor callbacks cannot make CUDA API calls and should avoid blocking behavior, as they\n are executed by a shared internal thread. Another thread may be signaled to perform such\n actions, if it does not block forward progress of tasks scheduled through CUDA.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n\n \\param object_out      - Location to return the user object handle\n \\param ptr             - The pointer to pass to the destroy function\n \\param destroy         - Callback to free the user object when it is no longer in use\n \\param initialRefcount - The initial refcount to create the object with, typically 1. The\n                          initial references are owned by the calling thread.\n \\param flags           - Currently it is required to pass ::cudaUserObjectNoDestructorSync,\n                          which is the only defined flag. This indicates that the destroy\n                          callback cannot be waited on by any CUDA API. Users requiring\n                          synchronization of the callback should signal its completion\n                          manually.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n\n \\sa\n ::cudaUserObjectRetain,\n ::cudaUserObjectRelease,\n ::cudaGraphRetainUserObject,\n ::cudaGraphReleaseUserObject,\n ::cudaGraphCreate"]
    pub fn cudaUserObjectCreate(
        object_out: *mut cudaUserObject_t,
        ptr: *mut ::std::os::raw::c_void,
        destroy: cudaHostFn_t,
        initialRefcount: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Retain a reference to a user object\n\n Retains new references to a user object. The new references are owned by the caller.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n\n \\param object - The object to retain\n \\param count  - The number of references to retain, typically 1. Must be nonzero\n                 and not larger than INT_MAX.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n\n \\sa\n ::cudaUserObjectCreate,\n ::cudaUserObjectRelease,\n ::cudaGraphRetainUserObject,\n ::cudaGraphReleaseUserObject,\n ::cudaGraphCreate"]
    pub fn cudaUserObjectRetain(
        object: cudaUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Release a reference to a user object\n\n Releases user object references owned by the caller. The object's destructor is invoked if\n the reference count reaches zero.\n\n It is undefined behavior to release references not owned by the caller, or to use a user\n object handle after all references are released.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n\n \\param object - The object to release\n \\param count  - The number of references to release, typically 1. Must be nonzero\n                 and not larger than INT_MAX.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n\n \\sa\n ::cudaUserObjectCreate,\n ::cudaUserObjectRetain,\n ::cudaGraphRetainUserObject,\n ::cudaGraphReleaseUserObject,\n ::cudaGraphCreate"]
    pub fn cudaUserObjectRelease(
        object: cudaUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Retain a reference to a user object from a graph\n\n Creates or moves user object references that will be owned by a CUDA graph.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n\n \\param graph  - The graph to associate the reference with\n \\param object - The user object to retain a reference for\n \\param count  - The number of references to add to the graph, typically 1. Must be\n                 nonzero and not larger than INT_MAX.\n \\param flags  - The optional flag ::cudaGraphUserObjectMove transfers references\n                 from the calling thread, rather than create new references. Pass 0\n                 to create new references.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n\n \\sa\n ::cudaUserObjectCreate\n ::cudaUserObjectRetain,\n ::cudaUserObjectRelease,\n ::cudaGraphReleaseUserObject,\n ::cudaGraphCreate"]
    pub fn cudaGraphRetainUserObject(
        graph: cudaGraph_t,
        object: cudaUserObject_t,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Release a user object reference from a graph\n\n Releases user object references owned by a graph.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n\n \\param graph  - The graph that will release the reference\n \\param object - The user object to release a reference for\n \\param count  - The number of references to release, typically 1. Must be nonzero\n                 and not larger than INT_MAX.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue\n\n \\sa\n ::cudaUserObjectCreate\n ::cudaUserObjectRetain,\n ::cudaUserObjectRelease,\n ::cudaGraphRetainUserObject,\n ::cudaGraphCreate"]
    pub fn cudaGraphReleaseUserObject(
        graph: cudaGraph_t,
        object: cudaUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the requested driver API function pointer\n\n Returns in \\p **funcPtr the address of the CUDA driver function for the requested flags.\n\n For a requested driver symbol, if the CUDA version in which the driver symbol was\n introduced is less than or equal to the CUDA runtime version, the API will return\n the function pointer to the corresponding versioned driver function.\n\n The pointer returned by the API should be cast to a function pointer matching the\n requested driver function's definition in the API header file. The function pointer\n typedef can be picked up from the corresponding typedefs header file. For example,\n cudaTypedefs.h consists of function pointer typedefs for driver APIs defined in cuda.h.\n\n The API will return ::cudaErrorSymbolNotFound if the requested driver function is not\n supported on the platform, no ABI compatible driver function exists for the CUDA runtime\n version or if the driver symbol is invalid.\n\n The requested flags can be:\n - ::cudaEnableDefault: This is the default mode. This is equivalent to\n   ::cudaEnablePerThreadDefaultStream if the code is compiled with\n   --default-stream per-thread compilation flag or the macro CUDA_API_PER_THREAD_DEFAULT_STREAM\n   is defined; ::cudaEnableLegacyStream otherwise.\n - ::cudaEnableLegacyStream: This will enable the search for all driver symbols\n   that match the requested driver symbol name except the corresponding per-thread versions.\n - ::cudaEnablePerThreadDefaultStream: This will enable the search for all\n   driver symbols that match the requested driver symbol name including the per-thread\n   versions. If a per-thread version is not found, the API will return the legacy version\n   of the driver function.\n\n \\param symbol - The base name of the driver API function to look for. As an example,\n                 for the driver API ::cuMemAlloc_v2, \\p symbol would be cuMemAlloc.\n                 Note that the API will use the CUDA runtime version to return the\n                 address to the most recent ABI compatible driver symbol, ::cuMemAlloc\n                 or ::cuMemAlloc_v2.\n \\param funcPtr - Location to return the function pointer to the requested driver function\n \\param flags -  Flags to specify search options.\n\n \\return\n ::cudaSuccess,\n ::cudaErrorInvalidValue,\n ::cudaErrorNotSupported,\n ::cudaErrorSymbolNotFound\n \\note_version_mixing\n \\note_init_rt\n \\note_callback\n\n \\sa\n ::cuGetProcAddress"]
    pub fn cudaGetDriverEntryPoint(
        symbol: *const ::std::os::raw::c_char,
        funcPtr: *mut *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_ulonglong,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\cond impl_private"]
    pub fn cudaGetExportTable(
        ppExportTable: *mut *const ::std::os::raw::c_void,
        pExportTableId: *const cudaUUID_t,
    ) -> cudaError_t;
}
unsafe extern "C" {
    #[doc = " \\brief Get pointer to device entry function that matches entry function \\p symbolPtr\n\n Returns in \\p functionPtr the device entry function corresponding to the symbol \\p symbolPtr.\n\n \\param functionPtr     - Returns the device entry function\n \\param symbolPtr       - Pointer to device entry function to search for\n\n \\return\n ::cudaSuccess\n"]
    pub fn cudaGetFuncBySymbol(
        functionPtr: *mut cudaFunction_t,
        symbolPtr: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cusolverDnContext {
    _unused: [u8; 0],
}
pub type cusolverDnHandle_t = *mut cusolverDnContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct syevjInfo {
    _unused: [u8; 0],
}
pub type syevjInfo_t = *mut syevjInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gesvdjInfo {
    _unused: [u8; 0],
}
pub type gesvdjInfo_t = *mut gesvdjInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cusolverDnIRSParams {
    _unused: [u8; 0],
}
pub type cusolverDnIRSParams_t = *mut cusolverDnIRSParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cusolverDnIRSInfos {
    _unused: [u8; 0],
}
pub type cusolverDnIRSInfos_t = *mut cusolverDnIRSInfos;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cusolverDnParams {
    _unused: [u8; 0],
}
pub type cusolverDnParams_t = *mut cusolverDnParams;
pub const cusolverDnFunction_t_CUSOLVERDN_GETRF: cusolverDnFunction_t = 0;
pub const cusolverDnFunction_t_CUSOLVERDN_POTRF: cusolverDnFunction_t = 1;
pub type cusolverDnFunction_t = ::std::os::raw::c_int;
pub type __crt_bool = bool;
unsafe extern "C" {
    pub fn _invalid_parameter_noinfo();
}
unsafe extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
unsafe extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __crt_locale_data_public"]
        [::std::mem::size_of::<__crt_locale_data_public>() - 16usize];
    ["Alignment of __crt_locale_data_public"]
        [::std::mem::align_of::<__crt_locale_data_public>() - 8usize];
    ["Offset of field: __crt_locale_data_public::_locale_pctype"]
        [::std::mem::offset_of!(__crt_locale_data_public, _locale_pctype) - 0usize];
    ["Offset of field: __crt_locale_data_public::_locale_mb_cur_max"]
        [::std::mem::offset_of!(__crt_locale_data_public, _locale_mb_cur_max) - 8usize];
    ["Offset of field: __crt_locale_data_public::_locale_lc_codepage"]
        [::std::mem::offset_of!(__crt_locale_data_public, _locale_lc_codepage) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __crt_locale_pointers"][::std::mem::size_of::<__crt_locale_pointers>() - 16usize];
    ["Alignment of __crt_locale_pointers"]
        [::std::mem::align_of::<__crt_locale_pointers>() - 8usize];
    ["Offset of field: __crt_locale_pointers::locinfo"]
        [::std::mem::offset_of!(__crt_locale_pointers, locinfo) - 0usize];
    ["Offset of field: __crt_locale_pointers::mbcinfo"]
        [::std::mem::offset_of!(__crt_locale_pointers, mbcinfo) - 8usize];
};
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Mbstatet"][::std::mem::size_of::<_Mbstatet>() - 8usize];
    ["Alignment of _Mbstatet"][::std::mem::align_of::<_Mbstatet>() - 4usize];
    ["Offset of field: _Mbstatet::_Wchar"][::std::mem::offset_of!(_Mbstatet, _Wchar) - 0usize];
    ["Offset of field: _Mbstatet::_Byte"][::std::mem::offset_of!(_Mbstatet, _Byte) - 4usize];
    ["Offset of field: _Mbstatet::_State"][::std::mem::offset_of!(_Mbstatet, _State) - 6usize];
};
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _iobuf"][::std::mem::size_of::<_iobuf>() - 8usize];
    ["Alignment of _iobuf"][::std::mem::align_of::<_iobuf>() - 8usize];
    ["Offset of field: _iobuf::_Placeholder"]
        [::std::mem::offset_of!(_iobuf, _Placeholder) - 0usize];
};
pub type FILE = _iobuf;
unsafe extern "C" {
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
unsafe extern "C" {
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn _fputwchar(_Character: wchar_t) -> wint_t;
}
unsafe extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwchar() -> wint_t;
}
unsafe extern "C" {
    pub fn fgetws(
        _Buffer: *mut wchar_t,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwchar(_Character: wchar_t) -> wint_t;
}
unsafe extern "C" {
    pub fn _putws(_Buffer: *const wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const wchar_t) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _wfopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _wfreopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _wfsopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
unsafe extern "C" {
    pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _wremove(_FileName: *const wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> errno_t;
}
unsafe extern "C" {
    pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
unsafe extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
unsafe extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
unsafe extern "C" {
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
unsafe extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(_ErrorMessage: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
unsafe extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
unsafe extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
unsafe extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _exception"][::std::mem::size_of::<_exception>() - 40usize];
    ["Alignment of _exception"][::std::mem::align_of::<_exception>() - 8usize];
    ["Offset of field: _exception::type_"][::std::mem::offset_of!(_exception, type_) - 0usize];
    ["Offset of field: _exception::name"][::std::mem::offset_of!(_exception, name) - 8usize];
    ["Offset of field: _exception::arg1"][::std::mem::offset_of!(_exception, arg1) - 16usize];
    ["Offset of field: _exception::arg2"][::std::mem::offset_of!(_exception, arg2) - 24usize];
    ["Offset of field: _exception::retval"][::std::mem::offset_of!(_exception, retval) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _complex {
    pub x: f64,
    pub y: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _complex"][::std::mem::size_of::<_complex>() - 16usize];
    ["Alignment of _complex"][::std::mem::align_of::<_complex>() - 8usize];
    ["Offset of field: _complex::x"][::std::mem::offset_of!(_complex, x) - 0usize];
    ["Offset of field: _complex::y"][::std::mem::offset_of!(_complex, y) - 8usize];
};
pub type float_t = f32;
pub type double_t = f64;
unsafe extern "C" {
    pub static _HUGE: f64;
}
unsafe extern "C" {
    pub fn _fperrraise(_Except: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn _dclass(_X: f64) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _ldclass(_X: f64) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _fdclass(_X: f32) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _dsign(_X: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _ldsign(_X: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fdsign(_X: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _dpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _ldpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fdpcomp(_X: f32, _Y: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _dtest(_Px: *mut f64) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _ldtest(_Px: *mut f64) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _fdtest(_Px: *mut f32) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _d_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _ld_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _fd_int(_Px: *mut f32, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _dscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _ldscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _fdscale(_Px: *mut f32, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _dunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _ldunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64)
                      -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _fdunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f32)
                      -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _dexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _ldexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long)
                  -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _fdexp(_Px: *mut f32, _Y: f32, _Eoff: ::std::os::raw::c_long)
                  -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _dnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _fdnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    pub fn _dpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn _ldpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn _fdpoly(_X: f32, _Tab: *const f32, _N: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn _dlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn _ldlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn _fdlog(_X: f32, _Baseflag: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn _dsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
}
unsafe extern "C" {
    pub fn _ldsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
}
unsafe extern "C" {
    pub fn _fdsin(_X: f32, _Qoff: ::std::os::raw::c_uint) -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _double_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _double_val"][::std::mem::size_of::<_double_val>() - 8usize];
    ["Alignment of _double_val"][::std::mem::align_of::<_double_val>() - 8usize];
    ["Offset of field: _double_val::_Sh"][::std::mem::offset_of!(_double_val, _Sh) - 0usize];
    ["Offset of field: _double_val::_Val"][::std::mem::offset_of!(_double_val, _Val) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_val {
    pub _Sh: [::std::os::raw::c_ushort; 2usize],
    pub _Val: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _float_val"][::std::mem::size_of::<_float_val>() - 4usize];
    ["Alignment of _float_val"][::std::mem::align_of::<_float_val>() - 4usize];
    ["Offset of field: _float_val::_Sh"][::std::mem::offset_of!(_float_val, _Sh) - 0usize];
    ["Offset of field: _float_val::_Val"][::std::mem::offset_of!(_float_val, _Val) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ldouble_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ldouble_val"][::std::mem::size_of::<_ldouble_val>() - 8usize];
    ["Alignment of _ldouble_val"][::std::mem::align_of::<_ldouble_val>() - 8usize];
    ["Offset of field: _ldouble_val::_Sh"][::std::mem::offset_of!(_ldouble_val, _Sh) - 0usize];
    ["Offset of field: _ldouble_val::_Val"][::std::mem::offset_of!(_ldouble_val, _Val) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_const {
    pub _Word: [::std::os::raw::c_ushort; 4usize],
    pub _Float: f32,
    pub _Double: f64,
    pub _Long_double: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _float_const"][::std::mem::size_of::<_float_const>() - 8usize];
    ["Alignment of _float_const"][::std::mem::align_of::<_float_const>() - 8usize];
    ["Offset of field: _float_const::_Word"][::std::mem::offset_of!(_float_const, _Word) - 0usize];
    ["Offset of field: _float_const::_Float"]
        [::std::mem::offset_of!(_float_const, _Float) - 0usize];
    ["Offset of field: _float_const::_Double"]
        [::std::mem::offset_of!(_float_const, _Double) - 0usize];
    ["Offset of field: _float_const::_Long_double"]
        [::std::mem::offset_of!(_float_const, _Long_double) - 0usize];
};
unsafe extern "C" {
    pub static _Denorm_C: _float_const;
}
unsafe extern "C" {
    pub static _Inf_C: _float_const;
}
unsafe extern "C" {
    pub static _Nan_C: _float_const;
}
unsafe extern "C" {
    pub static _Snan_C: _float_const;
}
unsafe extern "C" {
    pub static _Hugeval_C: _float_const;
}
unsafe extern "C" {
    pub static _FDenorm_C: _float_const;
}
unsafe extern "C" {
    pub static _FInf_C: _float_const;
}
unsafe extern "C" {
    pub static _FNan_C: _float_const;
}
unsafe extern "C" {
    pub static _FSnan_C: _float_const;
}
unsafe extern "C" {
    pub static _LDenorm_C: _float_const;
}
unsafe extern "C" {
    pub static _LInf_C: _float_const;
}
unsafe extern "C" {
    pub static _LNan_C: _float_const;
}
unsafe extern "C" {
    pub static _LSnan_C: _float_const;
}
unsafe extern "C" {
    pub static _Eps_C: _float_const;
}
unsafe extern "C" {
    pub static _Rteps_C: _float_const;
}
unsafe extern "C" {
    pub static _FEps_C: _float_const;
}
unsafe extern "C" {
    pub static _FRteps_C: _float_const;
}
unsafe extern "C" {
    pub static _LEps_C: _float_const;
}
unsafe extern "C" {
    pub static _LRteps_C: _float_const;
}
unsafe extern "C" {
    pub static _Zero_C: f64;
}
unsafe extern "C" {
    pub static _Xbig_C: f64;
}
unsafe extern "C" {
    pub static _FZero_C: f32;
}
unsafe extern "C" {
    pub static _FXbig_C: f32;
}
unsafe extern "C" {
    pub static _LZero_C: f64;
}
unsafe extern "C" {
    pub static _LXbig_C: f64;
}
unsafe extern "C" {
    pub fn abs(_X: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(_X: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(_X: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn acos(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn asin(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2(_Y: f64, _X: f64) -> f64;
}
unsafe extern "C" {
    pub fn cos(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosh(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn fabs(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmod(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn log(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn pow(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn sin(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinh(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrt(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn tan(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanh(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn acosh(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinh(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanh(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
unsafe extern "C" {
    pub fn _cabs(_Complex_value: _complex) -> f64;
}
unsafe extern "C" {
    pub fn cbrt(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceil(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn _chgsign(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn copysign(_Number: f64, _Sign: f64) -> f64;
}
unsafe extern "C" {
    pub fn _copysign(_Number: f64, _Sign: f64) -> f64;
}
unsafe extern "C" {
    pub fn erf(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfc(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn fdim(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn floor(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn fma(_X: f64, _Y: f64, _Z: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmax(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmin(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn frexp(_X: f64, _Y: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn hypot(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn _hypot(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn ilogb(_X: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ldexp(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn lgamma(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn llrint(_X: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llround(_X: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn log1p(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn logb(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn lrint(_X: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lround(_X: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn _matherr(_Except: *mut _exception) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn modf(_X: f64, _Y: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn nan(_X: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn nearbyint(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextafter(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttoward(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn remainder(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn remquo(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn rint(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn round(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalbln(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn scalbn(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn tgamma(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn trunc(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn _j0(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn _j1(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn _jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn _y0(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn _y1(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn _yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn acoshf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinhf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanhf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn cbrtf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn _chgsignf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn copysignf(_Number: f32, _Sign: f32) -> f32;
}
unsafe extern "C" {
    pub fn _copysignf(_Number: f32, _Sign: f32) -> f32;
}
unsafe extern "C" {
    pub fn erff(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn erfcf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn expm1f(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp2f(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn fdimf(_X: f32, _Y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaf(_X: f32, _Y: f32, _Z: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaxf(_X: f32, _Y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminf(_X: f32, _Y: f32) -> f32;
}
unsafe extern "C" {
    pub fn _hypotf(_X: f32, _Y: f32) -> f32;
}
unsafe extern "C" {
    pub fn ilogbf(_X: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lgammaf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn llrintf(_X: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llroundf(_X: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn log1pf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn log2f(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn logbf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn lrintf(_X: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lroundf(_X: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nanf(_X: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn nearbyintf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextafterf(_X: f32, _Y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nexttowardf(_X: f32, _Y: f64) -> f32;
}
unsafe extern "C" {
    pub fn remainderf(_X: f32, _Y: f32) -> f32;
}
unsafe extern "C" {
    pub fn remquof(_X: f32, _Y: f32, _Z: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn rintf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn roundf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalblnf(_X: f32, _Y: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn scalbnf(_X: f32, _Y: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn tgammaf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn truncf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn _logbf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn _nextafterf(_X: f32, _Y: f32) -> f32;
}
unsafe extern "C" {
    pub fn _finitef(_X: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _isnanf(_X: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fpclassf(_X: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _set_FMA3_enable(_Flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _get_FMA3_enable() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan2f(_Y: f32, _X: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn ceilf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn cosf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn coshf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn expf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn floorf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmodf(_X: f32, _Y: f32) -> f32;
}
unsafe extern "C" {
    pub fn log10f(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn logf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn modff(_X: f32, _Y: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn powf(_X: f32, _Y: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinhf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn sqrtf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanhf(_X: f32) -> f32;
}
unsafe extern "C" {
    pub fn acoshl(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinhl(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanhl(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrtl(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn copysignl(_Number: f64, _Sign: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfl(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfcl(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2l(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1l(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn fdiml(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmal(_X: f64, _Y: f64, _Z: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaxl(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminl(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn ilogbl(_X: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lgammal(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn llrintl(_X: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llroundl(_X: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn log1pl(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2l(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn logbl(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn lrintl(_X: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lroundl(_X: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nanl(_X: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn nearbyintl(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextafterl(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttowardl(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn remainderl(_X: f64, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn remquol(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn rintl(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn roundl(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalblnl(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn scalbnl(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn tgammal(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn truncl(_X: f64) -> f64;
}
unsafe extern "C" {
    pub static mut HUGE: f64;
}
unsafe extern "C" {
    pub fn j0(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn j1(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
unsafe extern "C" {
    pub fn y0(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn y1(_X: f64) -> f64;
}
unsafe extern "C" {
    pub fn yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
pub type cuFloatComplex = float2;
pub type cuDoubleComplex = double2;
pub type cuComplex = cuFloatComplex;
#[doc = " Types which allow static initialization of \"half\" and \"half2\" until\n these become an actual builtin. Note this initialization is as a\n bitfield representation of \"half\", and not a conversion from short->half.\n Such a representation will be deprecated in a future version of CUDA.\n (Note these are visible to non-nvcc compilers, including C-only compilation)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __half_raw {
    pub x: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __half_raw"][::std::mem::size_of::<__half_raw>() - 2usize];
    ["Alignment of __half_raw"][::std::mem::align_of::<__half_raw>() - 2usize];
    ["Offset of field: __half_raw::x"][::std::mem::offset_of!(__half_raw, x) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __half2_raw {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __half2_raw"][::std::mem::size_of::<__half2_raw>() - 4usize];
    ["Alignment of __half2_raw"][::std::mem::align_of::<__half2_raw>() - 4usize];
    ["Offset of field: __half2_raw::x"][::std::mem::offset_of!(__half2_raw, x) - 0usize];
    ["Offset of field: __half2_raw::y"][::std::mem::offset_of!(__half2_raw, y) - 2usize];
};
#[doc = " Types which allow static initialization of \"nv_bfloat16\" and \"nv_bfloat162\" until\n these become an actual builtin. Note this initialization is as a\n bitfield representation of \"nv_bfloat16\", and not a conversion from short->nv_bfloat16.\n Such a representation will be deprecated in a future version of CUDA.\n (Note these are visible to non-nvcc compilers, including C-only compilation)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __nv_bfloat16_raw {
    pub x: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __nv_bfloat16_raw"][::std::mem::size_of::<__nv_bfloat16_raw>() - 2usize];
    ["Alignment of __nv_bfloat16_raw"][::std::mem::align_of::<__nv_bfloat16_raw>() - 2usize];
    ["Offset of field: __nv_bfloat16_raw::x"]
        [::std::mem::offset_of!(__nv_bfloat16_raw, x) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __nv_bfloat162_raw {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __nv_bfloat162_raw"][::std::mem::size_of::<__nv_bfloat162_raw>() - 4usize];
    ["Alignment of __nv_bfloat162_raw"][::std::mem::align_of::<__nv_bfloat162_raw>() - 4usize];
    ["Offset of field: __nv_bfloat162_raw::x"]
        [::std::mem::offset_of!(__nv_bfloat162_raw, x) - 0usize];
    ["Offset of field: __nv_bfloat162_raw::y"]
        [::std::mem::offset_of!(__nv_bfloat162_raw, y) - 2usize];
};
pub const cudaDataType_t_CUDA_R_16F: cudaDataType_t = 2;
pub const cudaDataType_t_CUDA_C_16F: cudaDataType_t = 6;
pub const cudaDataType_t_CUDA_R_16BF: cudaDataType_t = 14;
pub const cudaDataType_t_CUDA_C_16BF: cudaDataType_t = 15;
pub const cudaDataType_t_CUDA_R_32F: cudaDataType_t = 0;
pub const cudaDataType_t_CUDA_C_32F: cudaDataType_t = 4;
pub const cudaDataType_t_CUDA_R_64F: cudaDataType_t = 1;
pub const cudaDataType_t_CUDA_C_64F: cudaDataType_t = 5;
pub const cudaDataType_t_CUDA_R_4I: cudaDataType_t = 16;
pub const cudaDataType_t_CUDA_C_4I: cudaDataType_t = 17;
pub const cudaDataType_t_CUDA_R_4U: cudaDataType_t = 18;
pub const cudaDataType_t_CUDA_C_4U: cudaDataType_t = 19;
pub const cudaDataType_t_CUDA_R_8I: cudaDataType_t = 3;
pub const cudaDataType_t_CUDA_C_8I: cudaDataType_t = 7;
pub const cudaDataType_t_CUDA_R_8U: cudaDataType_t = 8;
pub const cudaDataType_t_CUDA_C_8U: cudaDataType_t = 9;
pub const cudaDataType_t_CUDA_R_16I: cudaDataType_t = 20;
pub const cudaDataType_t_CUDA_C_16I: cudaDataType_t = 21;
pub const cudaDataType_t_CUDA_R_16U: cudaDataType_t = 22;
pub const cudaDataType_t_CUDA_C_16U: cudaDataType_t = 23;
pub const cudaDataType_t_CUDA_R_32I: cudaDataType_t = 10;
pub const cudaDataType_t_CUDA_C_32I: cudaDataType_t = 11;
pub const cudaDataType_t_CUDA_R_32U: cudaDataType_t = 12;
pub const cudaDataType_t_CUDA_C_32U: cudaDataType_t = 13;
pub const cudaDataType_t_CUDA_R_64I: cudaDataType_t = 24;
pub const cudaDataType_t_CUDA_C_64I: cudaDataType_t = 25;
pub const cudaDataType_t_CUDA_R_64U: cudaDataType_t = 26;
pub const cudaDataType_t_CUDA_C_64U: cudaDataType_t = 27;
pub const cudaDataType_t_CUDA_R_8F_E4M3: cudaDataType_t = 28;
pub const cudaDataType_t_CUDA_R_8F_E5M2: cudaDataType_t = 29;
pub type cudaDataType_t = ::std::os::raw::c_int;
pub use self::cudaDataType_t as cudaDataType;
pub const libraryPropertyType_t_MAJOR_VERSION: libraryPropertyType_t = 0;
pub const libraryPropertyType_t_MINOR_VERSION: libraryPropertyType_t = 1;
pub const libraryPropertyType_t_PATCH_LEVEL: libraryPropertyType_t = 2;
pub type libraryPropertyType_t = ::std::os::raw::c_int;
pub use self::libraryPropertyType_t as libraryPropertyType;
pub const cublasStatus_t_CUBLAS_STATUS_SUCCESS: cublasStatus_t = 0;
pub const cublasStatus_t_CUBLAS_STATUS_NOT_INITIALIZED: cublasStatus_t = 1;
pub const cublasStatus_t_CUBLAS_STATUS_ALLOC_FAILED: cublasStatus_t = 3;
pub const cublasStatus_t_CUBLAS_STATUS_INVALID_VALUE: cublasStatus_t = 7;
pub const cublasStatus_t_CUBLAS_STATUS_ARCH_MISMATCH: cublasStatus_t = 8;
pub const cublasStatus_t_CUBLAS_STATUS_MAPPING_ERROR: cublasStatus_t = 11;
pub const cublasStatus_t_CUBLAS_STATUS_EXECUTION_FAILED: cublasStatus_t = 13;
pub const cublasStatus_t_CUBLAS_STATUS_INTERNAL_ERROR: cublasStatus_t = 14;
pub const cublasStatus_t_CUBLAS_STATUS_NOT_SUPPORTED: cublasStatus_t = 15;
pub const cublasStatus_t_CUBLAS_STATUS_LICENSE_ERROR: cublasStatus_t = 16;
pub type cublasStatus_t = ::std::os::raw::c_int;
pub const cublasFillMode_t_CUBLAS_FILL_MODE_LOWER: cublasFillMode_t = 0;
pub const cublasFillMode_t_CUBLAS_FILL_MODE_UPPER: cublasFillMode_t = 1;
pub const cublasFillMode_t_CUBLAS_FILL_MODE_FULL: cublasFillMode_t = 2;
pub type cublasFillMode_t = ::std::os::raw::c_int;
pub const cublasDiagType_t_CUBLAS_DIAG_NON_UNIT: cublasDiagType_t = 0;
pub const cublasDiagType_t_CUBLAS_DIAG_UNIT: cublasDiagType_t = 1;
pub type cublasDiagType_t = ::std::os::raw::c_int;
pub const cublasSideMode_t_CUBLAS_SIDE_LEFT: cublasSideMode_t = 0;
pub const cublasSideMode_t_CUBLAS_SIDE_RIGHT: cublasSideMode_t = 1;
pub type cublasSideMode_t = ::std::os::raw::c_int;
pub const cublasOperation_t_CUBLAS_OP_N: cublasOperation_t = 0;
pub const cublasOperation_t_CUBLAS_OP_T: cublasOperation_t = 1;
pub const cublasOperation_t_CUBLAS_OP_C: cublasOperation_t = 2;
pub const cublasOperation_t_CUBLAS_OP_HERMITAN: cublasOperation_t = 2;
pub const cublasOperation_t_CUBLAS_OP_CONJG: cublasOperation_t = 3;
pub type cublasOperation_t = ::std::os::raw::c_int;
pub const cublasPointerMode_t_CUBLAS_POINTER_MODE_HOST: cublasPointerMode_t = 0;
pub const cublasPointerMode_t_CUBLAS_POINTER_MODE_DEVICE: cublasPointerMode_t = 1;
pub type cublasPointerMode_t = ::std::os::raw::c_int;
pub const cublasAtomicsMode_t_CUBLAS_ATOMICS_NOT_ALLOWED: cublasAtomicsMode_t = 0;
pub const cublasAtomicsMode_t_CUBLAS_ATOMICS_ALLOWED: cublasAtomicsMode_t = 1;
pub type cublasAtomicsMode_t = ::std::os::raw::c_int;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_DFALT: cublasGemmAlgo_t = -1;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_DEFAULT: cublasGemmAlgo_t = -1;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO0: cublasGemmAlgo_t = 0;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO1: cublasGemmAlgo_t = 1;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO2: cublasGemmAlgo_t = 2;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO3: cublasGemmAlgo_t = 3;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO4: cublasGemmAlgo_t = 4;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO5: cublasGemmAlgo_t = 5;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO6: cublasGemmAlgo_t = 6;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO7: cublasGemmAlgo_t = 7;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO8: cublasGemmAlgo_t = 8;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO9: cublasGemmAlgo_t = 9;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO10: cublasGemmAlgo_t = 10;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO11: cublasGemmAlgo_t = 11;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO12: cublasGemmAlgo_t = 12;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO13: cublasGemmAlgo_t = 13;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO14: cublasGemmAlgo_t = 14;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO15: cublasGemmAlgo_t = 15;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO16: cublasGemmAlgo_t = 16;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO17: cublasGemmAlgo_t = 17;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO18: cublasGemmAlgo_t = 18;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO19: cublasGemmAlgo_t = 19;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO20: cublasGemmAlgo_t = 20;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO21: cublasGemmAlgo_t = 21;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO22: cublasGemmAlgo_t = 22;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO23: cublasGemmAlgo_t = 23;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_DEFAULT_TENSOR_OP: cublasGemmAlgo_t = 99;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_DFALT_TENSOR_OP: cublasGemmAlgo_t = 99;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO0_TENSOR_OP: cublasGemmAlgo_t = 100;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO1_TENSOR_OP: cublasGemmAlgo_t = 101;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO2_TENSOR_OP: cublasGemmAlgo_t = 102;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO3_TENSOR_OP: cublasGemmAlgo_t = 103;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO4_TENSOR_OP: cublasGemmAlgo_t = 104;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO5_TENSOR_OP: cublasGemmAlgo_t = 105;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO6_TENSOR_OP: cublasGemmAlgo_t = 106;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO7_TENSOR_OP: cublasGemmAlgo_t = 107;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO8_TENSOR_OP: cublasGemmAlgo_t = 108;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO9_TENSOR_OP: cublasGemmAlgo_t = 109;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO10_TENSOR_OP: cublasGemmAlgo_t = 110;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO11_TENSOR_OP: cublasGemmAlgo_t = 111;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO12_TENSOR_OP: cublasGemmAlgo_t = 112;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO13_TENSOR_OP: cublasGemmAlgo_t = 113;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO14_TENSOR_OP: cublasGemmAlgo_t = 114;
pub const cublasGemmAlgo_t_CUBLAS_GEMM_ALGO15_TENSOR_OP: cublasGemmAlgo_t = 115;
pub type cublasGemmAlgo_t = ::std::os::raw::c_int;
pub const cublasMath_t_CUBLAS_DEFAULT_MATH: cublasMath_t = 0;
pub const cublasMath_t_CUBLAS_TENSOR_OP_MATH: cublasMath_t = 1;
pub const cublasMath_t_CUBLAS_PEDANTIC_MATH: cublasMath_t = 2;
pub const cublasMath_t_CUBLAS_TF32_TENSOR_OP_MATH: cublasMath_t = 3;
pub const cublasMath_t_CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION: cublasMath_t = 16;
pub type cublasMath_t = ::std::os::raw::c_int;
pub use self::cudaDataType as cublasDataType_t;
pub const cublasComputeType_t_CUBLAS_COMPUTE_16F: cublasComputeType_t = 64;
pub const cublasComputeType_t_CUBLAS_COMPUTE_16F_PEDANTIC: cublasComputeType_t = 65;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32F: cublasComputeType_t = 68;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32F_PEDANTIC: cublasComputeType_t = 69;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32F_FAST_16F: cublasComputeType_t = 74;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32F_FAST_16BF: cublasComputeType_t = 75;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32F_FAST_TF32: cublasComputeType_t = 77;
pub const cublasComputeType_t_CUBLAS_COMPUTE_64F: cublasComputeType_t = 70;
pub const cublasComputeType_t_CUBLAS_COMPUTE_64F_PEDANTIC: cublasComputeType_t = 71;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32I: cublasComputeType_t = 72;
pub const cublasComputeType_t_CUBLAS_COMPUTE_32I_PEDANTIC: cublasComputeType_t = 73;
pub type cublasComputeType_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cublasContext {
    _unused: [u8; 0],
}
pub type cublasHandle_t = *mut cublasContext;
unsafe extern "C" {
    pub fn cublasCreate_v2(handle: *mut cublasHandle_t) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDestroy_v2(handle: cublasHandle_t) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetVersion_v2(
        handle: cublasHandle_t,
        version: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetProperty(
        type_: libraryPropertyType,
        value: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetCudartVersion() -> usize;
}
unsafe extern "C" {
    pub fn cublasSetWorkspace_v2(
        handle: cublasHandle_t,
        workspace: *mut ::std::os::raw::c_void,
        workspaceSizeInBytes: usize,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSetStream_v2(handle: cublasHandle_t, streamId: cudaStream_t) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetStream_v2(
        handle: cublasHandle_t,
        streamId: *mut cudaStream_t,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetPointerMode_v2(
        handle: cublasHandle_t,
        mode: *mut cublasPointerMode_t,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSetPointerMode_v2(
        handle: cublasHandle_t,
        mode: cublasPointerMode_t,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetAtomicsMode(
        handle: cublasHandle_t,
        mode: *mut cublasAtomicsMode_t,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSetAtomicsMode(
        handle: cublasHandle_t,
        mode: cublasAtomicsMode_t,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetMathMode(handle: cublasHandle_t, mode: *mut cublasMath_t) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSetMathMode(handle: cublasHandle_t, mode: cublasMath_t) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetSmCountTarget(
        handle: cublasHandle_t,
        smCountTarget: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSetSmCountTarget(
        handle: cublasHandle_t,
        smCountTarget: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetStatusName(status: cublasStatus_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn cublasGetStatusString(status: cublasStatus_t) -> *const ::std::os::raw::c_char;
}
pub type cublasLogCallback =
::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
unsafe extern "C" {
    pub fn cublasLoggerConfigure(
        logIsOn: ::std::os::raw::c_int,
        logToStdOut: ::std::os::raw::c_int,
        logToStdErr: ::std::os::raw::c_int,
        logFileName: *const ::std::os::raw::c_char,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSetLoggerCallback(userCallback: cublasLogCallback) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetLoggerCallback(userCallback: *mut cublasLogCallback) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSetVector(
        n: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        incx: ::std::os::raw::c_int,
        devicePtr: *mut ::std::os::raw::c_void,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetVector(
        n: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSetMatrix(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        A: *const ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetMatrix(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        A: *const ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSetVectorAsync(
        n: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        hostPtr: *const ::std::os::raw::c_void,
        incx: ::std::os::raw::c_int,
        devicePtr: *mut ::std::os::raw::c_void,
        incy: ::std::os::raw::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetVectorAsync(
        n: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        devicePtr: *const ::std::os::raw::c_void,
        incx: ::std::os::raw::c_int,
        hostPtr: *mut ::std::os::raw::c_void,
        incy: ::std::os::raw::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSetMatrixAsync(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        A: *const ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGetMatrixAsync(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        elemSize: ::std::os::raw::c_int,
        A: *const ::std::os::raw::c_void,
        lda: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_void,
        ldb: ::std::os::raw::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasXerbla(srName: *const ::std::os::raw::c_char, info: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn cublasNrm2Ex(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: cudaDataType,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSnrm2_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDnrm2_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasScnrm2_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDznrm2_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDotEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *const ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: cudaDataType,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDotcEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *const ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: cudaDataType,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSdot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDdot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCdotu_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        result: *mut cuComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCdotc_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        result: *mut cuComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZdotu_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        result: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZdotc_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        result: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasScalEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: cudaDataType,
        x: *mut ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSscal_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDscal_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCscal_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCsscal_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZscal_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZdscal_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasAxpyEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        alphaType: cudaDataType,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSaxpy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDaxpy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCaxpy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZaxpy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCopyEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasScopy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDcopy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCcopy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZcopy_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSswap_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDswap_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCswap_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZswap_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSwapEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasIsamax_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasIdamax_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasIcamax_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasIzamax_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasIamaxEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasIsamin_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasIdamin_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasIcamin_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasIzamin_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasIaminEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasAsumEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
        resultType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSasum_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDasum_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasScasum_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDzasum_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSrot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDrot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCrot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const cuComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCsrot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
        c: *const f32,
        s: *const f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZrot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const cuDoubleComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZdrot_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasRotEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        csType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSrotg_v2(
        handle: cublasHandle_t,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        s: *mut f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDrotg_v2(
        handle: cublasHandle_t,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        s: *mut f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCrotg_v2(
        handle: cublasHandle_t,
        a: *mut cuComplex,
        b: *mut cuComplex,
        c: *mut f32,
        s: *mut cuComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZrotg_v2(
        handle: cublasHandle_t,
        a: *mut cuDoubleComplex,
        b: *mut cuDoubleComplex,
        c: *mut f64,
        s: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasRotgEx(
        handle: cublasHandle_t,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        abType: cudaDataType,
        c: *mut ::std::os::raw::c_void,
        s: *mut ::std::os::raw::c_void,
        csType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSrotm_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        param: *const f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDrotm_v2(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        param: *const f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasRotmEx(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_void,
        xType: cudaDataType,
        incx: ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_void,
        yType: cudaDataType,
        incy: ::std::os::raw::c_int,
        param: *const ::std::os::raw::c_void,
        paramType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSrotmg_v2(
        handle: cublasHandle_t,
        d1: *mut f32,
        d2: *mut f32,
        x1: *mut f32,
        y1: *const f32,
        param: *mut f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDrotmg_v2(
        handle: cublasHandle_t,
        d1: *mut f64,
        d2: *mut f64,
        x1: *mut f64,
        y1: *const f64,
        param: *mut f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasRotmgEx(
        handle: cublasHandle_t,
        d1: *mut ::std::os::raw::c_void,
        d1Type: cudaDataType,
        d2: *mut ::std::os::raw::c_void,
        d2Type: cudaDataType,
        x1: *mut ::std::os::raw::c_void,
        x1Type: cudaDataType,
        y1: *const ::std::os::raw::c_void,
        y1Type: cudaDataType,
        param: *mut ::std::os::raw::c_void,
        paramType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        kl: ::std::os::raw::c_int,
        ku: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasStrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDtrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCtrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZtrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasStbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDtbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCtbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZtbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasStpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDtpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCtpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const cuComplex,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZtpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const cuDoubleComplex,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasStrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDtrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCtrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZtrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasStpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDtpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCtpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const cuComplex,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZtpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        AP: *const cuDoubleComplex,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasStbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *mut f32,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDtbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *mut f64,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCtbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZtbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *mut cuDoubleComplex,
        incx: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasChemv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZhemv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSsbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDsbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasChbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZhbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSspmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        AP: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDspmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        AP: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasChpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        AP: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZhpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        AP: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSger_v2(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDger_v2(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgeru_v2(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgerc_v2(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgeru_v2(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgerc_v2(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCher_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZher_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSspr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        AP: *mut f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDspr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        AP: *mut f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasChpr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut cuComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZhpr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        AP: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCher2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZher2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSspr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        y: *const f32,
        incy: ::std::os::raw::c_int,
        AP: *mut f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDspr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        y: *const f64,
        incy: ::std::os::raw::c_int,
        AP: *mut f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasChpr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut cuComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZhpr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        y: *const cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        AP: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgemvBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        Aarray: *const *const f32,
        lda: ::std::os::raw::c_int,
        xarray: *const *const f32,
        incx: ::std::os::raw::c_int,
        beta: *const f32,
        yarray: *const *mut f32,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgemvBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        Aarray: *const *const f64,
        lda: ::std::os::raw::c_int,
        xarray: *const *const f64,
        incx: ::std::os::raw::c_int,
        beta: *const f64,
        yarray: *const *mut f64,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgemvBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        Aarray: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        xarray: *const *const cuComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuComplex,
        yarray: *const *mut cuComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgemvBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        Aarray: *const *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        xarray: *const *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        yarray: *const *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgemvStridedBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        stridex: ::std::os::raw::c_longlong,
        beta: *const f32,
        y: *mut f32,
        incy: ::std::os::raw::c_int,
        stridey: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgemvStridedBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        stridex: ::std::os::raw::c_longlong,
        beta: *const f64,
        y: *mut f64,
        incy: ::std::os::raw::c_int,
        stridey: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgemvStridedBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        stridex: ::std::os::raw::c_longlong,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::std::os::raw::c_int,
        stridey: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgemvStridedBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        stridex: ::std::os::raw::c_longlong,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::std::os::raw::c_int,
        stridey: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgemm3m(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgemm3mEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_void,
        Btype: cudaDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgemm3m(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgemmEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_void,
        Btype: cudaDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGemmEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_void,
        Btype: cudaDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
        computeType: cublasComputeType_t,
        algo: cublasGemmAlgo_t,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgemmEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_void,
        Btype: cudaDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasUint8gemmBias(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        transc: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const ::std::os::raw::c_uchar,
        A_bias: ::std::os::raw::c_int,
        lda: ::std::os::raw::c_int,
        B: *const ::std::os::raw::c_uchar,
        B_bias: ::std::os::raw::c_int,
        ldb: ::std::os::raw::c_int,
        C: *mut ::std::os::raw::c_uchar,
        C_bias: ::std::os::raw::c_int,
        ldc: ::std::os::raw::c_int,
        C_mult: ::std::os::raw::c_int,
        C_shift: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCsyrkEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCsyrk3mEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCherk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZherk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCherkEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCherk3mEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCher2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZher2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCherkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZherkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasChemm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZhemm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasStrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDtrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCtrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuComplex,
        ldb: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZtrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasStrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDtrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCtrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZtrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        Aarray: *const *const f32,
        lda: ::std::os::raw::c_int,
        Barray: *const *const f32,
        ldb: ::std::os::raw::c_int,
        beta: *const f32,
        Carray: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        Aarray: *const *const f64,
        lda: ::std::os::raw::c_int,
        Barray: *const *const f64,
        ldb: ::std::os::raw::c_int,
        beta: *const f64,
        Carray: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        Aarray: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        Barray: *const *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        Carray: *const *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgemm3mBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        Aarray: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        Barray: *const *const cuComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuComplex,
        Carray: *const *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        Aarray: *const *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Barray: *const *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        Carray: *const *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGemmBatchedEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        Aarray: *const *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        Barray: *const *const ::std::os::raw::c_void,
        Btype: cudaDataType,
        ldb: ::std::os::raw::c_int,
        beta: *const ::std::os::raw::c_void,
        Carray: *const *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
        computeType: cublasComputeType_t,
        algo: cublasGemmAlgo_t,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasGemmStridedBatchedEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        Atype: cudaDataType,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        B: *const ::std::os::raw::c_void,
        Btype: cudaDataType,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_void,
        Ctype: cudaDataType,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
        computeType: cublasComputeType_t,
        algo: cublasGemmAlgo_t,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgemm3mStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        strideB: ::std::os::raw::c_longlong,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        strideC: ::std::os::raw::c_longlong,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        beta: *const f32,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        beta: *const f64,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        beta: *const cuComplex,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        beta: *const cuDoubleComplex,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgetrfBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut f32,
        lda: ::std::os::raw::c_int,
        P: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgetrfBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut f64,
        lda: ::std::os::raw::c_int,
        P: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgetrfBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut cuComplex,
        lda: ::std::os::raw::c_int,
        P: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgetrfBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        P: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgetriBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const f32,
        lda: ::std::os::raw::c_int,
        P: *const ::std::os::raw::c_int,
        C: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgetriBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const f64,
        lda: ::std::os::raw::c_int,
        P: *const ::std::os::raw::c_int,
        C: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgetriBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        P: *const ::std::os::raw::c_int,
        C: *const *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgetriBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        P: *const ::std::os::raw::c_int,
        C: *const *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *const f32,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        Barray: *const *mut f32,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *const f64,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        Barray: *const *mut f64,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        Barray: *const *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        Barray: *const *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasStrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::std::os::raw::c_int,
        B: *const *mut f32,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDtrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::std::os::raw::c_int,
        B: *const *mut f64,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCtrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuComplex,
        A: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZtrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        alpha: *const cuDoubleComplex,
        A: *const *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        batchCount: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSmatinvBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const f32,
        lda: ::std::os::raw::c_int,
        Ainv: *const *mut f32,
        lda_inv: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDmatinvBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const f64,
        lda: ::std::os::raw::c_int,
        Ainv: *const *mut f64,
        lda_inv: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCmatinvBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const cuComplex,
        lda: ::std::os::raw::c_int,
        Ainv: *const *mut cuComplex,
        lda_inv: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZmatinvBatched(
        handle: cublasHandle_t,
        n: ::std::os::raw::c_int,
        A: *const *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Ainv: *const *mut cuDoubleComplex,
        lda_inv: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgeqrfBatched(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Aarray: *const *mut f32,
        lda: ::std::os::raw::c_int,
        TauArray: *const *mut f32,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgeqrfBatched(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Aarray: *const *mut f64,
        lda: ::std::os::raw::c_int,
        TauArray: *const *mut f64,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgeqrfBatched(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Aarray: *const *mut cuComplex,
        lda: ::std::os::raw::c_int,
        TauArray: *const *mut cuComplex,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgeqrfBatched(
        handle: cublasHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Aarray: *const *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        TauArray: *const *mut cuDoubleComplex,
        info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *mut f32,
        lda: ::std::os::raw::c_int,
        Carray: *const *mut f32,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        devInfoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *mut f64,
        lda: ::std::os::raw::c_int,
        Carray: *const *mut f64,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        devInfoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *mut cuComplex,
        lda: ::std::os::raw::c_int,
        Carray: *const *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        devInfoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        Aarray: *const *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Carray: *const *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        devInfoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasSdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        x: *const f32,
        incx: ::std::os::raw::c_int,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        x: *const f64,
        incx: ::std::os::raw::c_int,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuComplex,
        incx: ::std::os::raw::c_int,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        x: *const cuDoubleComplex,
        incx: ::std::os::raw::c_int,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasStpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        AP: *const f32,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDtpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        AP: *const f64,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCtpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        AP: *const cuComplex,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZtpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        AP: *const cuDoubleComplex,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasStrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        AP: *mut f32,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasDtrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        AP: *mut f64,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasCtrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        AP: *mut cuComplex,
    ) -> cublasStatus_t;
}
unsafe extern "C" {
    pub fn cublasZtrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        AP: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
pub type cusolver_int_t = ::std::os::raw::c_int;
pub const cusolverStatus_t_CUSOLVER_STATUS_SUCCESS: cusolverStatus_t = 0;
pub const cusolverStatus_t_CUSOLVER_STATUS_NOT_INITIALIZED: cusolverStatus_t = 1;
pub const cusolverStatus_t_CUSOLVER_STATUS_ALLOC_FAILED: cusolverStatus_t = 2;
pub const cusolverStatus_t_CUSOLVER_STATUS_INVALID_VALUE: cusolverStatus_t = 3;
pub const cusolverStatus_t_CUSOLVER_STATUS_ARCH_MISMATCH: cusolverStatus_t = 4;
pub const cusolverStatus_t_CUSOLVER_STATUS_MAPPING_ERROR: cusolverStatus_t = 5;
pub const cusolverStatus_t_CUSOLVER_STATUS_EXECUTION_FAILED: cusolverStatus_t = 6;
pub const cusolverStatus_t_CUSOLVER_STATUS_INTERNAL_ERROR: cusolverStatus_t = 7;
pub const cusolverStatus_t_CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED: cusolverStatus_t = 8;
pub const cusolverStatus_t_CUSOLVER_STATUS_NOT_SUPPORTED: cusolverStatus_t = 9;
pub const cusolverStatus_t_CUSOLVER_STATUS_ZERO_PIVOT: cusolverStatus_t = 10;
pub const cusolverStatus_t_CUSOLVER_STATUS_INVALID_LICENSE: cusolverStatus_t = 11;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED: cusolverStatus_t = 12;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_PARAMS_INVALID: cusolverStatus_t = 13;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_PARAMS_INVALID_PREC: cusolverStatus_t = 14;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_PARAMS_INVALID_REFINE: cusolverStatus_t = 15;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_PARAMS_INVALID_MAXITER: cusolverStatus_t = 16;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_INTERNAL_ERROR: cusolverStatus_t = 20;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_NOT_SUPPORTED: cusolverStatus_t = 21;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_OUT_OF_RANGE: cusolverStatus_t = 22;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_NRHS_NOT_SUPPORTED_FOR_REFINE_GMRES:
cusolverStatus_t = 23;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED: cusolverStatus_t = 25;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_INFOS_NOT_DESTROYED: cusolverStatus_t = 26;
pub const cusolverStatus_t_CUSOLVER_STATUS_IRS_MATRIX_SINGULAR: cusolverStatus_t = 30;
pub const cusolverStatus_t_CUSOLVER_STATUS_INVALID_WORKSPACE: cusolverStatus_t = 31;
pub type cusolverStatus_t = ::std::os::raw::c_int;
pub const cusolverEigType_t_CUSOLVER_EIG_TYPE_1: cusolverEigType_t = 1;
pub const cusolverEigType_t_CUSOLVER_EIG_TYPE_2: cusolverEigType_t = 2;
pub const cusolverEigType_t_CUSOLVER_EIG_TYPE_3: cusolverEigType_t = 3;
pub type cusolverEigType_t = ::std::os::raw::c_int;
pub const cusolverEigMode_t_CUSOLVER_EIG_MODE_NOVECTOR: cusolverEigMode_t = 0;
pub const cusolverEigMode_t_CUSOLVER_EIG_MODE_VECTOR: cusolverEigMode_t = 1;
pub type cusolverEigMode_t = ::std::os::raw::c_int;
pub const cusolverEigRange_t_CUSOLVER_EIG_RANGE_ALL: cusolverEigRange_t = 1001;
pub const cusolverEigRange_t_CUSOLVER_EIG_RANGE_I: cusolverEigRange_t = 1002;
pub const cusolverEigRange_t_CUSOLVER_EIG_RANGE_V: cusolverEigRange_t = 1003;
pub type cusolverEigRange_t = ::std::os::raw::c_int;
pub const cusolverNorm_t_CUSOLVER_INF_NORM: cusolverNorm_t = 104;
pub const cusolverNorm_t_CUSOLVER_MAX_NORM: cusolverNorm_t = 105;
pub const cusolverNorm_t_CUSOLVER_ONE_NORM: cusolverNorm_t = 106;
pub const cusolverNorm_t_CUSOLVER_FRO_NORM: cusolverNorm_t = 107;
pub type cusolverNorm_t = ::std::os::raw::c_int;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_NOT_SET: cusolverIRSRefinement_t = 1100;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_NONE: cusolverIRSRefinement_t = 1101;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_CLASSICAL: cusolverIRSRefinement_t = 1102;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_CLASSICAL_GMRES: cusolverIRSRefinement_t =
    1103;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_GMRES: cusolverIRSRefinement_t = 1104;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_GMRES_GMRES: cusolverIRSRefinement_t = 1105;
pub const cusolverIRSRefinement_t_CUSOLVER_IRS_REFINE_GMRES_NOPCOND: cusolverIRSRefinement_t = 1106;
pub const cusolverIRSRefinement_t_CUSOLVER_PREC_DD: cusolverIRSRefinement_t = 1150;
pub const cusolverIRSRefinement_t_CUSOLVER_PREC_SS: cusolverIRSRefinement_t = 1151;
pub const cusolverIRSRefinement_t_CUSOLVER_PREC_SHT: cusolverIRSRefinement_t = 1152;
pub type cusolverIRSRefinement_t = ::std::os::raw::c_int;
pub const cusolverPrecType_t_CUSOLVER_R_8I: cusolverPrecType_t = 1201;
pub const cusolverPrecType_t_CUSOLVER_R_8U: cusolverPrecType_t = 1202;
pub const cusolverPrecType_t_CUSOLVER_R_64F: cusolverPrecType_t = 1203;
pub const cusolverPrecType_t_CUSOLVER_R_32F: cusolverPrecType_t = 1204;
pub const cusolverPrecType_t_CUSOLVER_R_16F: cusolverPrecType_t = 1205;
pub const cusolverPrecType_t_CUSOLVER_R_16BF: cusolverPrecType_t = 1206;
pub const cusolverPrecType_t_CUSOLVER_R_TF32: cusolverPrecType_t = 1207;
pub const cusolverPrecType_t_CUSOLVER_R_AP: cusolverPrecType_t = 1208;
pub const cusolverPrecType_t_CUSOLVER_C_8I: cusolverPrecType_t = 1211;
pub const cusolverPrecType_t_CUSOLVER_C_8U: cusolverPrecType_t = 1212;
pub const cusolverPrecType_t_CUSOLVER_C_64F: cusolverPrecType_t = 1213;
pub const cusolverPrecType_t_CUSOLVER_C_32F: cusolverPrecType_t = 1214;
pub const cusolverPrecType_t_CUSOLVER_C_16F: cusolverPrecType_t = 1215;
pub const cusolverPrecType_t_CUSOLVER_C_16BF: cusolverPrecType_t = 1216;
pub const cusolverPrecType_t_CUSOLVER_C_TF32: cusolverPrecType_t = 1217;
pub const cusolverPrecType_t_CUSOLVER_C_AP: cusolverPrecType_t = 1218;
pub type cusolverPrecType_t = ::std::os::raw::c_int;
pub const cusolverAlgMode_t_CUSOLVER_ALG_0: cusolverAlgMode_t = 0;
pub const cusolverAlgMode_t_CUSOLVER_ALG_1: cusolverAlgMode_t = 1;
pub const cusolverAlgMode_t_CUSOLVER_ALG_2: cusolverAlgMode_t = 2;
pub type cusolverAlgMode_t = ::std::os::raw::c_int;
pub const cusolverStorevMode_t_CUBLAS_STOREV_COLUMNWISE: cusolverStorevMode_t = 0;
pub const cusolverStorevMode_t_CUBLAS_STOREV_ROWWISE: cusolverStorevMode_t = 1;
pub type cusolverStorevMode_t = ::std::os::raw::c_int;
pub const cusolverDirectMode_t_CUBLAS_DIRECT_FORWARD: cusolverDirectMode_t = 0;
pub const cusolverDirectMode_t_CUBLAS_DIRECT_BACKWARD: cusolverDirectMode_t = 1;
pub type cusolverDirectMode_t = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn cusolverGetProperty(
        type_: libraryPropertyType,
        value: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverGetVersion(version: *mut ::std::os::raw::c_int) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCreate(handle: *mut cusolverDnHandle_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDestroy(handle: cusolverDnHandle_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSetStream(
        handle: cusolverDnHandle_t,
        streamId: cudaStream_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnGetStream(
        handle: cusolverDnHandle_t,
        streamId: *mut cudaStream_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsCreate(params_ptr: *mut cusolverDnIRSParams_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsDestroy(params: cusolverDnIRSParams_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsSetRefinementSolver(
        params: cusolverDnIRSParams_t,
        refinement_solver: cusolverIRSRefinement_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsSetSolverMainPrecision(
        params: cusolverDnIRSParams_t,
        solver_main_precision: cusolverPrecType_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsSetSolverLowestPrecision(
        params: cusolverDnIRSParams_t,
        solver_lowest_precision: cusolverPrecType_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsSetSolverPrecisions(
        params: cusolverDnIRSParams_t,
        solver_main_precision: cusolverPrecType_t,
        solver_lowest_precision: cusolverPrecType_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsSetTol(params: cusolverDnIRSParams_t, val: f64) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsSetTolInner(
        params: cusolverDnIRSParams_t,
        val: f64,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsSetMaxIters(
        params: cusolverDnIRSParams_t,
        maxiters: cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsSetMaxItersInner(
        params: cusolverDnIRSParams_t,
        maxiters_inner: cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsGetMaxIters(
        params: cusolverDnIRSParams_t,
        maxiters: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsEnableFallback(params: cusolverDnIRSParams_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSParamsDisableFallback(params: cusolverDnIRSParams_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSInfosDestroy(infos: cusolverDnIRSInfos_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSInfosCreate(infos_ptr: *mut cusolverDnIRSInfos_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSInfosGetNiters(
        infos: cusolverDnIRSInfos_t,
        niters: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSInfosGetOuterNiters(
        infos: cusolverDnIRSInfos_t,
        outer_niters: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSInfosRequestResidual(infos: cusolverDnIRSInfos_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSInfosGetResidualHistory(
        infos: cusolverDnIRSInfos_t,
        residual_history: *mut *mut ::std::os::raw::c_void,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSInfosGetMaxIters(
        infos: cusolverDnIRSInfos_t,
        maxiters: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZZgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZCgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZKgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZEgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZYgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCCgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCEgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCKgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCYgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDDgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDSgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDHgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDBgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDXgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSSgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSHgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSBgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSXgesv(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZZgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZCgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZKgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZEgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZYgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCCgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCKgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCEgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCYgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDDgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDSgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDHgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDBgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDXgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSSgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSHgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSBgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSXgesv_bufferSize(
        handle: cusolverDnHandle_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dipiv: *mut cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZZgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZCgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZKgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZEgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZYgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCCgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCKgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCEgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCYgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDDgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDSgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDHgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDBgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDXgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSSgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSHgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSBgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSXgels(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        iter: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZZgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZCgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZKgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZEgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZYgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuDoubleComplex,
        ldda: cusolver_int_t,
        dB: *mut cuDoubleComplex,
        lddb: cusolver_int_t,
        dX: *mut cuDoubleComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCCgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCKgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCEgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCYgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut cuComplex,
        ldda: cusolver_int_t,
        dB: *mut cuComplex,
        lddb: cusolver_int_t,
        dX: *mut cuComplex,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDDgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDSgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDHgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDBgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDXgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f64,
        ldda: cusolver_int_t,
        dB: *mut f64,
        lddb: cusolver_int_t,
        dX: *mut f64,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSSgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSHgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSBgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSXgels_bufferSize(
        handle: cusolverDnHandle_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut f32,
        ldda: cusolver_int_t,
        dB: *mut f32,
        lddb: cusolver_int_t,
        dX: *mut f32,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSXgesv(
        handle: cusolverDnHandle_t,
        gesv_irs_params: cusolverDnIRSParams_t,
        gesv_irs_infos: cusolverDnIRSInfos_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut ::std::os::raw::c_void,
        ldda: cusolver_int_t,
        dB: *mut ::std::os::raw::c_void,
        lddb: cusolver_int_t,
        dX: *mut ::std::os::raw::c_void,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        niters: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSXgesv_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnIRSParams_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSXgels(
        handle: cusolverDnHandle_t,
        gels_irs_params: cusolverDnIRSParams_t,
        gels_irs_infos: cusolverDnIRSInfos_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        dA: *mut ::std::os::raw::c_void,
        ldda: cusolver_int_t,
        dB: *mut ::std::os::raw::c_void,
        lddb: cusolver_int_t,
        dX: *mut ::std::os::raw::c_void,
        lddx: cusolver_int_t,
        dWorkspace: *mut ::std::os::raw::c_void,
        lwork_bytes: usize,
        niters: *mut cusolver_int_t,
        d_info: *mut cusolver_int_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnIRSXgels_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnIRSParams_t,
        m: cusolver_int_t,
        n: cusolver_int_t,
        nrhs: cusolver_int_t,
        lwork_bytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSpotrf_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDpotrf_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCpotrf_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZpotrf_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSpotrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        Workspace: *mut f32,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDpotrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        Workspace: *mut f64,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCpotrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        Workspace: *mut cuComplex,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZpotrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Workspace: *mut cuDoubleComplex,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSpotrs(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDpotrs(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCpotrs(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZpotrs(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSpotrfBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        Aarray: *mut *mut f32,
        lda: ::std::os::raw::c_int,
        infoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDpotrfBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        Aarray: *mut *mut f64,
        lda: ::std::os::raw::c_int,
        infoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCpotrfBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        Aarray: *mut *mut cuComplex,
        lda: ::std::os::raw::c_int,
        infoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZpotrfBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        Aarray: *mut *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        infoArray: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSpotrsBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut *mut f32,
        lda: ::std::os::raw::c_int,
        B: *mut *mut f32,
        ldb: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDpotrsBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut *mut f64,
        lda: ::std::os::raw::c_int,
        B: *mut *mut f64,
        ldb: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCpotrsBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut *mut cuComplex,
        lda: ::std::os::raw::c_int,
        B: *mut *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZpotrsBatched(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *mut *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSpotri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDpotri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCpotri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZpotri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSpotri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDpotri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCpotri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZpotri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXtrtri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        diag: cublasDiagType_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXtrtri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        diag: cublasDiagType_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSlauum_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDlauum_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnClauum_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZlauum_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSlauum(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDlauum(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnClauum(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZlauum(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgetrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgetrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgetrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgetrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgetrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        Workspace: *mut f32,
        devIpiv: *mut ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgetrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        Workspace: *mut f64,
        devIpiv: *mut ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgetrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        Workspace: *mut cuComplex,
        devIpiv: *mut ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgetrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        Workspace: *mut cuDoubleComplex,
        devIpiv: *mut ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSlaswp(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        k1: ::std::os::raw::c_int,
        k2: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        incx: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDlaswp(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        k1: ::std::os::raw::c_int,
        k2: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        incx: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnClaswp(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        k1: ::std::os::raw::c_int,
        k2: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        incx: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZlaswp(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        k1: ::std::os::raw::c_int,
        k2: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        incx: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgetrs(
        handle: cusolverDnHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgetrs(
        handle: cusolverDnHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgetrs(
        handle: cusolverDnHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        B: *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgetrs(
        handle: cusolverDnHandle_t,
        trans: cublasOperation_t,
        n: ::std::os::raw::c_int,
        nrhs: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        devIpiv: *const ::std::os::raw::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgeqrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgeqrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgeqrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgeqrf_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgeqrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        TAU: *mut f32,
        Workspace: *mut f32,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgeqrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        TAU: *mut f64,
        Workspace: *mut f64,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgeqrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        TAU: *mut cuComplex,
        Workspace: *mut cuComplex,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgeqrf(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        TAU: *mut cuDoubleComplex,
        Workspace: *mut cuDoubleComplex,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSorgqr_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDorgqr_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCungqr_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZungqr_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSorgqr(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDorgqr(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCungqr(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZungqr(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSormqr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        C: *const f32,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDormqr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        C: *const f64,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCunmqr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        C: *const cuComplex,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZunmqr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        C: *const cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSormqr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDormqr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCunmqr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZunmqr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsytrf_bufferSize(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsytrf_bufferSize(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCsytrf_bufferSize(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZsytrf_bufferSize(
        handle: cusolverDnHandle_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsytrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsytrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCsytrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZsytrf(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXsytrs_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: i64,
        nrhs: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        ipiv: *const i64,
        dataTypeB: cudaDataType,
        B: *mut ::std::os::raw::c_void,
        ldb: i64,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXsytrs(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: i64,
        nrhs: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        ipiv: *const i64,
        dataTypeB: cudaDataType,
        B: *mut ::std::os::raw::c_void,
        ldb: i64,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsytri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsytri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCsytri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZsytri_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsytri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsytri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCsytri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZsytri(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgebrd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgebrd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgebrd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgebrd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        Lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgebrd(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        D: *mut f32,
        E: *mut f32,
        TAUQ: *mut f32,
        TAUP: *mut f32,
        Work: *mut f32,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgebrd(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        D: *mut f64,
        E: *mut f64,
        TAUQ: *mut f64,
        TAUP: *mut f64,
        Work: *mut f64,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgebrd(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        D: *mut f32,
        E: *mut f32,
        TAUQ: *mut cuComplex,
        TAUP: *mut cuComplex,
        Work: *mut cuComplex,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgebrd(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        D: *mut f64,
        E: *mut f64,
        TAUQ: *mut cuDoubleComplex,
        TAUP: *mut cuDoubleComplex,
        Work: *mut cuDoubleComplex,
        Lwork: ::std::os::raw::c_int,
        devInfo: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSorgbr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDorgbr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCungbr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZungbr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSorgbr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDorgbr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCungbr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZungbr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsytrd_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        d: *const f32,
        e: *const f32,
        tau: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsytrd_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        d: *const f64,
        e: *const f64,
        tau: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnChetrd_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        d: *const f32,
        e: *const f32,
        tau: *const cuComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZhetrd_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        d: *const f64,
        e: *const f64,
        tau: *const cuDoubleComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsytrd(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        d: *mut f32,
        e: *mut f32,
        tau: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsytrd(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tau: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnChetrd(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        d: *mut f32,
        e: *mut f32,
        tau: *mut cuComplex,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZhetrd(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tau: *mut cuDoubleComplex,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSorgtr_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDorgtr_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCungtr_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZungtr_bufferSize(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSorgtr(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDorgtr(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCungtr(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZungtr(
        handle: cusolverDnHandle_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSormtr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        tau: *const f32,
        C: *const f32,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDormtr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        tau: *const f64,
        C: *const f64,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCunmtr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuComplex,
        C: *const cuComplex,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZunmtr_bufferSize(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *const cuDoubleComplex,
        C: *const cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSormtr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        tau: *mut f32,
        C: *mut f32,
        ldc: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDormtr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        tau: *mut f64,
        C: *mut f64,
        ldc: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCunmtr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        tau: *mut cuComplex,
        C: *mut cuComplex,
        ldc: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZunmtr(
        handle: cusolverDnHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        tau: *mut cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgesvd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgesvd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgesvd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgesvd_bufferSize(
        handle: cusolverDnHandle_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgesvd(
        handle: cusolverDnHandle_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        S: *mut f32,
        U: *mut f32,
        ldu: ::std::os::raw::c_int,
        VT: *mut f32,
        ldvt: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        rwork: *mut f32,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgesvd(
        handle: cusolverDnHandle_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        S: *mut f64,
        U: *mut f64,
        ldu: ::std::os::raw::c_int,
        VT: *mut f64,
        ldvt: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgesvd(
        handle: cusolverDnHandle_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        S: *mut f32,
        U: *mut cuComplex,
        ldu: ::std::os::raw::c_int,
        VT: *mut cuComplex,
        ldvt: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        rwork: *mut f32,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgesvd(
        handle: cusolverDnHandle_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        S: *mut f64,
        U: *mut cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        VT: *mut cuDoubleComplex,
        ldvt: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsyevd_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsyevd_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCheevd_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZheevd_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsyevd(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsyevd(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCheevd(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZheevd(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsyevdx_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsyevdx_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCheevdx_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZheevdx_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsyevdx(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsyevdx(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCheevdx(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZheevdx(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsygvdx_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsygvdx_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnChegvdx_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZhegvdx_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsygvdx(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsygvdx(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnChegvdx(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        vl: f32,
        vu: f32,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZhegvdx(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        vl: f64,
        vu: f64,
        il: ::std::os::raw::c_int,
        iu: ::std::os::raw::c_int,
        meig: *mut ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsygvd_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsygvd_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnChegvd_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZhegvd_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsygvd(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsygvd(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnChegvd(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZhegvd(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCreateSyevjInfo(info: *mut syevjInfo_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDestroySyevjInfo(info: syevjInfo_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXsyevjSetTolerance(info: syevjInfo_t, tolerance: f64) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXsyevjSetMaxSweeps(
        info: syevjInfo_t,
        max_sweeps: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXsyevjSetSortEig(
        info: syevjInfo_t,
        sort_eig: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXsyevjGetResidual(
        handle: cusolverDnHandle_t,
        info: syevjInfo_t,
        residual: *mut f64,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXsyevjGetSweeps(
        handle: cusolverDnHandle_t,
        info: syevjInfo_t,
        executed_sweeps: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsyevjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsyevjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCheevjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZheevjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsyevjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsyevjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCheevjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZheevjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsyevj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsyevj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCheevj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZheevj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsyevj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsyevj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCheevj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZheevj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsygvj_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        B: *const f32,
        ldb: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsygvj_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        B: *const f64,
        ldb: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnChegvj_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuComplex,
        ldb: ::std::os::raw::c_int,
        W: *const f32,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZhegvj_bufferSize(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *const cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        W: *const f64,
        lwork: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSsygvj(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        B: *mut f32,
        ldb: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDsygvj(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        B: *mut f64,
        ldb: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnChegvj(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuComplex,
        ldb: ::std::os::raw::c_int,
        W: *mut f32,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZhegvj(
        handle: cusolverDnHandle_t,
        itype: cusolverEigType_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::std::os::raw::c_int,
        W: *mut f64,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: syevjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCreateGesvdjInfo(info: *mut gesvdjInfo_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDestroyGesvdjInfo(info: gesvdjInfo_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgesvdjSetTolerance(info: gesvdjInfo_t, tolerance: f64) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgesvdjSetMaxSweeps(
        info: gesvdjInfo_t,
        max_sweeps: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgesvdjSetSortEig(
        info: gesvdjInfo_t,
        sort_svd: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgesvdjGetResidual(
        handle: cusolverDnHandle_t,
        info: gesvdjInfo_t,
        residual: *mut f64,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgesvdjGetSweeps(
        handle: cusolverDnHandle_t,
        info: gesvdjInfo_t,
        executed_sweeps: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgesvdjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        S: *const f32,
        U: *const f32,
        ldu: ::std::os::raw::c_int,
        V: *const f32,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgesvdjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        S: *const f64,
        U: *const f64,
        ldu: ::std::os::raw::c_int,
        V: *const f64,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgesvdjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        S: *const f32,
        U: *const cuComplex,
        ldu: ::std::os::raw::c_int,
        V: *const cuComplex,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgesvdjBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        S: *const f64,
        U: *const cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        V: *const cuDoubleComplex,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgesvdjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        S: *mut f32,
        U: *mut f32,
        ldu: ::std::os::raw::c_int,
        V: *mut f32,
        ldv: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgesvdjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        S: *mut f64,
        U: *mut f64,
        ldu: ::std::os::raw::c_int,
        V: *mut f64,
        ldv: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgesvdjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        S: *mut f32,
        U: *mut cuComplex,
        ldu: ::std::os::raw::c_int,
        V: *mut cuComplex,
        ldv: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgesvdjBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        S: *mut f64,
        U: *mut cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        V: *mut cuDoubleComplex,
        ldv: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgesvdj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f32,
        lda: ::std::os::raw::c_int,
        S: *const f32,
        U: *const f32,
        ldu: ::std::os::raw::c_int,
        V: *const f32,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgesvdj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const f64,
        lda: ::std::os::raw::c_int,
        S: *const f64,
        U: *const f64,
        ldu: ::std::os::raw::c_int,
        V: *const f64,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgesvdj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        S: *const f32,
        U: *const cuComplex,
        ldu: ::std::os::raw::c_int,
        V: *const cuComplex,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgesvdj_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        S: *const f64,
        U: *const cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        V: *const cuDoubleComplex,
        ldv: ::std::os::raw::c_int,
        lwork: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgesvdj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f32,
        lda: ::std::os::raw::c_int,
        S: *mut f32,
        U: *mut f32,
        ldu: ::std::os::raw::c_int,
        V: *mut f32,
        ldv: ::std::os::raw::c_int,
        work: *mut f32,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgesvdj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut f64,
        lda: ::std::os::raw::c_int,
        S: *mut f64,
        U: *mut f64,
        ldu: ::std::os::raw::c_int,
        V: *mut f64,
        ldv: ::std::os::raw::c_int,
        work: *mut f64,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgesvdj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuComplex,
        lda: ::std::os::raw::c_int,
        S: *mut f32,
        U: *mut cuComplex,
        ldu: ::std::os::raw::c_int,
        V: *mut cuComplex,
        ldv: ::std::os::raw::c_int,
        work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgesvdj(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        A: *mut cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        S: *mut f64,
        U: *mut cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        V: *mut cuDoubleComplex,
        ldv: ::std::os::raw::c_int,
        work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        params: gesvdjInfo_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgesvdaStridedBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *const f32,
        strideS: ::std::os::raw::c_longlong,
        d_U: *const f32,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *const f32,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        lwork: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgesvdaStridedBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *const f64,
        strideS: ::std::os::raw::c_longlong,
        d_U: *const f64,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *const f64,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        lwork: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgesvdaStridedBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *const f32,
        strideS: ::std::os::raw::c_longlong,
        d_U: *const cuComplex,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *const cuComplex,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        lwork: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgesvdaStridedBatched_bufferSize(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *const f64,
        strideS: ::std::os::raw::c_longlong,
        d_U: *const cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *const cuDoubleComplex,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        lwork: *mut ::std::os::raw::c_int,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSgesvdaStridedBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const f32,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *mut f32,
        strideS: ::std::os::raw::c_longlong,
        d_U: *mut f32,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *mut f32,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        d_work: *mut f32,
        lwork: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        h_R_nrmF: *mut f64,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDgesvdaStridedBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const f64,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *mut f64,
        strideS: ::std::os::raw::c_longlong,
        d_U: *mut f64,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *mut f64,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        d_work: *mut f64,
        lwork: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        h_R_nrmF: *mut f64,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCgesvdaStridedBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const cuComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *mut f32,
        strideS: ::std::os::raw::c_longlong,
        d_U: *mut cuComplex,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *mut cuComplex,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        d_work: *mut cuComplex,
        lwork: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        h_R_nrmF: *mut f64,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnZgesvdaStridedBatched(
        handle: cusolverDnHandle_t,
        jobz: cusolverEigMode_t,
        rank: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        d_A: *const cuDoubleComplex,
        lda: ::std::os::raw::c_int,
        strideA: ::std::os::raw::c_longlong,
        d_S: *mut f64,
        strideS: ::std::os::raw::c_longlong,
        d_U: *mut cuDoubleComplex,
        ldu: ::std::os::raw::c_int,
        strideU: ::std::os::raw::c_longlong,
        d_V: *mut cuDoubleComplex,
        ldv: ::std::os::raw::c_int,
        strideV: ::std::os::raw::c_longlong,
        d_work: *mut cuDoubleComplex,
        lwork: ::std::os::raw::c_int,
        d_info: *mut ::std::os::raw::c_int,
        h_R_nrmF: *mut f64,
        batchSize: ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnCreateParams(params: *mut cusolverDnParams_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnDestroyParams(params: cusolverDnParams_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSetAdvOptions(
        params: cusolverDnParams_t,
        function: cusolverDnFunction_t,
        algo: cusolverAlgMode_t,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnPotrf_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        computeType: cudaDataType,
        workspaceInBytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnPotrf(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        computeType: cudaDataType,
        pBuffer: *mut ::std::os::raw::c_void,
        workspaceInBytes: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnPotrs(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        uplo: cublasFillMode_t,
        n: i64,
        nrhs: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeB: cudaDataType,
        B: *mut ::std::os::raw::c_void,
        ldb: i64,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnGeqrf_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeTau: cudaDataType,
        tau: *const ::std::os::raw::c_void,
        computeType: cudaDataType,
        workspaceInBytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnGeqrf(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeTau: cudaDataType,
        tau: *mut ::std::os::raw::c_void,
        computeType: cudaDataType,
        pBuffer: *mut ::std::os::raw::c_void,
        workspaceInBytes: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnGetrf_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        computeType: cudaDataType,
        workspaceInBytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnGetrf(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        ipiv: *mut i64,
        computeType: cudaDataType,
        pBuffer: *mut ::std::os::raw::c_void,
        workspaceInBytes: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnGetrs(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        trans: cublasOperation_t,
        n: i64,
        nrhs: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        ipiv: *const i64,
        dataTypeB: cudaDataType,
        B: *mut ::std::os::raw::c_void,
        ldb: i64,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSyevd_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeW: cudaDataType,
        W: *const ::std::os::raw::c_void,
        computeType: cudaDataType,
        workspaceInBytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSyevd(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeW: cudaDataType,
        W: *mut ::std::os::raw::c_void,
        computeType: cudaDataType,
        pBuffer: *mut ::std::os::raw::c_void,
        workspaceInBytes: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSyevdx_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        vl: *mut ::std::os::raw::c_void,
        vu: *mut ::std::os::raw::c_void,
        il: i64,
        iu: i64,
        h_meig: *mut i64,
        dataTypeW: cudaDataType,
        W: *const ::std::os::raw::c_void,
        computeType: cudaDataType,
        workspaceInBytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnSyevdx(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        vl: *mut ::std::os::raw::c_void,
        vu: *mut ::std::os::raw::c_void,
        il: i64,
        iu: i64,
        meig64: *mut i64,
        dataTypeW: cudaDataType,
        W: *mut ::std::os::raw::c_void,
        computeType: cudaDataType,
        pBuffer: *mut ::std::os::raw::c_void,
        workspaceInBytes: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnGesvd_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeS: cudaDataType,
        S: *const ::std::os::raw::c_void,
        dataTypeU: cudaDataType,
        U: *const ::std::os::raw::c_void,
        ldu: i64,
        dataTypeVT: cudaDataType,
        VT: *const ::std::os::raw::c_void,
        ldvt: i64,
        computeType: cudaDataType,
        workspaceInBytes: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnGesvd(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeS: cudaDataType,
        S: *mut ::std::os::raw::c_void,
        dataTypeU: cudaDataType,
        U: *mut ::std::os::raw::c_void,
        ldu: i64,
        dataTypeVT: cudaDataType,
        VT: *mut ::std::os::raw::c_void,
        ldvt: i64,
        computeType: cudaDataType,
        pBuffer: *mut ::std::os::raw::c_void,
        workspaceInBytes: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXpotrf_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXpotrf(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXpotrs(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        uplo: cublasFillMode_t,
        n: i64,
        nrhs: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeB: cudaDataType,
        B: *mut ::std::os::raw::c_void,
        ldb: i64,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgeqrf_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeTau: cudaDataType,
        tau: *const ::std::os::raw::c_void,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgeqrf(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeTau: cudaDataType,
        tau: *mut ::std::os::raw::c_void,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgetrf_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgetrf(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        ipiv: *mut i64,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgetrs(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        trans: cublasOperation_t,
        n: i64,
        nrhs: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        ipiv: *const i64,
        dataTypeB: cudaDataType,
        B: *mut ::std::os::raw::c_void,
        ldb: i64,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXsyevd_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeW: cudaDataType,
        W: *const ::std::os::raw::c_void,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXsyevd(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeW: cudaDataType,
        W: *mut ::std::os::raw::c_void,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXsyevdx_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        vl: *mut ::std::os::raw::c_void,
        vu: *mut ::std::os::raw::c_void,
        il: i64,
        iu: i64,
        h_meig: *mut i64,
        dataTypeW: cudaDataType,
        W: *const ::std::os::raw::c_void,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXsyevdx(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        range: cusolverEigRange_t,
        uplo: cublasFillMode_t,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        vl: *mut ::std::os::raw::c_void,
        vu: *mut ::std::os::raw::c_void,
        il: i64,
        iu: i64,
        meig64: *mut i64,
        dataTypeW: cudaDataType,
        W: *mut ::std::os::raw::c_void,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgesvd_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeS: cudaDataType,
        S: *const ::std::os::raw::c_void,
        dataTypeU: cudaDataType,
        U: *const ::std::os::raw::c_void,
        ldu: i64,
        dataTypeVT: cudaDataType,
        VT: *const ::std::os::raw::c_void,
        ldvt: i64,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgesvd(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobu: ::std::os::raw::c_schar,
        jobvt: ::std::os::raw::c_schar,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeS: cudaDataType,
        S: *mut ::std::os::raw::c_void,
        dataTypeU: cudaDataType,
        U: *mut ::std::os::raw::c_void,
        ldu: i64,
        dataTypeVT: cudaDataType,
        VT: *mut ::std::os::raw::c_void,
        ldvt: i64,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgesvdp_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeS: cudaDataType,
        S: *const ::std::os::raw::c_void,
        dataTypeU: cudaDataType,
        U: *const ::std::os::raw::c_void,
        ldu: i64,
        dataTypeV: cudaDataType,
        V: *const ::std::os::raw::c_void,
        ldv: i64,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgesvdp(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobz: cusolverEigMode_t,
        econ: ::std::os::raw::c_int,
        m: i64,
        n: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeS: cudaDataType,
        S: *mut ::std::os::raw::c_void,
        dataTypeU: cudaDataType,
        U: *mut ::std::os::raw::c_void,
        ldu: i64,
        dataTypeV: cudaDataType,
        V: *mut ::std::os::raw::c_void,
        ldv: i64,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        d_info: *mut ::std::os::raw::c_int,
        h_err_sigma: *mut f64,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgesvdr_bufferSize(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobu: ::std::os::raw::c_schar,
        jobv: ::std::os::raw::c_schar,
        m: i64,
        n: i64,
        k: i64,
        p: i64,
        niters: i64,
        dataTypeA: cudaDataType,
        A: *const ::std::os::raw::c_void,
        lda: i64,
        dataTypeSrand: cudaDataType,
        Srand: *const ::std::os::raw::c_void,
        dataTypeUrand: cudaDataType,
        Urand: *const ::std::os::raw::c_void,
        ldUrand: i64,
        dataTypeVrand: cudaDataType,
        Vrand: *const ::std::os::raw::c_void,
        ldVrand: i64,
        computeType: cudaDataType,
        workspaceInBytesOnDevice: *mut usize,
        workspaceInBytesOnHost: *mut usize,
    ) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnXgesvdr(
        handle: cusolverDnHandle_t,
        params: cusolverDnParams_t,
        jobu: ::std::os::raw::c_schar,
        jobv: ::std::os::raw::c_schar,
        m: i64,
        n: i64,
        k: i64,
        p: i64,
        niters: i64,
        dataTypeA: cudaDataType,
        A: *mut ::std::os::raw::c_void,
        lda: i64,
        dataTypeSrand: cudaDataType,
        Srand: *mut ::std::os::raw::c_void,
        dataTypeUrand: cudaDataType,
        Urand: *mut ::std::os::raw::c_void,
        ldUrand: i64,
        dataTypeVrand: cudaDataType,
        Vrand: *mut ::std::os::raw::c_void,
        ldVrand: i64,
        computeType: cudaDataType,
        bufferOnDevice: *mut ::std::os::raw::c_void,
        workspaceInBytesOnDevice: usize,
        bufferOnHost: *mut ::std::os::raw::c_void,
        workspaceInBytesOnHost: usize,
        d_info: *mut ::std::os::raw::c_int,
    ) -> cusolverStatus_t;
}
pub type cusolverDnLoggerCallback_t = ::std::option::Option<
    unsafe extern "C" fn(
        logLevel: ::std::os::raw::c_int,
        functionName: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    ),
>;
unsafe extern "C" {
    pub fn cusolverDnLoggerSetCallback(callback: cusolverDnLoggerCallback_t) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnLoggerSetFile(file: *mut FILE) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnLoggerOpenFile(logFile: *const ::std::os::raw::c_char) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnLoggerSetLevel(level: ::std::os::raw::c_int) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnLoggerSetMask(mask: ::std::os::raw::c_int) -> cusolverStatus_t;
}
unsafe extern "C" {
    pub fn cusolverDnLoggerForceDisable() -> cusolverStatus_t;
}
pub const cufftResult_t_CUFFT_SUCCESS: cufftResult_t = 0;
pub const cufftResult_t_CUFFT_INVALID_PLAN: cufftResult_t = 1;
pub const cufftResult_t_CUFFT_ALLOC_FAILED: cufftResult_t = 2;
pub const cufftResult_t_CUFFT_INVALID_TYPE: cufftResult_t = 3;
pub const cufftResult_t_CUFFT_INVALID_VALUE: cufftResult_t = 4;
pub const cufftResult_t_CUFFT_INTERNAL_ERROR: cufftResult_t = 5;
pub const cufftResult_t_CUFFT_EXEC_FAILED: cufftResult_t = 6;
pub const cufftResult_t_CUFFT_SETUP_FAILED: cufftResult_t = 7;
pub const cufftResult_t_CUFFT_INVALID_SIZE: cufftResult_t = 8;
pub const cufftResult_t_CUFFT_UNALIGNED_DATA: cufftResult_t = 9;
pub const cufftResult_t_CUFFT_INCOMPLETE_PARAMETER_LIST: cufftResult_t = 10;
pub const cufftResult_t_CUFFT_INVALID_DEVICE: cufftResult_t = 11;
pub const cufftResult_t_CUFFT_PARSE_ERROR: cufftResult_t = 12;
pub const cufftResult_t_CUFFT_NO_WORKSPACE: cufftResult_t = 13;
pub const cufftResult_t_CUFFT_NOT_IMPLEMENTED: cufftResult_t = 14;
pub const cufftResult_t_CUFFT_LICENSE_ERROR: cufftResult_t = 15;
pub const cufftResult_t_CUFFT_NOT_SUPPORTED: cufftResult_t = 16;
pub type cufftResult_t = ::std::os::raw::c_int;
pub use self::cufftResult_t as cufftResult;
pub type cufftReal = f32;
pub type cufftDoubleReal = f64;
pub type cufftComplex = cuComplex;
pub type cufftDoubleComplex = cuDoubleComplex;
pub const cufftType_t_CUFFT_R2C: cufftType_t = 42;
pub const cufftType_t_CUFFT_C2R: cufftType_t = 44;
pub const cufftType_t_CUFFT_C2C: cufftType_t = 41;
pub const cufftType_t_CUFFT_D2Z: cufftType_t = 106;
pub const cufftType_t_CUFFT_Z2D: cufftType_t = 108;
pub const cufftType_t_CUFFT_Z2Z: cufftType_t = 105;
pub type cufftType_t = ::std::os::raw::c_int;
pub use self::cufftType_t as cufftType;
pub const cufftCompatibility_t_CUFFT_COMPATIBILITY_FFTW_PADDING: cufftCompatibility_t = 1;
pub type cufftCompatibility_t = ::std::os::raw::c_int;
pub use self::cufftCompatibility_t as cufftCompatibility;
pub type cufftHandle = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn cufftPlan1d(
        plan: *mut cufftHandle,
        nx: ::std::os::raw::c_int,
        type_: cufftType,
        batch: ::std::os::raw::c_int,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftPlan2d(
        plan: *mut cufftHandle,
        nx: ::std::os::raw::c_int,
        ny: ::std::os::raw::c_int,
        type_: cufftType,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftPlan3d(
        plan: *mut cufftHandle,
        nx: ::std::os::raw::c_int,
        ny: ::std::os::raw::c_int,
        nz: ::std::os::raw::c_int,
        type_: cufftType,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftPlanMany(
        plan: *mut cufftHandle,
        rank: ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        inembed: *mut ::std::os::raw::c_int,
        istride: ::std::os::raw::c_int,
        idist: ::std::os::raw::c_int,
        onembed: *mut ::std::os::raw::c_int,
        ostride: ::std::os::raw::c_int,
        odist: ::std::os::raw::c_int,
        type_: cufftType,
        batch: ::std::os::raw::c_int,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftMakePlan1d(
        plan: cufftHandle,
        nx: ::std::os::raw::c_int,
        type_: cufftType,
        batch: ::std::os::raw::c_int,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftMakePlan2d(
        plan: cufftHandle,
        nx: ::std::os::raw::c_int,
        ny: ::std::os::raw::c_int,
        type_: cufftType,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftMakePlan3d(
        plan: cufftHandle,
        nx: ::std::os::raw::c_int,
        ny: ::std::os::raw::c_int,
        nz: ::std::os::raw::c_int,
        type_: cufftType,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftMakePlanMany(
        plan: cufftHandle,
        rank: ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        inembed: *mut ::std::os::raw::c_int,
        istride: ::std::os::raw::c_int,
        idist: ::std::os::raw::c_int,
        onembed: *mut ::std::os::raw::c_int,
        ostride: ::std::os::raw::c_int,
        odist: ::std::os::raw::c_int,
        type_: cufftType,
        batch: ::std::os::raw::c_int,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftMakePlanMany64(
        plan: cufftHandle,
        rank: ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_longlong,
        inembed: *mut ::std::os::raw::c_longlong,
        istride: ::std::os::raw::c_longlong,
        idist: ::std::os::raw::c_longlong,
        onembed: *mut ::std::os::raw::c_longlong,
        ostride: ::std::os::raw::c_longlong,
        odist: ::std::os::raw::c_longlong,
        type_: cufftType,
        batch: ::std::os::raw::c_longlong,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftGetSizeMany64(
        plan: cufftHandle,
        rank: ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_longlong,
        inembed: *mut ::std::os::raw::c_longlong,
        istride: ::std::os::raw::c_longlong,
        idist: ::std::os::raw::c_longlong,
        onembed: *mut ::std::os::raw::c_longlong,
        ostride: ::std::os::raw::c_longlong,
        odist: ::std::os::raw::c_longlong,
        type_: cufftType,
        batch: ::std::os::raw::c_longlong,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftEstimate1d(
        nx: ::std::os::raw::c_int,
        type_: cufftType,
        batch: ::std::os::raw::c_int,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftEstimate2d(
        nx: ::std::os::raw::c_int,
        ny: ::std::os::raw::c_int,
        type_: cufftType,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftEstimate3d(
        nx: ::std::os::raw::c_int,
        ny: ::std::os::raw::c_int,
        nz: ::std::os::raw::c_int,
        type_: cufftType,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftEstimateMany(
        rank: ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        inembed: *mut ::std::os::raw::c_int,
        istride: ::std::os::raw::c_int,
        idist: ::std::os::raw::c_int,
        onembed: *mut ::std::os::raw::c_int,
        ostride: ::std::os::raw::c_int,
        odist: ::std::os::raw::c_int,
        type_: cufftType,
        batch: ::std::os::raw::c_int,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftCreate(handle: *mut cufftHandle) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftGetSize1d(
        handle: cufftHandle,
        nx: ::std::os::raw::c_int,
        type_: cufftType,
        batch: ::std::os::raw::c_int,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftGetSize2d(
        handle: cufftHandle,
        nx: ::std::os::raw::c_int,
        ny: ::std::os::raw::c_int,
        type_: cufftType,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftGetSize3d(
        handle: cufftHandle,
        nx: ::std::os::raw::c_int,
        ny: ::std::os::raw::c_int,
        nz: ::std::os::raw::c_int,
        type_: cufftType,
        workSize: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftGetSizeMany(
        handle: cufftHandle,
        rank: ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        inembed: *mut ::std::os::raw::c_int,
        istride: ::std::os::raw::c_int,
        idist: ::std::os::raw::c_int,
        onembed: *mut ::std::os::raw::c_int,
        ostride: ::std::os::raw::c_int,
        odist: ::std::os::raw::c_int,
        type_: cufftType,
        batch: ::std::os::raw::c_int,
        workArea: *mut usize,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftGetSize(handle: cufftHandle, workSize: *mut usize) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftSetWorkArea(
        plan: cufftHandle,
        workArea: *mut ::std::os::raw::c_void,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftSetAutoAllocation(
        plan: cufftHandle,
        autoAllocate: ::std::os::raw::c_int,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftExecC2C(
        plan: cufftHandle,
        idata: *mut cufftComplex,
        odata: *mut cufftComplex,
        direction: ::std::os::raw::c_int,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftExecR2C(
        plan: cufftHandle,
        idata: *mut cufftReal,
        odata: *mut cufftComplex,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftExecC2R(
        plan: cufftHandle,
        idata: *mut cufftComplex,
        odata: *mut cufftReal,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftExecZ2Z(
        plan: cufftHandle,
        idata: *mut cufftDoubleComplex,
        odata: *mut cufftDoubleComplex,
        direction: ::std::os::raw::c_int,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftExecD2Z(
        plan: cufftHandle,
        idata: *mut cufftDoubleReal,
        odata: *mut cufftDoubleComplex,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftExecZ2D(
        plan: cufftHandle,
        idata: *mut cufftDoubleComplex,
        odata: *mut cufftDoubleReal,
    ) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftSetStream(plan: cufftHandle, stream: cudaStream_t) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftDestroy(plan: cufftHandle) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftGetVersion(version: *mut ::std::os::raw::c_int) -> cufftResult;
}
unsafe extern "C" {
    pub fn cufftGetProperty(
        type_: libraryPropertyType,
        value: *mut ::std::os::raw::c_int,
    ) -> cufftResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
